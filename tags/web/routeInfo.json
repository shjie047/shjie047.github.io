{"path":"tags/web","templateID":3,"sharedPropsHashes":{},"localProps":{"posts":[{"title":"Go Web 架构","tags":["Go","Architecture","Translate","后端","Web"],"iso8601Date":"2015-11-11T03:01:21+08:00","basename":"Go-Web-架构","body":"\n\n[原文地址](https://larry-price.com/blog/2015/06/25/architecture-for-a-golang-web-app)\n\n使用Golang来创建Web项目是一件很麻烦的事情。如果你使用Rails，那么你可能不会有这个感触。我在[Refer Madness](https://www.refer-madness.com/)中使用了下面这个架构。\n\n```\n-public/\n-views/\n-models/\n-utils/\n-controllers/\n-web/\n-main.go\n```\n\n我将打破这个体系，介绍各个目录的作用。在每个目录下，文件只能访问其同级或者上一级。这就意味着`utils`只能访问他自己和`models`，`web`只能访问它自己，`controllers`，`utils`，`models`。`models`只能访问它自己。我这么做是为了让层次清晰，防止出现递归依赖。现在来分析每一个目录，文件的作用。\n\n#### main.go\n\n`main.go`是创建依赖，获取环境变量，启动服务的主要文件。下面是它的实例。\n\n```Go\npackage main\n\nimport (\n  \"github.com/larryprice/refermadness/utils\"\n  \"github.com/larryprice/refermadness/web\"\n  \"github.com/stretchr/graceful\"\n  \"os\"\n)\n\nfunc main() {\n  isDevelopment := os.Getenv(\"ENVIRONMENT\") == \"development\"\n  dbURL := os.Getenv(\"MONGOLAB_URI\")\n  if isDevelopment {\n    dbURL = os.Getenv(\"DB_PORT_27017_TCP_ADDR\")\n  }\n\n  dbAccessor := utils.NewDatabaseAccessor(dbURL, os.Getenv(\"DATABASE_NAME\"), 0)\n  cuAccessor := utils.NewCurrentUserAccessor(1)\n  s := web.NewServer(*dbAccessor, *cuAccessor, os.Getenv(\"GOOGLE_OAUTH2_CLIENT_ID\"),\n    os.Getenv(\"GOOGLE_OAUTH2_CLIENT_SECRET\"), os.Getenv(\"SESSION_SECRET\"),\n    isDevelopment, os.Getenv(\"GOOGLE_ANALYTICS_KEY\"))\n\n  port := os.Getenv(\"PORT\")\n  if port == \"\" {\n    port = \"3000\"\n  }\n\n  graceful.Run(\":\"+port, 0, s)\n}\n\n```\n\n因为`main.go`实在最低的层级，所以它可以访问所有的目录：在这个例子里是`web`和`utils`。在这里获取了所有的环境变量并把它们注入到合适的地方。在`main.go`中创建了服务器，注入依赖，并且在配置的端口启动服务器。\n\n#### web\n\n`web`目录下是主要的服务代码，同时也包括了中间件代码。下面是`web`目录的内部结构：\n\n```\n-web/\n|-middleware/\n|-server.go\n```\n\n`server.go`包含了web server的定义。这个web server 创建了所有的web controller并且给negroni添加了中间件。下面是他的例子：\n\n```Go\npackage web\n\nimport (\n  \"github.com/codegangsta/negroni\"\n  \"github.com/goincremental/negroni-sessions\"\n  \"github.com/goincremental/negroni-sessions/cookiestore\"\n  \"github.com/gorilla/mux\"\n  \"github.com/larryprice/refermadness/controllers\"\n  \"github.com/larryprice/refermadness/utils\"\n  \"github.com/larryprice/refermadness/web/middleware\"\n  \"github.com/unrolled/secure\"\n  \"gopkg.in/unrolled/render.v1\"\n  \"html/template\"\n  \"net/http\"\n)\n\ntype Server struct {\n  *negroni.Negroni\n}\n\nfunc NewServer(dba utils.DatabaseAccessor, cua utils.CurrentUserAccessor, clientID, clientSecret,\n  sessionSecret string, isDevelopment bool, gaKey string) *Server {\n  s := Server{negroni.Classic()}\n  session := utils.NewSessionManager()\n  basePage := utils.NewBasePageCreator(cua, gaKey)\n  renderer := render.New()\n\n  router := mux.NewRouter()\n\n  // ...\n\n  accountController := controllers.NewAccountController(clientID, clientSecret, isDevelopment, session, dba, cua, basePage, renderer)\n  accountController.Register(router)\n\n  // ...\n\n  s.Use(sessions.Sessions(\"refermadness\", cookiestore.New([]byte(sessionSecret))))\n  s.Use(middleware.NewAuthenticator(dba, session, cua).Middleware())\n  s.UseHandler(router)\n  return &s\n}\n```\n\n`Server`结构体是一个`negroni.Negroni`的web server，在这个文件里有对`utils`和其他第三方包的引用，创建了一个router，一些controller，并且将controller注册到当前router。同时也引入了必要的中间件。说到中间件，下面是它的代码：\n\n```Go\npackage middleware\n\nimport (\n  \"github.com/codegangsta/negroni\"\n  \"github.com/larryprice/refermadness/utils\"\n  \"net/http\"\n)\n\ntype Database struct {\n  da utils.DatabaseAccessor\n}\n\nfunc NewDatabase(da utils.DatabaseAccessor) *Database {\n  return &Database{da}\n}\n\nfunc (d *Database) Middleware() negroni.HandlerFunc {\n  return func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n    reqSession := d.da.Clone()\n    defer reqSession.Close()\n    d.da.Set(r, reqSession)\n    next(rw, r)\n  }\n}\n```\n\n这个是通过HTTP router访问数据库session的标注中间件。基本文件是从[Brian Gesiak’s blog post on RESTful Go](http://modocache.svbtle.com/restful-go)中得到，将其修改为适合我的文件。\n\n#### controllers/\n\n这里的controller与Rails里的controller的概念很像。Controller注册自己的router，设置自己的函数调用。一个简短的例子如下：\n\n```Go\npackage controllers\n\nimport (\n  \"encoding/json\"\n  \"errors\"\n  \"github.com/gorilla/mux\"\n  \"github.com/larryprice/refermadness/models\"\n  \"github.com/larryprice/refermadness/utils\"\n  \"gopkg.in/mgo.v2/bson\"\n  \"gopkg.in/unrolled/render.v1\"\n  \"html/template\"\n  \"net/http\"\n  \"strings\"\n)\n\ntype ServiceControllerImpl struct {\n  currentUser utils.CurrentUserAccessor\n  basePage    utils.BasePageCreator\n  renderer    *render.Render\n  database    utils.DatabaseAccessor\n}\n\nfunc NewServiceController(currentUser utils.CurrentUserAccessor, basePage utils.BasePageCreator,\n  renderer *render.Render, database utils.DatabaseAccessor) *ServiceControllerImpl {\n  return &ServiceControllerImpl{\n    currentUser: currentUser,\n    basePage:    basePage,\n    renderer:    renderer,\n    database:    database,\n  }\n}\n\nfunc (sc *ServiceControllerImpl) Register(router *mux.Router) {\n  router.HandleFunc(\"/service/{id}\", sc.single)\n  // ...\n}\n\n// ...\n\ntype serviceResult struct {\n  *models.Service\n  RandomCode *models.ReferralCode\n  UserCode   *models.ReferralCode\n}\n\ntype servicePage struct {\n  utils.BasePage\n  ResultString string\n}\n\nfunc (sc *ServiceControllerImpl) single(w http.ResponseWriter, r *http.Request) {\n  data, err := sc.get(w, r)\n\n  if len(r.Header[\"Content-Type\"]) == 1 && strings.Contains(r.Header[\"Content-Type\"][0], \"application/json\") {\n    if err != nil {\n      sc.renderer.JSON(w, http.StatusBadRequest, map[string]string{\n        \"error\": err.Error(),\n      })\n      return\n    }\n    sc.renderer.JSON(w, http.StatusOK, data)\n    return\n  } else if err != nil {\n    http.Error(w, err.Error(), http.StatusBadRequest)\n  }\n\n  resultString, _ := json.Marshal(data)\n  t, _ := template.ParseFiles(\"views/layout.html\", \"views/service.html\")\n  t.Execute(w, servicePage{sc.basePage.Get(r), string(resultString)})\n}\n```\n\n#### utils/\n\n在`utils`目录下的文件提供了一些底层功能用来支持其他的代码。在这个例子中，主要是定义一个结构体来访问请求的上下文，处理session，定义一个特别的页面来继承。下面是通过访问上下文设置用户的例子：\n\n```Go\npackage utils\n\nimport (\n  \"github.com/gorilla/context\"\n  \"github.com/larryprice/refermadness/models\"\n  \"net/http\"\n)\n\ntype CurrentUserAccessor struct {\n  key int\n}\n\nfunc NewCurrentUserAccessor(key int) *CurrentUserAccessor {\n  return &CurrentUserAccessor{key}\n}\n\nfunc (cua *CurrentUserAccessor) Set(r *http.Request, user *models.User) {\n  context.Set(r, cua.key, user)\n}\n\nfunc (cua *CurrentUserAccessor) Clear(r *http.Request) {\n  context.Delete(r, cua.key)\n}\n\nfunc (cua *CurrentUserAccessor) Get(r *http.Request) *models.User {\n  if rv := context.Get(r, cua.key); rv != nil {\n    return rv.(*models.User)\n  }\n  return nil\n}\n```\n\n#### models/\n\nmodel 是为了描述数据库中的数据的数据结构。在这个例子中使用model来访问数据库，创建一个空的model，然后通过查询数据库为其赋值。下面是一个例子：\n\n```Go\npackage models\n\nimport (\n  \"gopkg.in/mgo.v2\"\n  \"gopkg.in/mgo.v2/bson\"\n  \"strings\"\n  \"time\"\n)\n\ntype Service struct {\n  // identification information\n  ID          bson.ObjectId `bson:\"_id\"`\n  Name        string        `bson:\"name\"`\n  Description string        `bson:\"description\"`\n  URL         string        `bson:\"url\"`\n  Search      string        `bson:\"search\"`\n}\n\nfunc NewService(name, description, url string, creatorID bson.ObjectId) *Service {\n  url = strings.TrimPrefix(strings.TrimPrefix(url, \"http://\"), \"https://\")\n  return &Service{\n    ID:            bson.NewObjectId(),\n    Name:          name,\n    URL:           url,\n    Description:   description,\n    Search:        strings.ToLower(name) + \";\" + strings.ToLower(description) + \";\" + strings.ToLower(url),\n  }\n}\n\nfunc (s *Service) Save(db *mgo.Database) error {\n  _, err := s.coll(db).UpsertId(s.ID, s)\n  return err\n}\n\nfunc (s *Service) FindByID(id bson.ObjectId, db *mgo.Database) error {\n  return s.coll(db).FindId(id).One(s)\n}\n\nfunc (*Service) coll(db *mgo.Database) *mgo.Collection {\n  return db.C(\"service\")\n}\n\ntype Services []Service\n\nfunc (s *Services) FindByIDs(ids []bson.ObjectId, db *mgo.Database) error {\n  return s.coll(db).Find(bson.M{\"_id\": bson.M{\"$in\": ids}}).Sort(\"name\").All(s)\n}\n\nfunc (*Services) coll(db *mgo.Database) *mgo.Collection {\n  return db.C(\"service\")\n}\n\n```\n\n#### views/\n\n将Golang的模板文件放到`views`目录下。这样，不管用什么样的模板引擎都可以直接放到`views`下。\n\n#### public/\n\n跟以前一样，这个文件都是放公开的文件的，例如`css`,`img`,`scripts`。\n\n#### 如何运行\n\n毫无疑问，我最喜欢的就是[docker](https://www.docker.com/)，因此我将使用他来运行这个应用。如果不使用docker，那么可以将文件放到`$GOPATH/src/github.com/larryprice/refermadness`,运行`go get`来获取所有的依赖，然后运行 `go run main.go`或者`go build; ./refermadness`运行程序。如果你也喜欢使用docker，那么可以直接通过`Dockerfile`来运行。\n\n```\nFROM golang:1.4\n\nRUN go get github.com/codegangsta/gin\n\nADD . /go/src/github.com/larryprice/refermadness\nWORKDIR /go/src/github.com/larryprice/refermadness\nRUN go get\n```\n\n同时我也很喜欢[compose](https://github.com/docker/compose)，所以我也通过compose 文件来运行所有的应用。我用了JSC ，SASS和mongodb，所以一下是我的`docker-compose.yml`文件。\n\n```Go\nmain:\n  build: .\n  command: gin run\n  env_file: .env\n  volumes:\n    - ./:/go/src/github.com/larryprice/refermadness\n  working_dir: /go/src/github.com/larryprice/refermadness\n  ports:\n    - \"3000:3000\"\n  links:\n    - db\nsass:\n  image: larryprice/sass\n  volumes:\n    - ./public/css:/src\njsx:\n  image: larryprice/jsx\n  volumes:\n    - ./public/scripts:/src\ndb:\n  image: mongo:3.0\n  command: mongod --smallfiles --quiet --logpath=/dev/null\n  volumes_from:\n    - dbvolume\ndbvolume:\n  image: busybox:ubuntu-14.04\n  volumes:\n    - /data/db\n```\n\n然后运行`docker-compose up`来运行所有的容器并启动服务器。\n\n\n","date":"2015-11-11"}]}}