{"path":"cates/backend/post/2017-03-19/Recipes","templateID":1,"sharedPropsHashes":{"tags":"1C8cqm"},"localProps":{"post":{"title":"OKHttp Recipes","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-199128865.jpg","iso8601Date":"2017-03-19T03:44:10+08:00","basename":"Recipes","tags":["Java","Translate","OKHttp","HTTP","Backend"],"date":"2017-03-19","cate":"backend","summary":"原文地址\n我们写了一些建议，来演示如何使用OKHttp来解决一些常见问题。\n\n同步GET\n\n下载文件，打印header，打印body。\nstring()方法对于小文档的响应来说是个既方便有高效的方法。但是如果一个文档太大（大于1M），就不要使用string()方法了，以为他会把整个文档加载到内存中,在这种情况下可以把body当作流来处理。  \n\n`Java\nprivate final OkHttpClient client = new OkHttpClient();\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(&quot;http://publicobject.com/helloworld.txt&quot;)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nHeaders responseHeaders = response.headers();\nfor (int i = 0; i &lt; responseHeaders.size(); i++) {\nSystem.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i));\n}\nSystem.out.println(response.body().string());\n\n`\n\n #### 异步GET\n 在工作线程下载文件，响应可读后回调。在响应的header准备好的时候回调。响应体可能仍然阻塞。现在OKHttp没有提供获取响应体的异步API。\n\n`Java\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(&quot;http://publicobject.com/helloworld.txt&quot;)\n    .build();\n\nclient.newCall(request).enqueue(new Callback() {\n    @Override public void onFailure(Call call, IOException e) {\n    e.printStackTrace();\n    }\n\n@Override public void onResponse(Call call, Response response) throws IOException {\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nHeaders responseHeaders = response.headers();\nfor (int i = 0, size = responseHeaders.size(); i &lt; size; i++) {\n    System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i));\n}\n\nSystem.out.println(response.body().string());\n}\n\n});\n}\n`\n\n #### 访问Header\n 总体上说Header有点像Map&lt;String,String&gt;，每一个字段都有或没有值。但是一些Header允许有多个值，就像Guava的[Multimap](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Multimap.html)。\n 例如HTTP提供多个Vary的值是很常见并且合法的。OKHttp的API在这两种情况下都能轻松使用。\n 当写入请求header的时候使用header(name,value)设置仅有一个的name和value。如果有存在的值，会先移除值再添加。 使用addHeader(name,value)添加header不会移除已经存在的header。\n 当读响应header的时候，header(name)只返回最后一个值，通常也仅有一个。如果没有值，将会返回null。以一个list的方式获取所有的值可以使用headers(name)`。\n 如果要访问所有的header，可以使用Headers类，支持坐标访问。\n\n`Java\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(&quot;https://api.github.com/repos/square/okhttp/issues&quot;)\n    .header(&quot;User-Agent&quot;, &quot;OkHttp Headers.java&quot;)\n    .addHeader(&quot;Accept&quot;, &quot;application/json; q=0.5&quot;)\n    .addHeader(&quot;Accept&quot;, &quot;application/vnd.github.v3+json&quot;)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nSystem.out.println(&quot;Server: &quot; + response.header(&quot;Server&quot;));\nSystem.out.println(&quot;Date: &quot; + response.header(&quot;Date&quot;));\nSystem.out.println(&quot;Vary: &quot; + response.headers(&quot;Vary&quot;));\n}\n`\n\n #### 使用POST发送String请求。\n 使用HTTP的POST给服务发送请求。这个例子发送了一个markdown文档到服务器用来将markdown渲染成HTML。因为整个请求是放在内存中的，所以使用此API的时候避免大文档（小于1M）。\n\n`Java\npublic static final MediaType MEDIATYPEMARKDOWN\n    = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nString postBody = &quot;&quot;\n    + &quot;Releases\\n&quot;\n    + &quot;--------\\n&quot;\n    + &quot;\\n&quot;\n    + &quot; * 1.0 May 6, 2013\\n&quot;\n    + &quot; * 1.1 June 15, 2013\\n&quot;\n    + &quot; * 1.2 August 11, 2013\\n&quot;;\n\nRequest request = new Request.Builder()\n    .url(&quot;https://api.github.com/markdown/raw&quot;)\n    .post(RequestBody.create(MEDIATYPEMARKDOWN, postBody))\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nSystem.out.println(response.body().string());\n}\n`\n\n #### 使用POST发送流\n 使用POST将请求体以流的方式发送。请求体在被写入的时候生成。这个例子直接使用了[Okio](https://github.com/square/okio)的缓冲库。可能你更熟悉OutputStream可以通过BufferedSink.outputStream获取。\n\n`Java\npublic static final MediaType MEDIATYPEMARKDOWN\n    = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequestBody requestBody = new RequestBody() {\n    @Override public MediaType contentType() {\n    return MEDIATYPEMARKDOWN;\n    }\n\n@Override public void writeTo(BufferedSink sink) throws IOException {\nsink.writeUtf8(&quot;Numbers\\n&quot;);\nsink.writeUtf8(&quot;-------\\n&quot;);\nfor (int i = 2; i &lt;= 997; i++) {\n    sink.writeUtf8(String.format(&quot; * %s = %s\\n&quot;, i, factor(i)));\n}\n}\n\nprivate String factor(int n) {\nfor (int i = 2; i &lt; n; i++) {\n    int x = n / i;\n    if (x * i == n) return factor(x) + &quot; × &quot; + i;\n}\nreturn Integer.toString(n);\n}\n\n};\n\nRequest request = new Request.Builder()\n    .url(&quot;https://api.github.com/markdown/raw&quot;)\n    .post(requestBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nSystem.out.println(response.body().string());\n}\n`\n\n #### 使用POST发送一个文件\n 文件很容易当作一个请求体。\n\n`Java\npublic static final MediaType MEDIATYPEMARKDOWN\n    = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nFile file = new File(&quot;README.md&quot;);\n\nRequest request = new Request.Builder()\n    .url(&quot;https://api.github.com/markdown/raw&quot;)\n    .post(RequestBody.create(MEDIATYPEMARKDOWN, file))\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nSystem.out.println(response.body().string());\n}\n`\n\n #### 发送form 参数\n 使用FormBody.Builder来创建一个同HTML 的form标签方式相同的请求踢。名字和值会被编码成HTML兼容的URL编码。\n\n`Java\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequestBody formBody = new FormBody.Builder()\n    .add(&quot;search&quot;, &quot;Jurassic Park&quot;)\n    .build();\nRequest request = new Request.Builder()\n    .url(&quot;https://en.wikipedia.org/w/index.php&quot;)\n    .post(formBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nSystem.out.println(response.body().string());\n}\n`\n\n #### 发送multipart请求\n MultipartBody.Builder可以创建和HTML上传文件兼容的请求。每一个multipart请求体自身也是请求体，可以有自己的header。如果提供了，这些header仅描述自身的一部分，例如Content-Dispositon。Content-Type,Content-Length如果可用会自动添加。\n\n`Java\nprivate static final String IMGURCLIENTID = &quot;...&quot;;\nprivate static final MediaType MEDIATYPEPNG = MediaType.parse(&quot;image/png&quot;);\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\n// Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image\nRequestBody requestBody = new MultipartBody.Builder()\n    .setType(MultipartBody.FORM)\n    .addFormDataPart(&quot;title&quot;, &quot;Square Logo&quot;)\n    .addFormDataPart(&quot;image&quot;, &quot;logo-square.png&quot;,\n        RequestBody.create(MEDIATYPEPNG, new File(&quot;website/static/logo-square.png&quot;)))\n    .build();\n\nRequest request = new Request.Builder()\n    .header(&quot;Authorization&quot;, &quot;Client-ID &quot; + IMGURCLIENTID)\n    .url(&quot;https://api.imgur.com/3/image&quot;)\n    .post(requestBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nSystem.out.println(response.body().string());\n}\n\n #### 使用Gson解析响应JSON\n [Gson](http://code.google.com/p/google-gson/)是一个很顺手的转换Java对象和JSON的API。这里我们用它来解析GitHub响应的JSON。\n 注意，ResponseBody.charStream()使用content-type`的响应header来选择解码响应流的字符集，如果没有提供默认使用UTF-8。\n\n`Java\nprivate final OkHttpClient client = new OkHttpClient();\nprivate final Gson gson = new Gson();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(&quot;https://api.github.com/gists/c2a7c39532239ff261be&quot;)\n    .build();\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nGist gist = gson.fromJson(response.body().charStream(), Gist.class);\nfor (Map.Entry&lt;String, GistFile&gt; entry : gist.files.entrySet()) {\n    System.out.println(entry.getKey());\n    System.out.println(entry.getValue().content);\n}\n}\n\nstatic class Gist {\nMap&lt;String, GistFile&gt; files;\n}\n\nstatic class GistFile {\nString content;\n}\n`\n\n #### 响应缓存\n 为了换成响应需要又一个可读写的缓存目录并且限制缓存的大小。缓存目录应该是私有的，并且非信任的应用无权访问。 同时访问一个缓冲目录回出现错误。大多数应用应该调用一次new OkHttpClient()，配置它的缓存，在其他地方使用统一个实例。否则两个缓存实例会互相损害，损坏换成，可能是你的应用崩溃。\n 响应缓存使用HTTP的header来配置。如果请求头添加了Cache-Control: max-stale=3600,OKHttp将会使用这些配置。是服务器来配置响应可以被缓存多长时间，通过响应头来配置，例如Cache-Control: max-age=9600。有一些header可以强制换成响应，强制一个网络返回或者强制一个有条件的GET确定缓存是否有效。\n\n`Java\nprivate final OkHttpClient client;\n\npublic CacheResponse(File cacheDirectory) throws Exception {\nint cacheSize = 10  1024  1024; // 10 MiB\nCache cache = new Cache(cacheDirectory, cacheSize);\n\nclient = new OkHttpClient.Builder()\n    .cache(cache)\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(&quot;http://publicobject.com/helloworld.txt&quot;)\n    .build();\n\nResponse response1 = client.newCall(request).execute();\nif (!response1.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response1);\n\nString response1Body = response1.body().string();\nSystem.out.println(&quot;Response 1 response:          &quot; + response1);\nSystem.out.println(&quot;Response 1 cache response:    &quot; + response1.cacheResponse());\nSystem.out.println(&quot;Response 1 network response:  &quot; + response1.networkResponse());\n\nResponse response2 = client.newCall(request).execute();\nif (!response2.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response2);\n\nString response2Body = response2.body().string();\nSystem.out.println(&quot;Response 2 response:          &quot; + response2);\nSystem.out.println(&quot;Response 2 cache response:    &quot; + response2.cacheResponse());\nSystem.out.println(&quot;Response 2 network response:  &quot; + response2.networkResponse());\n\nSystem.out.println(&quot;Response 2 equals Response 1? &quot; + response1Body.equals(response2Body));\n}\n`\n\n 为了阻止缓冲可以使用[CacheControl.FORCE_NETWORK](CacheControl.FORCE_NETWORK).为了阻止网络连接可以使用[CacheControl.FORCE_CACHE](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CacheControl.html#FORCE_CACHE)。警告：如果使用了FORCE_CACHE并且响应需要网络，将会返回504 Unsatisfiable Request。\n #### 取消请求\n 使用Call.cancel()立即取消正在进行的请求。如果一个线程正在写一个请求或者读一个响应将会抛出IOException。当一个请求不在需要的时候使用这个函数来保护网络。例如当用户导航离开应用的时候。同步和异步的请求都可以取消。\n\n`Java\nprivate final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay.\n    .build();\n\nfinal long startNanos = System.nanoTime();\nfinal Call call = client.newCall(request);\n\n// Schedule a job to cancel the call in 1 second.\nexecutor.schedule(new Runnable() {\n    @Override public void run() {\n    System.out.printf(&quot;%.2f Canceling call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);\n    call.cancel();\n    System.out.printf(&quot;%.2f Canceled call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);\n    }\n}, 1, TimeUnit.SECONDS);\n\ntry {\n    System.out.printf(&quot;%.2f Executing call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);\n    Response response = call.execute();\n    System.out.printf(&quot;%.2f Call was expected to fail, but completed: %s%n&quot;,\n        (System.nanoTime() - startNanos) / 1e9f, response);\n} catch (IOException e) {\n    System.out.printf(&quot;%.2f Call failed as expected: %s%n&quot;,\n        (System.nanoTime() - startNanos) / 1e9f, e);\n}\n}\n`\n\n #### 超时\n 当端点不可达的时候使用超时使请求失败。网络分区可能是客户端连接问题，服务器可用性问题或者其他问题。OKHttp支持连接，读，写超时。\n\n`Java\nprivate final OkHttpClient client;\n\npublic ConfigureTimeouts() throws Exception {\nclient = new OkHttpClient.Builder()\n    .connectTimeout(10, TimeUnit.SECONDS)\n    .writeTimeout(10, TimeUnit.SECONDS)\n    .readTimeout(30, TimeUnit.SECONDS)\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay.\n    .build();\n\nResponse response = client.newCall(request).execute();\nSystem.out.println(&quot;Response completed: &quot; + response);\n}\n `\n\n #### 调用前配置\n 所有的HTTP调用配置都会在OkHttpClient中，包括，代理设置，超时和缓存。当需要修改某个调用的配置的时候，使用OKHttpClient.newBuilder()。这个函数会返回共享的连接池，调度器，并且跟原始client相同的配置。在下面这个例子中，一个请求的超时时间是500ms另一个是3000ms。\n\n `Java\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(&quot;http://httpbin.org/delay/1&quot;) // This URL is served with a 1 second delay.\n    .build();\n\ntry {\n    // Copy to customize OkHttp for this request.\n    OkHttpClient copy = client.newBuilder()\n        .readTimeout(500, TimeUnit.MILLISECONDS)\n        .build();\n\nResponse response = copy.newCall(request).execute();\nSystem.out.println(&quot;Response 1 succeeded: &quot; + response);\n\n} catch (IOException e) {\n    System.out.println(&quot;Response 1 failed: &quot; + e);\n}\n\ntry {\n    // Copy to customize OkHttp for this request.\n    OkHttpClient copy = client.newBuilder()\n        .readTimeout(3000, TimeUnit.MILLISECONDS)\n        .build();\n\nResponse response = copy.newCall(request).execute();\nSystem.out.println(&quot;Response 2 succeeded: &quot; + response);\n\n} catch (IOException e) {\n    System.out.println(&quot;Response 2 failed: &quot; + e);\n}\n}\n `\n\n #### 处理认证\n OKHttp会自动重试认证请求。当响应是401 Not Authorized,Authenticator需要用来提供凭证。将会重新实现一个带有凭证的请求，如果没有凭证可用跳过重试，返回null。\n 使用 Response.challenges()来获取任何认证口令的方案和域。当使用Basic认证的时候使用Credentials.basic(username,password)来编码一个header。\n\n`Java\nprivate final OkHttpClient client;\n\npublic Authenticate() {\nclient = new OkHttpClient.Builder()\n    .authenticator(new Authenticator() {\n        @Override public Request authenticate(Route route, Response response) throws IOException {\n        System.out.println(&quot;Authenticating for response: &quot; + response);\n        System.out.println(&quot;Challenges: &quot; + response.challenges());\n        String credential = Credentials.basic(&quot;jesse&quot;, &quot;password1&quot;);\n        return response.request().newBuilder()\n            .header(&quot;Authorization&quot;, credential)\n            .build();\n        }\n    })\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(&quot;http://publicobject.com/secrets/hellosecret.txt&quot;)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nSystem.out.println(response.body().string());\n}\n`","readingtime":22,"url":"/cates/backend/post/2017-03-19/Recipes","dirs":["okhttp"],"relatives":[{"url":"/cates/backend/post/2017-03-18/calls","title":"OKHttp的调用"},{"url":"/cates/backend/post/2017-03-19/connections","title":"OKHttp connections"},{"url":"/cates/backend/post/2017-03-23/https","title":"OKHttp https"},{"url":"/cates/backend/post/2017-03-19/interceptors","title":"OKHttp 拦截器"}],"body":"\n\n[原文地址](https://github.com/square/okhttp/wiki/Recipes)\n我们写了一些建议，来演示如何使用OKHttp来解决一些常见问题。\n\n#### 同步GET\n下载文件，打印header，打印body。\n`string()`方法对于小文档的响应来说是个既方便有高效的方法。但是如果一个文档太大（大于1M），就不要使用`string()`方法了，以为他会把整个文档加载到内存中,在这种情况下可以把body当作流来处理。  \n\n```Java\nprivate final OkHttpClient client = new OkHttpClient();\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://publicobject.com/helloworld.txt\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nHeaders responseHeaders = response.headers();\nfor (int i = 0; i < responseHeaders.size(); i++) {\nSystem.out.println(responseHeaders.name(i) + \": \" + responseHeaders.value(i));\n}\nSystem.out.println(response.body().string());\n    \n```\n\n #### 异步GET\n 在工作线程下载文件，响应可读后回调。在响应的header准备好的时候回调。响应体可能仍然阻塞。现在OKHttp没有提供获取响应体的异步API。\n\n```Java\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://publicobject.com/helloworld.txt\")\n    .build();\n\nclient.newCall(request).enqueue(new Callback() {\n    @Override public void onFailure(Call call, IOException e) {\n    e.printStackTrace();\n    }\n\n    @Override public void onResponse(Call call, Response response) throws IOException {\n    if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n    Headers responseHeaders = response.headers();\n    for (int i = 0, size = responseHeaders.size(); i < size; i++) {\n        System.out.println(responseHeaders.name(i) + \": \" + responseHeaders.value(i));\n    }\n\n    System.out.println(response.body().string());\n    }\n});\n}\n```\n\n #### 访问Header\n 总体上说Header有点像`Map<String,String>`，每一个字段都有或没有值。但是一些Header允许有多个值，就像Guava的`[Multimap](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Multimap.html)`。\n 例如HTTP提供多个Vary`的值是很常见并且合法的。OKHttp的API在这两种情况下都能轻松使用。\n 当写入请求header的时候使用`header(name,value)`设置仅有一个的`name`和`value`。如果有存在的值，会先移除值再添加。 使用`addHeader(name,value)`添加header不会移除已经存在的header。\n 当读响应header的时候，`header(name)`只返回最后一个值，通常也仅有一个。如果没有值，将会返回null。以一个list的方式获取所有的值可以使用`headers(name)`。\n 如果要访问所有的header，可以使用Headers类，支持坐标访问。\n\n```Java\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/repos/square/okhttp/issues\")\n    .header(\"User-Agent\", \"OkHttp Headers.java\")\n    .addHeader(\"Accept\", \"application/json; q=0.5\")\n    .addHeader(\"Accept\", \"application/vnd.github.v3+json\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(\"Server: \" + response.header(\"Server\"));\nSystem.out.println(\"Date: \" + response.header(\"Date\"));\nSystem.out.println(\"Vary: \" + response.headers(\"Vary\"));\n}\n```\n\n #### 使用POST发送String请求。\n 使用HTTP的POST给服务发送请求。这个例子发送了一个markdown文档到服务器用来将markdown渲染成HTML。因为整个请求是放在内存中的，所以使用此API的时候避免大文档（小于1M）。\n\n```Java\npublic static final MediaType MEDIA_TYPE_MARKDOWN\n    = MediaType.parse(\"text/x-markdown; charset=utf-8\");\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nString postBody = \"\"\n    + \"Releases\\n\"\n    + \"--------\\n\"\n    + \"\\n\"\n    + \" * _1.0_ May 6, 2013\\n\"\n    + \" * _1.1_ June 15, 2013\\n\"\n    + \" * _1.2_ August 11, 2013\\n\";\n\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/markdown/raw\")\n    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n\n #### 使用POST发送流\n 使用POST将请求体以流的方式发送。请求体在被写入的时候生成。这个例子直接使用了`[Okio](https://github.com/square/okio)`的缓冲库。可能你更熟悉`OutputStream`可以通过`BufferedSink.outputStream`获取。\n\n\n```Java\npublic static final MediaType MEDIA_TYPE_MARKDOWN\n    = MediaType.parse(\"text/x-markdown; charset=utf-8\");\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequestBody requestBody = new RequestBody() {\n    @Override public MediaType contentType() {\n    return MEDIA_TYPE_MARKDOWN;\n    }\n\n    @Override public void writeTo(BufferedSink sink) throws IOException {\n    sink.writeUtf8(\"Numbers\\n\");\n    sink.writeUtf8(\"-------\\n\");\n    for (int i = 2; i <= 997; i++) {\n        sink.writeUtf8(String.format(\" * %s = %s\\n\", i, factor(i)));\n    }\n    }\n\n    private String factor(int n) {\n    for (int i = 2; i < n; i++) {\n        int x = n / i;\n        if (x * i == n) return factor(x) + \" × \" + i;\n    }\n    return Integer.toString(n);\n    }\n};\n\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/markdown/raw\")\n    .post(requestBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n\n #### 使用POST发送一个文件\n 文件很容易当作一个请求体。\n\n```Java\npublic static final MediaType MEDIA_TYPE_MARKDOWN\n    = MediaType.parse(\"text/x-markdown; charset=utf-8\");\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nFile file = new File(\"README.md\");\n\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/markdown/raw\")\n    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n\n #### 发送form 参数\n 使用`FormBody.Builder`来创建一个同HTML 的`form`标签方式相同的请求踢。名字和值会被编码成HTML兼容的URL编码。\n\n```Java\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequestBody formBody = new FormBody.Builder()\n    .add(\"search\", \"Jurassic Park\")\n    .build();\nRequest request = new Request.Builder()\n    .url(\"https://en.wikipedia.org/w/index.php\")\n    .post(formBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n\n #### 发送multipart请求\n `MultipartBody.Builder`可以创建和HTML上传文件兼容的请求。每一个multipart请求体自身也是请求体，可以有自己的header。如果提供了，这些header仅描述自身的一部分，例如`Content-Dispositon`。`Content-Type`,`Content-Length`如果可用会自动添加。\n \n```Java\nprivate static final String IMGUR_CLIENT_ID = \"...\";\nprivate static final MediaType MEDIA_TYPE_PNG = MediaType.parse(\"image/png\");\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\n// Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image\nRequestBody requestBody = new MultipartBody.Builder()\n    .setType(MultipartBody.FORM)\n    .addFormDataPart(\"title\", \"Square Logo\")\n    .addFormDataPart(\"image\", \"logo-square.png\",\n        RequestBody.create(MEDIA_TYPE_PNG, new File(\"website/static/logo-square.png\")))\n    .build();\n\nRequest request = new Request.Builder()\n    .header(\"Authorization\", \"Client-ID \" + IMGUR_CLIENT_ID)\n    .url(\"https://api.imgur.com/3/image\")\n    .post(requestBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n #### 使用Gson解析响应JSON\n [Gson](http://code.google.com/p/google-gson/)是一个很顺手的转换Java对象和JSON的API。这里我们用它来解析GitHub响应的JSON。\n 注意，`ResponseBody.charStream()`使用`content-type`的响应header来选择解码响应流的字符集，如果没有提供默认使用UTF-8。\n\n```Java\nprivate final OkHttpClient client = new OkHttpClient();\nprivate final Gson gson = new Gson();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/gists/c2a7c39532239ff261be\")\n    .build();\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nGist gist = gson.fromJson(response.body().charStream(), Gist.class);\nfor (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {\n    System.out.println(entry.getKey());\n    System.out.println(entry.getValue().content);\n}\n}\n\nstatic class Gist {\nMap<String, GistFile> files;\n}\n\nstatic class GistFile {\nString content;\n}\n```\n\n #### 响应缓存\n 为了换成响应需要又一个可读写的缓存目录并且限制缓存的大小。缓存目录应该是私有的，并且非信任的应用无权访问。  \n 同时访问一个缓冲目录回出现错误。大多数应用应该调用一次`new OkHttpClient()`，配置它的缓存，在其他地方使用统一个实例。否则两个缓存实例会互相损害，损坏换成，可能是你的应用崩溃。\n 响应缓存使用HTTP的header来配置。如果请求头添加了`Cache-Control: max-stale=3600`,OKHttp将会使用这些配置。是服务器来配置响应可以被缓存多长时间，通过响应头来配置，例如`Cache-Control: max-age=9600`。有一些header可以强制换成响应，强制一个网络返回或者强制一个有条件的GET确定缓存是否有效。\n \n```Java\nprivate final OkHttpClient client;\n\npublic CacheResponse(File cacheDirectory) throws Exception {\nint cacheSize = 10 * 1024 * 1024; // 10 MiB\nCache cache = new Cache(cacheDirectory, cacheSize);\n\nclient = new OkHttpClient.Builder()\n    .cache(cache)\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://publicobject.com/helloworld.txt\")\n    .build();\n\nResponse response1 = client.newCall(request).execute();\nif (!response1.isSuccessful()) throw new IOException(\"Unexpected code \" + response1);\n\nString response1Body = response1.body().string();\nSystem.out.println(\"Response 1 response:          \" + response1);\nSystem.out.println(\"Response 1 cache response:    \" + response1.cacheResponse());\nSystem.out.println(\"Response 1 network response:  \" + response1.networkResponse());\n\nResponse response2 = client.newCall(request).execute();\nif (!response2.isSuccessful()) throw new IOException(\"Unexpected code \" + response2);\n\nString response2Body = response2.body().string();\nSystem.out.println(\"Response 2 response:          \" + response2);\nSystem.out.println(\"Response 2 cache response:    \" + response2.cacheResponse());\nSystem.out.println(\"Response 2 network response:  \" + response2.networkResponse());\n\nSystem.out.println(\"Response 2 equals Response 1? \" + response1Body.equals(response2Body));\n}\n```\n\n 为了阻止缓冲可以使用`[CacheControl.FORCE_NETWORK](CacheControl.FORCE_NETWORK)`.为了阻止网络连接可以使用`[CacheControl.FORCE_CACHE](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CacheControl.html#FORCE_CACHE)`。警告：如果使用了`FORCE_CACHE`并且响应需要网络，将会返回`504 Unsatisfiable Request`。\n #### 取消请求\n 使用`Call.cancel()`立即取消正在进行的请求。如果一个线程正在写一个请求或者读一个响应将会抛出IOException。当一个请求不在需要的时候使用这个函数来保护网络。例如当用户导航离开应用的时候。同步和异步的请求都可以取消。\n \n```Java\nprivate final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://httpbin.org/delay/2\") // This URL is served with a 2 second delay.\n    .build();\n\nfinal long startNanos = System.nanoTime();\nfinal Call call = client.newCall(request);\n\n// Schedule a job to cancel the call in 1 second.\nexecutor.schedule(new Runnable() {\n    @Override public void run() {\n    System.out.printf(\"%.2f Canceling call.%n\", (System.nanoTime() - startNanos) / 1e9f);\n    call.cancel();\n    System.out.printf(\"%.2f Canceled call.%n\", (System.nanoTime() - startNanos) / 1e9f);\n    }\n}, 1, TimeUnit.SECONDS);\n\ntry {\n    System.out.printf(\"%.2f Executing call.%n\", (System.nanoTime() - startNanos) / 1e9f);\n    Response response = call.execute();\n    System.out.printf(\"%.2f Call was expected to fail, but completed: %s%n\",\n        (System.nanoTime() - startNanos) / 1e9f, response);\n} catch (IOException e) {\n    System.out.printf(\"%.2f Call failed as expected: %s%n\",\n        (System.nanoTime() - startNanos) / 1e9f, e);\n}\n}\n```\n\n #### 超时\n 当端点不可达的时候使用超时使请求失败。网络分区可能是客户端连接问题，服务器可用性问题或者其他问题。OKHttp支持连接，读，写超时。\n \n```Java\nprivate final OkHttpClient client;\n\npublic ConfigureTimeouts() throws Exception {\nclient = new OkHttpClient.Builder()\n    .connectTimeout(10, TimeUnit.SECONDS)\n    .writeTimeout(10, TimeUnit.SECONDS)\n    .readTimeout(30, TimeUnit.SECONDS)\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://httpbin.org/delay/2\") // This URL is served with a 2 second delay.\n    .build();\n\nResponse response = client.newCall(request).execute();\nSystem.out.println(\"Response completed: \" + response);\n}\n ```\n\n #### 调用前配置\n 所有的HTTP调用配置都会在`OkHttpClient`中，包括，代理设置，超时和缓存。当需要修改某个调用的配置的时候，使用`OKHttpClient.newBuilder()`。这个函数会返回共享的连接池，调度器，并且跟原始client相同的配置。在下面这个例子中，一个请求的超时时间是500ms另一个是3000ms。\n\n ```Java\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://httpbin.org/delay/1\") // This URL is served with a 1 second delay.\n    .build();\n\ntry {\n    // Copy to customize OkHttp for this request.\n    OkHttpClient copy = client.newBuilder()\n        .readTimeout(500, TimeUnit.MILLISECONDS)\n        .build();\n\n    Response response = copy.newCall(request).execute();\n    System.out.println(\"Response 1 succeeded: \" + response);\n} catch (IOException e) {\n    System.out.println(\"Response 1 failed: \" + e);\n}\n\ntry {\n    // Copy to customize OkHttp for this request.\n    OkHttpClient copy = client.newBuilder()\n        .readTimeout(3000, TimeUnit.MILLISECONDS)\n        .build();\n\n    Response response = copy.newCall(request).execute();\n    System.out.println(\"Response 2 succeeded: \" + response);\n} catch (IOException e) {\n    System.out.println(\"Response 2 failed: \" + e);\n}\n}\n ```\n\n #### 处理认证\n OKHttp会自动重试认证请求。当响应是`401 Not Authorized`,`Authenticator`需要用来提供凭证。将会重新实现一个带有凭证的请求，如果没有凭证可用跳过重试，返回null。\n 使用` Response.challenges()`来获取任何认证口令的方案和域。当使用`Basic`认证的时候使用`Credentials.basic(username,password)`来编码一个header。\n \n```Java\nprivate final OkHttpClient client;\n\npublic Authenticate() {\nclient = new OkHttpClient.Builder()\n    .authenticator(new Authenticator() {\n        @Override public Request authenticate(Route route, Response response) throws IOException {\n        System.out.println(\"Authenticating for response: \" + response);\n        System.out.println(\"Challenges: \" + response.challenges());\n        String credential = Credentials.basic(\"jesse\", \"password1\");\n        return response.request().newBuilder()\n            .header(\"Authorization\", credential)\n            .build();\n        }\n    })\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://publicobject.com/secrets/hellosecret.txt\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n"}}}