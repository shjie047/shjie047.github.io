{"path":"cates/Frontend/post/2018-04-08/hyperapp","templateID":2,"sharedPropsHashes":{"tags":"Zpc8p0"},"localProps":{"post":{"author":"shjie047","title":"1kb的JS框架 - Hyperapp","iso8601Date":"2018-04-08T08:00:00+08:00","basename":"hyperapp","cover":"https://coding.net/u/shjie047/p/images/git/raw/master/stock-photo-249278113.jpg","tags":["前端","JS","Javascript","Frontend","Hyperapp","React","Web"],"date":"2018-04-08","cate":"Frontend","summary":"1. 概览\n\nHyperapp是最近开源的一个前端web开发框架，体积很小 -- 只有1.4kb，api很简单 -- 只有两个函数: h和app；借鉴了React、Redux和Elm的思想,\n\n它的主要要特点是：\n\n最小化 -- 用最少的代码实现了同类框架(React、Vue等)的核心功能重实效 -- 坚持函数式编程来管理状态(state)，同时提供有效的方法来处理边际效应(side effects)比如：异步action和DOM操作独立性 -- 自身集成状态管理和虚拟DOM引擎(虚拟DOM支持key更新 &amp;&amp; 生命周期事件)，没有第三方依赖\n\n下面用Hyperapp实现一个Counter的demo，实现了简单的加和减:\n\n`Javascript\n// 两个API\nimport { h, app } from &quot;hyperapp&quot;\n\n// 状态\nconst state = {\n  count: 0\n}\n\n// 用action来更新state\nconst actions = {\n  down: value =&gt; state =&gt; ({ count: state.count - value }),\n  up: value =&gt; state =&gt; ({ count: state.count + value })\n}\n\n// 用jsx来编写视图\nconst view = (state, actions) =&gt; (\n  &lt;div&gt;\n    &lt;h1&gt;{state.count}&lt;/h1&gt;\n    &lt;button onclick={() =&gt; actions.down(1)}&gt;-&lt;/button&gt;\n    &lt;button onclick={() =&gt; actions.up(1)}&gt;+&lt;/button&gt;\n  &lt;/div&gt;\n)\n\n// 把state，actions，view连接起来并渲染到页面的body元素上\napp(state, actions, view, document.body)\n`\n\n2. API\n\nHyperapp由两个函数API组成：h和app。\n\nh返回一个新的虚拟DOM节点树，app把一个新的app渲染到指定DOM元素上。\n\n以上的示例需要本地环境安装：编译器 -- Babel或者TypeScript，打包工具 -- Parcel或者Webpack，使用JSX来编写模板需要在.babelrc安装transform plugin来支持:\n\nJSON\n{\n  &quot;plugins&quot;: [[&quot;transform-react-jsx&quot;, { &quot;pragma&quot;: &quot;h&quot; }]]\n}\n\n\n2.1 JSX\n\nJSX是JS的语言扩展，可以写出和HTML类似的标签式组件，浏览器本身不支持JSX，需要配合编译器把JSX编译为hyperapp.h可以调用的代码。\n\n但是JSX并不是Hyperapp所必需的，可以直接使用hyperapp.h的api来直接编写组件，省去编译JSX的步骤：\n\n`Javascript\n\n// 直接用 h 来编写\nconst view = (state, actions) =&gt;\n  h(&quot;div&quot;, {}, [\n    h(&quot;h1&quot;, {}, state.count),\n    h(&quot;button&quot;, { onclick: () =&gt; actions.down(1) }, &quot;-&quot;),\n    h(&quot;button&quot;, { onclick: () =&gt; actions.up(1) }, &quot;+&quot;)\n  ])\n`\n\n3. 架构\n\nHyperapp编写的应用由三部分构成：state、action和view\n\n在程序初始化完成后，整个app会处于一个持续的循环执行里。通过用户或者外部事件产生的action来更新state，用virtual dom来展示view层的改动。可以把action当作一个通知Hyperapp更新状态重绘view的信号，当action处理完后，用户会看到新的状态(state)。\n\n3.1 State\n\nState是一个扁平对象，存储app的所有动态数据，用来描述app的状态。State在程序创建后不能直接修改，只能通过Action来更新。\n\nJavascript\nconst state = {\n  count: 0\n}\n\nState可以允许嵌套：\n\nJavascript\nconst state = {\n  top: {\n    count: 0\n  },\n  bottom: {\n    count: 0\n  }\n}\n\n\n3.2 Actions\n\n改变State的唯一方式是通过Action。Action是一个一元函数：接收一个参数，参数可以是任何类型；action通过返回部分state来更新当前state，新的state是action返回的部分state和当前state的组合。\n\nJavascript\nconst actions = {\n  setValue: value =&gt; ({ value })\n}\n\n\nAction还可以返回一个函数，函数接收当前state和action为参数，返回部分state:\n\nJavascript\nconst actions = {\n  setValue: value =&gt; (state, actions) =&gt; ({value: state.count - count})\n}\n\n\n3.2.1 异步Action\n\nAction用于处理边际效应（比如：写数据到数据库、发送一个请求到服务器，等等）并不是每次都需要返回一个值。你可以在一个action里或者回调函数里调用另外一个action。当Action返回Promise、undefined或者null时，不会触发视图重绘或状态更新。\n\nJavascript\nconst actions = {\n  upLater: value =&gt; (state, actions) =&gt; {\n    setTimeout(actions.up, 1000, value)\n  },\n  up: value =&gt; state =&gt; ({ count: state.count + value })\n}\n\n\nAction可以是一个async异步函数。因为async函数返回一个Promise而不是部分state，这时候需要调用另外一个action来更新state。\n\nJavascript\nconst actions = {\n  upLater: () =&gt; async (state, actions) =&gt; {\n    await new Promise(done =&gt; setTimeout(done, 1000))\n    actions.up(10)\n  },\n  up: value =&gt; state =&gt; ({ count: state.count + value })\n}\n\n\n3.2.2 嵌套的Action\n\nAction可以在命名空间里嵌套。更新深度嵌套的state就像在同样路径下声明一个action来更新部分state一样简单。\n\n`Javascript\nconst state = {\n  counter: {\n    count: 0\n  }\n}\n\nconst actions = {\n  counter: {\n    down: value =&gt; state =&gt; ({ count: state.count - value }),\n    up: value =&gt; state =&gt; ({ count: state.count + value })\n  }\n}\n`\n\n3.2.3 操作性\n\napp函数返回一个包含action的对象，可以用来更新state。暴露这个对象到外部可以方便的和其他程序或框架交互、订阅全局事件、监听鼠标或键盘输入，等等。\n\n`Javascript\nconst main = app(state, actions, view, document.body)\n\nsetInterval(main.up, 250, 1)\nsetInterval(main.down, 500, 1)\n`\n\n4. View\n\n当state改变时，view函数被执行；view函数返回一个js对象，被称作virtual dom，Hyperapp根据virtual dom来更新实际的DOM节点。\n\n`Javascript\nimport { h } from &quot;hyperapp&quot;\n\nexport const view = (state, actions) =&gt;\n  h(&quot;div&quot;, {}, [\n    h(&quot;h1&quot;, {}, state.count),\n    h(&quot;button&quot;, { onclick: () =&gt; actions.down(1) }, &quot;-&quot;),\n    h(&quot;button&quot;, { onclick: () =&gt; actions.up(1) }, &quot;+&quot;)\n  ])\n`\n\n4.1 Virtual DOM\n\nVirtual DOM使用一个树结构的js对象来描述真实DOM节点，具体形式如下：\n\nJavascript\n{\n  nodeName: &quot;div&quot;,\n  attributes: {},\n  children: [\n    {\n      nodeName: &quot;h1&quot;,\n      attributes: {},\n      children: [0]\n    },\n    {\n      nodeName: &quot;button&quot;,\n      attributes: { ... },\n      children: [&quot;-&quot;]\n    },\n    {\n      nodeName:   &quot;button&quot;,\n      attributes: { ... },\n      children: [&quot;+&quot;]\n    }\n  ]\n}\n\n\n以上便是Hyperapp的概要，在项目使用中，由于hyperapp代码短小精炼，更易于调试和扩展，推荐感兴趣的同学试用。","readingtime":11,"url":"/cates/Frontend/post/2018-04-08/hyperapp","dirs":["js"],"relatives":[{"url":"/cates/Frontend/post/2018-04-03/Here_are_examples_of_everything_new_in_ECMAScript_2016_2017_and_2018","title":"ES2016, 2017和2018到底有哪些新东西？"},{"url":"/cates/Frontend/post/2018-03-10/JavaScript_Modules_Worth_Using","title":"那些值得一用的JS库"}],"body":"\n\n## 1. 概览\n\n[Hyperapp](https://github.com/hyperapp/hyperapp)是最近开源的一个前端web开发框架，体积很小 -- 只有**1.4kb**，api很简单 -- 只有**两个函数**: h和app；借鉴了React、Redux和Elm的思想,\n\n它的主要要特点是：\n\n* **最小化** -- 用最少的代码实现了同类框架(React、Vue等)的核心功能\n\n* **重实效** -- 坚持函数式编程来管理状态(state)，同时提供有效的方法来处理边际效应(side effects)比如：异步action和DOM操作\n\n* **独立性** -- 自身集成状态管理和虚拟DOM引擎(虚拟DOM支持key更新 && 生命周期事件)，没有第三方依赖\n\n\n下面用Hyperapp实现一个**Counter**的demo，实现了简单的加和减:\n\n```Javascript\n// 两个API\nimport { h, app } from \"hyperapp\"\n\n// 状态\nconst state = {\n  count: 0\n}\n\n// 用action来更新state\nconst actions = {\n  down: value => state => ({ count: state.count - value }),\n  up: value => state => ({ count: state.count + value })\n}\n\n// 用jsx来编写视图\nconst view = (state, actions) => (\n  <div>\n    <h1>{state.count}</h1>\n    <button onclick={() => actions.down(1)}>-</button>\n    <button onclick={() => actions.up(1)}>+</button>\n  </div>\n)\n\n// 把state，actions，view连接起来并渲染到页面的body元素上\napp(state, actions, view, document.body)\n```\n\n## 2. API\n\nHyperapp由两个函数API组成：**h**和**app**。\n\n**h**返回一个新的虚拟DOM节点树，**app**把一个新的app渲染到指定DOM元素上。\n\n以上的示例需要本地环境安装：编译器 -- Babel或者TypeScript，打包工具 -- Parcel或者Webpack，使用JSX来编写模板需要在**.babelrc**安装[transform plugin](https://babeljs.io/docs/plugins/transform-react-jsx)来支持:\n\n```JSON\n{\n  \"plugins\": [[\"transform-react-jsx\", { \"pragma\": \"h\" }]]\n}\n```\n\n### 2.1 JSX\n\n[JSX](https://en.wikipedia.org/wiki/React_(JavaScript_library)#JSX)是JS的语言扩展，可以写出和HTML类似的标签式组件，浏览器本身不支持JSX，需要配合编译器把JSX编译为hyperapp.h可以调用的代码。\n\n但是JSX并不是Hyperapp所必需的，可以直接使用hyperapp.h的api来直接编写组件，省去编译JSX的步骤：\n\n```Javascript\n\n// 直接用 `h` 来编写\nconst view = (state, actions) =>\n  h(\"div\", {}, [\n    h(\"h1\", {}, state.count),\n    h(\"button\", { onclick: () => actions.down(1) }, \"-\"),\n    h(\"button\", { onclick: () => actions.up(1) }, \"+\")\n  ])\n```\n\n## 3. 架构\n\nHyperapp编写的应用由三部分构成：**state**、**action**和**view**\n\n在程序初始化完成后，整个app会处于一个持续的循环执行里。通过用户或者外部事件产生的action来更新state，用virtual dom来展示view层的改动。可以把action当作一个通知Hyperapp更新状态重绘view的信号，当action处理完后，用户会看到新的状态(state)。\n\n### 3.1 State\n\n`State`是一个扁平对象，存储app的所有动态数据，用来描述app的状态。`State`在程序创建后不能直接修改，只能通过`Action`来更新。\n\n```Javascript\nconst state = {\n  count: 0\n}\n```\n`State`可以允许嵌套：\n\n```Javascript\nconst state = {\n  top: {\n    count: 0\n  },\n  bottom: {\n    count: 0\n  }\n}\n```\n\n### 3.2 Actions\n\n改变`State`的唯一方式是通过`Action`。`Action`是一个一元函数：接收一个参数，参数可以是任何类型；action通过返回**部分state**来更新**当前state**，**新的state**是action返回的**部分state**和**当前state**的组合。\n\n```Javascript\nconst actions = {\n  setValue: value => ({ value })\n}\n```\n\n`Action`还可以返回一个函数，函数接收当前state和action为参数，返回部分state:\n\n```Javascript\nconst actions = {\n  setValue: value => (state, actions) => ({value: state.count - count})\n}\n```\n\n####  3.2.1 异步Action\n\n`Action`用于处理边际效应（比如：写数据到数据库、发送一个请求到服务器，等等）并不是每次都需要返回一个值。你可以在一个action里或者回调函数里调用另外一个action。当`Action`返回`Promise`、`undefined`或者`null`时，不会触发视图重绘或状态更新。\n\n```Javascript\nconst actions = {\n  upLater: value => (state, actions) => {\n    setTimeout(actions.up, 1000, value)\n  },\n  up: value => state => ({ count: state.count + value })\n}\n```\n\n`Action`可以是一个`async`异步函数。因为async函数返回一个Promise而不是部分state，这时候需要调用另外一个action来更新state。\n\n```Javascript\nconst actions = {\n  upLater: () => async (state, actions) => {\n    await new Promise(done => setTimeout(done, 1000))\n    actions.up(10)\n  },\n  up: value => state => ({ count: state.count + value })\n}\n```\n\n### 3.2.2 嵌套的Action\n\n`Action`可以在命名空间里嵌套。更新深度嵌套的state就像在同样路径下声明一个action来更新部分state一样简单。\n\n```Javascript\nconst state = {\n  counter: {\n    count: 0\n  }\n}\n\nconst actions = {\n  counter: {\n    down: value => state => ({ count: state.count - value }),\n    up: value => state => ({ count: state.count + value })\n  }\n}\n```\n\n#### 3.2.3 操作性\n\napp函数返回一个包含action的对象，可以用来更新state。暴露这个对象到外部可以方便的和其他程序或框架交互、订阅全局事件、监听鼠标或键盘输入，等等。\n\n```Javascript\nconst main = app(state, actions, view, document.body)\n\nsetInterval(main.up, 250, 1)\nsetInterval(main.down, 500, 1)\n```\n\n### 4. View\n\n当state改变时，view函数被执行；view函数返回一个js对象，被称作virtual dom，Hyperapp根据virtual dom来更新实际的DOM节点。\n\n```Javascript\nimport { h } from \"hyperapp\"\n\nexport const view = (state, actions) =>\n  h(\"div\", {}, [\n    h(\"h1\", {}, state.count),\n    h(\"button\", { onclick: () => actions.down(1) }, \"-\"),\n    h(\"button\", { onclick: () => actions.up(1) }, \"+\")\n  ])\n```\n\n### 4.1 Virtual DOM\n\n`Virtual DOM`使用一个树结构的js对象来描述真实DOM节点，具体形式如下：\n\n```Javascript\n{\n  nodeName: \"div\",\n  attributes: {},\n  children: [\n    {\n      nodeName: \"h1\",\n      attributes: {},\n      children: [0]\n    },\n    {\n      nodeName: \"button\",\n      attributes: { ... },\n      children: [\"-\"]\n    },\n    {\n      nodeName:   \"button\",\n      attributes: { ... },\n      children: [\"+\"]\n    }\n  ]\n}\n```\n\n以上便是Hyperapp的概要，在项目使用中，由于hyperapp代码短小精炼，更易于调试和扩展，推荐感兴趣的同学试用。\n"}}}