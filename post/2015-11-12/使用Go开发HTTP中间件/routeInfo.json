{"path":"post/2015-11-12/使用Go开发HTTP中间件","templateID":2,"sharedPropsHashes":{},"localProps":{"post":{"title":"使用Go开发HTTP中间件","tags":["HTTP","Go","Middleware","backend"],"iso8601Date":"2015-11-12T20:07:49+08:00","basename":"使用Go开发HTTP中间件","body":"\n[原文地址](https://justinas.org/writing-http-middleware-in-go/)\n\n 再web开发的背景下，“中间件”通常意思是“包装原始应用并添加一些额外的功能的应用的一部分”。这个概念似乎总是不被人理解，但是我认为中间件非常棒。\n 首先，一个好的中间件有一个责任就是可插拔并且自足。这就意味着你可以在接口级别嵌入你的中间件他就能直接运行。它不会影响你编码方式，不是框架，仅仅是你请求处理里面的一层而已。完全没必要重写你的代码，如果你想使用中间件的一个功能，你就帮他插入到那里，如果不想使用了，就可以直接移除。\n 纵观Go语言，中间件是非常普遍的，即使在标准库中。虽然开始的时候不会那么明显，在标准库`net/http`中的函数`StripText`或者`TimeoutHandler`就是我们要定义和的中间件的样子，处理请求和相应的时候他们包装你的handler，并处理一些额外的步骤。\n 我最近写的Go包[nosurf](https://github.com/justinas/nosurf)同样也是个中间件。我特意将他从头开始设计。在大多数情况下，你不需要在应用层担心CSRF攻击，nosurf像其他的中间件一样可以自足，并且和`net/http`的接口无缝衔接。\n 同样你还可以使用中间件做：\n* 隐藏长度防止缓冲攻击\n* 速度限制\n* 屏蔽爬虫\n* 提供调试信息\n* 添加HSTS，X-Frame-Options头\n* 从错误中恢复\n* 等等\n\n### 编写一个简单的中间件\n\n 我们的第一个例子是写一个只允许一个域名下的用户访问的中间件，通过HTTP的`HOST`header实现。这样的中间件可以防止[主机欺骗攻击](http://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html)。\n\n### 类型的机构\n\n 首先我们定义一个结构体，叫做`SingleHost`\n\n```Go\ntype SingleHost struct {\n    handler     http.Handler\n    allowedHost string\n}\n```\n\n 它只包含两个field。\n* 如果是一个可用的Host，那么我们会调用嵌入的handler。\n* allowedHost 就是允许的Host。\n 因为我们将其首字母小写，因此他们只对本包可见。我们需要给它定义已给构造函数。\n\n```Go\nfunc NewSingleHost(handler http.Handler, allowedHost string) *SingleHost {\n    return &SingleHost{handler: handler, allowedHost: allowedHost}\n}\n```\n\n### 请求处理\n\n 现在需要实现真正的逻辑功能了。想要实现`http.Handler`，我们只需要实现他的一个方法。\n\n```Go\ntype Handler interface {\n        ServeHTTP(ResponseWriter, *Request)\n}\n```\n\n 实现如下：\n\n```Go\nfunc (s *SingleHost) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    host := r.Host\n    if host == s.allowedHost {\n        s.handler.ServeHTTP(w, r)\n    } else {\n        w.WriteHeader(403)\n    }\n}\n```\n\n`ServeHTTP`只是检查请求的Host：\n* 如果Host和配置的allowed一直，那么调用handler的ServeHTTP。\n* 如果不一直返回403\n对于后一种情况，不仅不会得到应答，设置不知道有这个请求。\n现在我们已经开发哈了中间件，只需要将其插入到需要的地方。\n\n```Go\nsingleHosted = NewSingleHost(myHandler, \"example.com\")\nhttp.ListenAndServe(\":8080\", singleHosted)\n```\n\n### 另一种方式\n\n 我们刚刚写的那个中间件很简单，它只有15行代码。写这样的中间件，可以使用样板方法。由于Go支持函数为一等公民和闭包，并且有`http.HandlerFunc`包装函数，我们可以通过他创建一个中间件，而不是将其放入到一个结构体中。下面是这个中间件的写法。\n\n```Go\nfunc SingleHost(handler http.Handler, allowedHost string) http.Handler {\n    ourFunc := func(w http.ResponseWriter, r *http.Request) {\n        host := r.Host\n        if host == allowedHost {\n            handler.ServeHTTP(w, r)\n        } else {\n            w.WriteHeader(403)\n        }\n    }\n    return http.HandlerFunc(ourFunc)\n}\n```\n 我们定义了一个简单的函数`SingleHost`，它包装了`Handler`和允许的Host，在其内部我们实现了一个跟上面中间件类似的功能。我们内部的函数就是一个闭包，因此他可以访问外部函数的变量。最终HandlerFunc让我们可以将其变为Handler。\n 觉得是使用HandlerFunc还是自己实现一个http.Handler完全取决于你自己。对于简单的情况，一个简单的函数就完全够了。如果你的中间件越来越多，那么就可以考虑实现自己的结构并把它们分开。\n 同时标准库同时使用了两种功能。`StripPrefix`使用的是HandlerFunc，TimeoutHandler使用的是自定义的结构体。\n\n### 一个更复杂的例子\n\n 我们的`SingleHost`并不重要，我们只检测一个属性，要么将他传递给其他的handler，要么直接返回。然而存在这种情况，我们的程序需要对处理完进行后续处理。\n\n### 添加数据是简单的\n\n 如果只是想简单的添加数据，那么使用Write就可以了。\n\n```Go\ntype AppendMiddleware struct {\n    handler http.Handler\n}\n\nfunc (a *AppendMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    a.handler.ServeHTTP(w, r)\n    w.Write([]byte(\"Middleware says hello.\"))\n}\n```\n\n 返回的结构肯定会包含`Middleware says hello.`\n\n### 问题\n\n 但是操作其他的数据有点困难。例如我们想要在它前面添加数据而不是后面追加。如果我们在原Handler之前调用Write，那么将会失去控制，因为第一个Write已经将他写入了。\n 通过其他方法修改原始输出，例如替换字符串，改变响应header，或者设置状态码都不会起作用，因为当handler返回的时候数据已经返回到客户端了。\n 为了实现这个功能，我们需要一个特殊的ResponseWriter，他可以想buffer一样工作，收集数据，存储以备使用和修改。然后我们将这个ResponseWriter传递给handler，而不是传递真是的RW，这样在其之前我们已经修改了它了。\n 幸运的是在标准库中有这样的一个工具。在`net/http/httptest`包里的ResponseRecorder能做所有我们需要的：保存状态码，一个响应header的map，将body放入byte 缓冲中。虽然它是再测试中中使用的，但是很服务我们的情况。\n\n```Go\ntype ModifierMiddleware struct {\n    handler http.Handler\n}\n\nfunc (m *ModifierMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    rec := httptest.NewRecorder()\n    // passing a ResponseRecorder instead of the original RW\n    m.handler.ServeHTTP(rec, r)\n    // after this finishes, we have the response recorded\n    // and can modify it before copying it to the original RW\n\n    // we copy the original headers first\n    for k, v := range rec.Header() {\n        w.Header()[k] = v\n    }\n    // and set an additional one\n    w.Header().Set(\"X-We-Modified-This\", \"Yup\")\n    // only then the status code, as this call writes out the headers \n    w.WriteHeader(418)\n\n    // The body hasn't been written (to the real RW) yet,\n    // so we can prepend some data.\n    data := []byte(\"Middleware says hello again. \")\n\n    // But the Content-Length might have been set already,\n    // we should modify it by adding the length\n    // of our own data.\n    // Ignoring the error is fine here:\n    // if Content-Length is empty or otherwise invalid,\n    // Atoi() will return zero,\n    // which is just what we'd want in that case.\n    clen, _ := strconv.Atoi(r.Header.Get(\"Content-Length\"))\n    clen += len(data)\n    r.Header.Set(\"Content-Length\", strconv.Itoa(clen))\n\n    // finally, write out our data\n    w.Write(data)\n    // then write out the original body\n    w.Write(rec.Body.Bytes())\n}\n```\n最后僵尸我们中间件的输出：\n\n```\nHTTP/1.1 418 I'm a teapot\nX-We-Modified-This: Yup\nContent-Type: text/plain; charset=utf-8\nContent-Length: 37\nDate: Tue, 03 Sep 2013 18:41:39 GMT\n\nMiddleware says hello again. Success!\n```\n这样就开启了一种新的可能，包装的handler完全手控制。\n\n### 和其他handler分享数据\n\n 在其他例子中，中间件可能需要暴露一些信息给其他中间件或者应用本身。例如nosurf需要给其他用户访问CSRF token的权限。\n 最简单是是使用一个map，但是通常不希望这样。它将http.Request 的指针作为key，其他数据作为value。下面是nosurf的例子，Go的map非线程安全，所以要自己是实现。\n\n```Go\ntype csrfContext struct {\n    token string\n    reason error\n}\n\nvar (\n    contextMap = make(map[*http.Request]*csrfContext)\n    cmMutex    = new(sync.RWMutex)\n)\n```\n 数据由Token设置：\n\n```Go\nfunc Token(req *http.Request) string {\n    cmMutex.RLock()\n    defer cmMutex.RUnlock()\n\n    ctx, ok := contextMap[req]\n    if !ok {\n            return \"\"\n    }\n\n    return ctx.token\n}\n```\n源码可以再nosurf的项目的[context.go](https://github.com/justinas/nosurf/blob/master/context.go)中找到。\n\n\n","date":"2015-11-12"}}}