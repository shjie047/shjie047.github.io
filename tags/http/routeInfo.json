{"path":"tags/http","templateID":3,"sharedPropsHashes":{},"localProps":{"posts":[{"title":"HTTP/2 和GO","tags":["http","HTTP/2","Translate","Go","backend"],"iso8601Date":"2015-11-12T19:39:21+08:00","basename":"HTTP-2-和GO","body":"\n[原文地址](https://www.ianlewis.org/en/http2-and-go)\n\nHTTP/2是一个添加了一些新功能的HTTP的新版本，这些功能包括连接复用，首部压缩。再Go的标准库中暂时还没有HTTP/2的实现，但是现在有很多正在开发的库可以用来在Go中实现HTTP/2的server和client。\n\nBrad Fitzpatrick实现了一个[golang.org/x/net/http2](https://godoc.org/golang.org/x/net/http2)的库，这个库甚至最终会加入到标准库中，不过他现在正在开发，所以在其他的库中。因为他现在的开发很活跃，所有情况因人而异，但是如果你想实现HTTP/2的服务器，仍然可以使用这个库。\n\n### 创建HTTP/2服务器\n\n使用http2的库写一个服务器是很简单的。http2库和标准库的http包集成在一起，需要调用`http2.ConfigureServer()`来配置一个普通http使用HTTP/2协议。如果需要通过浏览器访问或者降级到HTTP 1.x 协议，那么你需要设置TLS 加密。虽然加密不是必须的，但是现在还没有浏览器支持非加密的HTTP/2协议。\n\n```Go\npackage main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"os\"\n\n    \"golang.org/x/net/http2\"\n)\n\nfunc main() {\n    cwd, err := os.Getwd()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    srv := &http.Server{\n        Addr:    \":8000\", // Normally \":443\"\n        Handler: http.FileServer(http.Dir(cwd)),\n    }\n    http2.ConfigureServer(srv, &http2.Server{})\n    log.Fatal(srv.ListenAndServeTLS(\"server.crt\", \"server.key\"))\n}\n```\n\n### 创建HTTP/2 客户端\n\n现在使用http2的库创建客户端很hacky。虽然它会输出很多调试日志，但是对于大多数情况下运行的很好。可以使用`http2.Transport`对象，将他传给`http`包的client。\n\n```Go\npackage main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"log\"\n    \"net/http\"\n\n    \"golang.org/x/net/http2\"\n)\n\nfunc main() {\n    client := http.Client{\n        // InsecureTLSDial is temporary and will likely be\n        // replaced by a different API later.\n        Transport: &http2.Transport{InsecureTLSDial: true},\n    }\n\n    resp, err := client.Get(\"https://localhost:8000/\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(string(body))\n}\n```\n\n### 更多阅读\n\n如果你对HTTP/2协议感兴趣，那么可以参考[HTTP/2 主页](https://http2.github.io/)，这个页面有很多其他资料的连接还有其他语言的实现。\n\n如果你想知道HTTP/2的服务端和客户端是如何实现的，那么[Jxck's http2 implementation](https://github.com/Jxck/http2)的实现就很值得一读。Jxck通过对标准的HTTP库的TLSNextProto设置一个钩子来实现的。你可以再这里阅读一些[示例](https://github.com/Jxck/http2/blob/master/sample/http.go)。\n\ngrpc-go 库同样也有自己的服务端和客户端的实现。\n","date":"2015-11-12"},{"title":"使用Go开发HTTP中间件","tags":["HTTP","Go","Middleware","backend"],"iso8601Date":"2015-11-12T20:07:49+08:00","basename":"使用Go开发HTTP中间件","body":"\n[原文地址](https://justinas.org/writing-http-middleware-in-go/)\n\n 再web开发的背景下，“中间件”通常意思是“包装原始应用并添加一些额外的功能的应用的一部分”。这个概念似乎总是不被人理解，但是我认为中间件非常棒。\n 首先，一个好的中间件有一个责任就是可插拔并且自足。这就意味着你可以在接口级别嵌入你的中间件他就能直接运行。它不会影响你编码方式，不是框架，仅仅是你请求处理里面的一层而已。完全没必要重写你的代码，如果你想使用中间件的一个功能，你就帮他插入到那里，如果不想使用了，就可以直接移除。\n 纵观Go语言，中间件是非常普遍的，即使在标准库中。虽然开始的时候不会那么明显，在标准库`net/http`中的函数`StripText`或者`TimeoutHandler`就是我们要定义和的中间件的样子，处理请求和相应的时候他们包装你的handler，并处理一些额外的步骤。\n 我最近写的Go包[nosurf](https://github.com/justinas/nosurf)同样也是个中间件。我特意将他从头开始设计。在大多数情况下，你不需要在应用层担心CSRF攻击，nosurf像其他的中间件一样可以自足，并且和`net/http`的接口无缝衔接。\n 同样你还可以使用中间件做：\n* 隐藏长度防止缓冲攻击\n* 速度限制\n* 屏蔽爬虫\n* 提供调试信息\n* 添加HSTS，X-Frame-Options头\n* 从错误中恢复\n* 等等\n\n### 编写一个简单的中间件\n\n 我们的第一个例子是写一个只允许一个域名下的用户访问的中间件，通过HTTP的`HOST`header实现。这样的中间件可以防止[主机欺骗攻击](http://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html)。\n\n### 类型的机构\n\n 首先我们定义一个结构体，叫做`SingleHost`\n\n```Go\ntype SingleHost struct {\n    handler     http.Handler\n    allowedHost string\n}\n```\n\n 它只包含两个field。\n* 如果是一个可用的Host，那么我们会调用嵌入的handler。\n* allowedHost 就是允许的Host。\n 因为我们将其首字母小写，因此他们只对本包可见。我们需要给它定义已给构造函数。\n\n```Go\nfunc NewSingleHost(handler http.Handler, allowedHost string) *SingleHost {\n    return &SingleHost{handler: handler, allowedHost: allowedHost}\n}\n```\n\n### 请求处理\n\n 现在需要实现真正的逻辑功能了。想要实现`http.Handler`，我们只需要实现他的一个方法。\n\n```Go\ntype Handler interface {\n        ServeHTTP(ResponseWriter, *Request)\n}\n```\n\n 实现如下：\n\n```Go\nfunc (s *SingleHost) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    host := r.Host\n    if host == s.allowedHost {\n        s.handler.ServeHTTP(w, r)\n    } else {\n        w.WriteHeader(403)\n    }\n}\n```\n\n`ServeHTTP`只是检查请求的Host：\n* 如果Host和配置的allowed一直，那么调用handler的ServeHTTP。\n* 如果不一直返回403\n对于后一种情况，不仅不会得到应答，设置不知道有这个请求。\n现在我们已经开发哈了中间件，只需要将其插入到需要的地方。\n\n```Go\nsingleHosted = NewSingleHost(myHandler, \"example.com\")\nhttp.ListenAndServe(\":8080\", singleHosted)\n```\n\n### 另一种方式\n\n 我们刚刚写的那个中间件很简单，它只有15行代码。写这样的中间件，可以使用样板方法。由于Go支持函数为一等公民和闭包，并且有`http.HandlerFunc`包装函数，我们可以通过他创建一个中间件，而不是将其放入到一个结构体中。下面是这个中间件的写法。\n\n```Go\nfunc SingleHost(handler http.Handler, allowedHost string) http.Handler {\n    ourFunc := func(w http.ResponseWriter, r *http.Request) {\n        host := r.Host\n        if host == allowedHost {\n            handler.ServeHTTP(w, r)\n        } else {\n            w.WriteHeader(403)\n        }\n    }\n    return http.HandlerFunc(ourFunc)\n}\n```\n 我们定义了一个简单的函数`SingleHost`，它包装了`Handler`和允许的Host，在其内部我们实现了一个跟上面中间件类似的功能。我们内部的函数就是一个闭包，因此他可以访问外部函数的变量。最终HandlerFunc让我们可以将其变为Handler。\n 觉得是使用HandlerFunc还是自己实现一个http.Handler完全取决于你自己。对于简单的情况，一个简单的函数就完全够了。如果你的中间件越来越多，那么就可以考虑实现自己的结构并把它们分开。\n 同时标准库同时使用了两种功能。`StripPrefix`使用的是HandlerFunc，TimeoutHandler使用的是自定义的结构体。\n\n### 一个更复杂的例子\n\n 我们的`SingleHost`并不重要，我们只检测一个属性，要么将他传递给其他的handler，要么直接返回。然而存在这种情况，我们的程序需要对处理完进行后续处理。\n\n### 添加数据是简单的\n\n 如果只是想简单的添加数据，那么使用Write就可以了。\n\n```Go\ntype AppendMiddleware struct {\n    handler http.Handler\n}\n\nfunc (a *AppendMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    a.handler.ServeHTTP(w, r)\n    w.Write([]byte(\"Middleware says hello.\"))\n}\n```\n\n 返回的结构肯定会包含`Middleware says hello.`\n\n### 问题\n\n 但是操作其他的数据有点困难。例如我们想要在它前面添加数据而不是后面追加。如果我们在原Handler之前调用Write，那么将会失去控制，因为第一个Write已经将他写入了。\n 通过其他方法修改原始输出，例如替换字符串，改变响应header，或者设置状态码都不会起作用，因为当handler返回的时候数据已经返回到客户端了。\n 为了实现这个功能，我们需要一个特殊的ResponseWriter，他可以想buffer一样工作，收集数据，存储以备使用和修改。然后我们将这个ResponseWriter传递给handler，而不是传递真是的RW，这样在其之前我们已经修改了它了。\n 幸运的是在标准库中有这样的一个工具。在`net/http/httptest`包里的ResponseRecorder能做所有我们需要的：保存状态码，一个响应header的map，将body放入byte 缓冲中。虽然它是再测试中中使用的，但是很服务我们的情况。\n\n```Go\ntype ModifierMiddleware struct {\n    handler http.Handler\n}\n\nfunc (m *ModifierMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    rec := httptest.NewRecorder()\n    // passing a ResponseRecorder instead of the original RW\n    m.handler.ServeHTTP(rec, r)\n    // after this finishes, we have the response recorded\n    // and can modify it before copying it to the original RW\n\n    // we copy the original headers first\n    for k, v := range rec.Header() {\n        w.Header()[k] = v\n    }\n    // and set an additional one\n    w.Header().Set(\"X-We-Modified-This\", \"Yup\")\n    // only then the status code, as this call writes out the headers \n    w.WriteHeader(418)\n\n    // The body hasn't been written (to the real RW) yet,\n    // so we can prepend some data.\n    data := []byte(\"Middleware says hello again. \")\n\n    // But the Content-Length might have been set already,\n    // we should modify it by adding the length\n    // of our own data.\n    // Ignoring the error is fine here:\n    // if Content-Length is empty or otherwise invalid,\n    // Atoi() will return zero,\n    // which is just what we'd want in that case.\n    clen, _ := strconv.Atoi(r.Header.Get(\"Content-Length\"))\n    clen += len(data)\n    r.Header.Set(\"Content-Length\", strconv.Itoa(clen))\n\n    // finally, write out our data\n    w.Write(data)\n    // then write out the original body\n    w.Write(rec.Body.Bytes())\n}\n```\n最后僵尸我们中间件的输出：\n\n```\nHTTP/1.1 418 I'm a teapot\nX-We-Modified-This: Yup\nContent-Type: text/plain; charset=utf-8\nContent-Length: 37\nDate: Tue, 03 Sep 2013 18:41:39 GMT\n\nMiddleware says hello again. Success!\n```\n这样就开启了一种新的可能，包装的handler完全手控制。\n\n### 和其他handler分享数据\n\n 在其他例子中，中间件可能需要暴露一些信息给其他中间件或者应用本身。例如nosurf需要给其他用户访问CSRF token的权限。\n 最简单是是使用一个map，但是通常不希望这样。它将http.Request 的指针作为key，其他数据作为value。下面是nosurf的例子，Go的map非线程安全，所以要自己是实现。\n\n```Go\ntype csrfContext struct {\n    token string\n    reason error\n}\n\nvar (\n    contextMap = make(map[*http.Request]*csrfContext)\n    cmMutex    = new(sync.RWMutex)\n)\n```\n 数据由Token设置：\n\n```Go\nfunc Token(req *http.Request) string {\n    cmMutex.RLock()\n    defer cmMutex.RUnlock()\n\n    ctx, ok := contextMap[req]\n    if !ok {\n            return \"\"\n    }\n\n    return ctx.token\n}\n```\n源码可以再nosurf的项目的[context.go](https://github.com/justinas/nosurf/blob/master/context.go)中找到。\n\n\n","date":"2015-11-12"},{"title":"OKHttp Recipes","tags":["Java","Translate","OKHttp","HTTP","backend"],"iso8601Date":"2017-03-19T03:44:10+08:00","basename":"Recipes","body":"\n\n[原文地址](https://github.com/square/okhttp/wiki/Recipes)\n我们写了一些建议，来演示如何使用OKHttp来解决一些常见问题。\n\n#### 同步GET\n下载文件，打印header，打印body。\n`string()`方法对于小文档的响应来说是个既方便有高效的方法。但是如果一个文档太大（大于1M），就不要使用`string()`方法了，以为他会把整个文档加载到内存中,在这种情况下可以把body当作流来处理。  \n\n```Java\nprivate final OkHttpClient client = new OkHttpClient();\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://publicobject.com/helloworld.txt\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nHeaders responseHeaders = response.headers();\nfor (int i = 0; i < responseHeaders.size(); i++) {\nSystem.out.println(responseHeaders.name(i) + \": \" + responseHeaders.value(i));\n}\nSystem.out.println(response.body().string());\n    \n```\n\n #### 异步GET\n 在工作线程下载文件，响应可读后回调。在响应的header准备好的时候回调。响应体可能仍然阻塞。现在OKHttp没有提供获取响应体的异步API。\n\n```Java\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://publicobject.com/helloworld.txt\")\n    .build();\n\nclient.newCall(request).enqueue(new Callback() {\n    @Override public void onFailure(Call call, IOException e) {\n    e.printStackTrace();\n    }\n\n    @Override public void onResponse(Call call, Response response) throws IOException {\n    if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n    Headers responseHeaders = response.headers();\n    for (int i = 0, size = responseHeaders.size(); i < size; i++) {\n        System.out.println(responseHeaders.name(i) + \": \" + responseHeaders.value(i));\n    }\n\n    System.out.println(response.body().string());\n    }\n});\n}\n```\n\n #### 访问Header\n 总体上说Header有点像`Map<String,String>`，每一个字段都有或没有值。但是一些Header允许有多个值，就像Guava的`[Multimap](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Multimap.html)`。\n 例如HTTP提供多个Vary`的值是很常见并且合法的。OKHttp的API在这两种情况下都能轻松使用。\n 当写入请求header的时候使用`header(name,value)`设置仅有一个的`name`和`value`。如果有存在的值，会先移除值再添加。 使用`addHeader(name,value)`添加header不会移除已经存在的header。\n 当读响应header的时候，`header(name)`只返回最后一个值，通常也仅有一个。如果没有值，将会返回null。以一个list的方式获取所有的值可以使用`headers(name)`。\n 如果要访问所有的header，可以使用Headers类，支持坐标访问。\n\n```Java\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/repos/square/okhttp/issues\")\n    .header(\"User-Agent\", \"OkHttp Headers.java\")\n    .addHeader(\"Accept\", \"application/json; q=0.5\")\n    .addHeader(\"Accept\", \"application/vnd.github.v3+json\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(\"Server: \" + response.header(\"Server\"));\nSystem.out.println(\"Date: \" + response.header(\"Date\"));\nSystem.out.println(\"Vary: \" + response.headers(\"Vary\"));\n}\n```\n\n #### 使用POST发送String请求。\n 使用HTTP的POST给服务发送请求。这个例子发送了一个markdown文档到服务器用来将markdown渲染成HTML。因为整个请求是放在内存中的，所以使用此API的时候避免大文档（小于1M）。\n\n```Java\npublic static final MediaType MEDIA_TYPE_MARKDOWN\n    = MediaType.parse(\"text/x-markdown; charset=utf-8\");\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nString postBody = \"\"\n    + \"Releases\\n\"\n    + \"--------\\n\"\n    + \"\\n\"\n    + \" * _1.0_ May 6, 2013\\n\"\n    + \" * _1.1_ June 15, 2013\\n\"\n    + \" * _1.2_ August 11, 2013\\n\";\n\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/markdown/raw\")\n    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n\n #### 使用POST发送流\n 使用POST将请求体以流的方式发送。请求体在被写入的时候生成。这个例子直接使用了`[Okio](https://github.com/square/okio)`的缓冲库。可能你更熟悉`OutputStream`可以通过`BufferedSink.outputStream`获取。\n\n\n```Java\npublic static final MediaType MEDIA_TYPE_MARKDOWN\n    = MediaType.parse(\"text/x-markdown; charset=utf-8\");\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequestBody requestBody = new RequestBody() {\n    @Override public MediaType contentType() {\n    return MEDIA_TYPE_MARKDOWN;\n    }\n\n    @Override public void writeTo(BufferedSink sink) throws IOException {\n    sink.writeUtf8(\"Numbers\\n\");\n    sink.writeUtf8(\"-------\\n\");\n    for (int i = 2; i <= 997; i++) {\n        sink.writeUtf8(String.format(\" * %s = %s\\n\", i, factor(i)));\n    }\n    }\n\n    private String factor(int n) {\n    for (int i = 2; i < n; i++) {\n        int x = n / i;\n        if (x * i == n) return factor(x) + \" × \" + i;\n    }\n    return Integer.toString(n);\n    }\n};\n\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/markdown/raw\")\n    .post(requestBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n\n #### 使用POST发送一个文件\n 文件很容易当作一个请求体。\n\n```Java\npublic static final MediaType MEDIA_TYPE_MARKDOWN\n    = MediaType.parse(\"text/x-markdown; charset=utf-8\");\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nFile file = new File(\"README.md\");\n\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/markdown/raw\")\n    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n\n #### 发送form 参数\n 使用`FormBody.Builder`来创建一个同HTML 的`form`标签方式相同的请求踢。名字和值会被编码成HTML兼容的URL编码。\n\n```Java\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequestBody formBody = new FormBody.Builder()\n    .add(\"search\", \"Jurassic Park\")\n    .build();\nRequest request = new Request.Builder()\n    .url(\"https://en.wikipedia.org/w/index.php\")\n    .post(formBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n\n #### 发送multipart请求\n `MultipartBody.Builder`可以创建和HTML上传文件兼容的请求。每一个multipart请求体自身也是请求体，可以有自己的header。如果提供了，这些header仅描述自身的一部分，例如`Content-Dispositon`。`Content-Type`,`Content-Length`如果可用会自动添加。\n \n```Java\nprivate static final String IMGUR_CLIENT_ID = \"...\";\nprivate static final MediaType MEDIA_TYPE_PNG = MediaType.parse(\"image/png\");\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\n// Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image\nRequestBody requestBody = new MultipartBody.Builder()\n    .setType(MultipartBody.FORM)\n    .addFormDataPart(\"title\", \"Square Logo\")\n    .addFormDataPart(\"image\", \"logo-square.png\",\n        RequestBody.create(MEDIA_TYPE_PNG, new File(\"website/static/logo-square.png\")))\n    .build();\n\nRequest request = new Request.Builder()\n    .header(\"Authorization\", \"Client-ID \" + IMGUR_CLIENT_ID)\n    .url(\"https://api.imgur.com/3/image\")\n    .post(requestBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n #### 使用Gson解析响应JSON\n [Gson](http://code.google.com/p/google-gson/)是一个很顺手的转换Java对象和JSON的API。这里我们用它来解析GitHub响应的JSON。\n 注意，`ResponseBody.charStream()`使用`content-type`的响应header来选择解码响应流的字符集，如果没有提供默认使用UTF-8。\n\n```Java\nprivate final OkHttpClient client = new OkHttpClient();\nprivate final Gson gson = new Gson();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/gists/c2a7c39532239ff261be\")\n    .build();\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nGist gist = gson.fromJson(response.body().charStream(), Gist.class);\nfor (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {\n    System.out.println(entry.getKey());\n    System.out.println(entry.getValue().content);\n}\n}\n\nstatic class Gist {\nMap<String, GistFile> files;\n}\n\nstatic class GistFile {\nString content;\n}\n```\n\n #### 响应缓存\n 为了换成响应需要又一个可读写的缓存目录并且限制缓存的大小。缓存目录应该是私有的，并且非信任的应用无权访问。  \n 同时访问一个缓冲目录回出现错误。大多数应用应该调用一次`new OkHttpClient()`，配置它的缓存，在其他地方使用统一个实例。否则两个缓存实例会互相损害，损坏换成，可能是你的应用崩溃。\n 响应缓存使用HTTP的header来配置。如果请求头添加了`Cache-Control: max-stale=3600`,OKHttp将会使用这些配置。是服务器来配置响应可以被缓存多长时间，通过响应头来配置，例如`Cache-Control: max-age=9600`。有一些header可以强制换成响应，强制一个网络返回或者强制一个有条件的GET确定缓存是否有效。\n \n```Java\nprivate final OkHttpClient client;\n\npublic CacheResponse(File cacheDirectory) throws Exception {\nint cacheSize = 10 * 1024 * 1024; // 10 MiB\nCache cache = new Cache(cacheDirectory, cacheSize);\n\nclient = new OkHttpClient.Builder()\n    .cache(cache)\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://publicobject.com/helloworld.txt\")\n    .build();\n\nResponse response1 = client.newCall(request).execute();\nif (!response1.isSuccessful()) throw new IOException(\"Unexpected code \" + response1);\n\nString response1Body = response1.body().string();\nSystem.out.println(\"Response 1 response:          \" + response1);\nSystem.out.println(\"Response 1 cache response:    \" + response1.cacheResponse());\nSystem.out.println(\"Response 1 network response:  \" + response1.networkResponse());\n\nResponse response2 = client.newCall(request).execute();\nif (!response2.isSuccessful()) throw new IOException(\"Unexpected code \" + response2);\n\nString response2Body = response2.body().string();\nSystem.out.println(\"Response 2 response:          \" + response2);\nSystem.out.println(\"Response 2 cache response:    \" + response2.cacheResponse());\nSystem.out.println(\"Response 2 network response:  \" + response2.networkResponse());\n\nSystem.out.println(\"Response 2 equals Response 1? \" + response1Body.equals(response2Body));\n}\n```\n\n 为了阻止缓冲可以使用`[CacheControl.FORCE_NETWORK](CacheControl.FORCE_NETWORK)`.为了阻止网络连接可以使用`[CacheControl.FORCE_CACHE](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CacheControl.html#FORCE_CACHE)`。警告：如果使用了`FORCE_CACHE`并且响应需要网络，将会返回`504 Unsatisfiable Request`。\n #### 取消请求\n 使用`Call.cancel()`立即取消正在进行的请求。如果一个线程正在写一个请求或者读一个响应将会抛出IOException。当一个请求不在需要的时候使用这个函数来保护网络。例如当用户导航离开应用的时候。同步和异步的请求都可以取消。\n \n```Java\nprivate final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://httpbin.org/delay/2\") // This URL is served with a 2 second delay.\n    .build();\n\nfinal long startNanos = System.nanoTime();\nfinal Call call = client.newCall(request);\n\n// Schedule a job to cancel the call in 1 second.\nexecutor.schedule(new Runnable() {\n    @Override public void run() {\n    System.out.printf(\"%.2f Canceling call.%n\", (System.nanoTime() - startNanos) / 1e9f);\n    call.cancel();\n    System.out.printf(\"%.2f Canceled call.%n\", (System.nanoTime() - startNanos) / 1e9f);\n    }\n}, 1, TimeUnit.SECONDS);\n\ntry {\n    System.out.printf(\"%.2f Executing call.%n\", (System.nanoTime() - startNanos) / 1e9f);\n    Response response = call.execute();\n    System.out.printf(\"%.2f Call was expected to fail, but completed: %s%n\",\n        (System.nanoTime() - startNanos) / 1e9f, response);\n} catch (IOException e) {\n    System.out.printf(\"%.2f Call failed as expected: %s%n\",\n        (System.nanoTime() - startNanos) / 1e9f, e);\n}\n}\n```\n\n #### 超时\n 当端点不可达的时候使用超时使请求失败。网络分区可能是客户端连接问题，服务器可用性问题或者其他问题。OKHttp支持连接，读，写超时。\n \n```Java\nprivate final OkHttpClient client;\n\npublic ConfigureTimeouts() throws Exception {\nclient = new OkHttpClient.Builder()\n    .connectTimeout(10, TimeUnit.SECONDS)\n    .writeTimeout(10, TimeUnit.SECONDS)\n    .readTimeout(30, TimeUnit.SECONDS)\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://httpbin.org/delay/2\") // This URL is served with a 2 second delay.\n    .build();\n\nResponse response = client.newCall(request).execute();\nSystem.out.println(\"Response completed: \" + response);\n}\n ```\n\n #### 调用前配置\n 所有的HTTP调用配置都会在`OkHttpClient`中，包括，代理设置，超时和缓存。当需要修改某个调用的配置的时候，使用`OKHttpClient.newBuilder()`。这个函数会返回共享的连接池，调度器，并且跟原始client相同的配置。在下面这个例子中，一个请求的超时时间是500ms另一个是3000ms。\n\n ```Java\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://httpbin.org/delay/1\") // This URL is served with a 1 second delay.\n    .build();\n\ntry {\n    // Copy to customize OkHttp for this request.\n    OkHttpClient copy = client.newBuilder()\n        .readTimeout(500, TimeUnit.MILLISECONDS)\n        .build();\n\n    Response response = copy.newCall(request).execute();\n    System.out.println(\"Response 1 succeeded: \" + response);\n} catch (IOException e) {\n    System.out.println(\"Response 1 failed: \" + e);\n}\n\ntry {\n    // Copy to customize OkHttp for this request.\n    OkHttpClient copy = client.newBuilder()\n        .readTimeout(3000, TimeUnit.MILLISECONDS)\n        .build();\n\n    Response response = copy.newCall(request).execute();\n    System.out.println(\"Response 2 succeeded: \" + response);\n} catch (IOException e) {\n    System.out.println(\"Response 2 failed: \" + e);\n}\n}\n ```\n\n #### 处理认证\n OKHttp会自动重试认证请求。当响应是`401 Not Authorized`,`Authenticator`需要用来提供凭证。将会重新实现一个带有凭证的请求，如果没有凭证可用跳过重试，返回null。\n 使用` Response.challenges()`来获取任何认证口令的方案和域。当使用`Basic`认证的时候使用`Credentials.basic(username,password)`来编码一个header。\n \n```Java\nprivate final OkHttpClient client;\n\npublic Authenticate() {\nclient = new OkHttpClient.Builder()\n    .authenticator(new Authenticator() {\n        @Override public Request authenticate(Route route, Response response) throws IOException {\n        System.out.println(\"Authenticating for response: \" + response);\n        System.out.println(\"Challenges: \" + response.challenges());\n        String credential = Credentials.basic(\"jesse\", \"password1\");\n        return response.request().newBuilder()\n            .header(\"Authorization\", credential)\n            .build();\n        }\n    })\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://publicobject.com/secrets/hellosecret.txt\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n","date":"2017-03-19"},{"title":"OKHttp的调用","tags":["Translate","Java","OKHttp","HTTP","backend"],"iso8601Date":"2017-03-18T23:10:03+08:00","basename":"calls","body":"\n\n[原文地址](https://github.com/square/okhttp/wiki/Calls)\n\nHTTP客户端的任务是接受请求和产生响应。理论很简单，但是实战的时候就有点棘手了。\n#### Requests\n每一个HTTP请求都包含一个URL，一个方法（例如，GET，POST）和一些headers。请求同时可以包含一个特定类型的数据流作为body。\n#### Responses\nResponse 通过一个一个状态码（例如，200 成功，404未找到），headers，和一个可选的Body来响应请求。\n##### 重写请求\n当使用OkHttp发送HTTP请求的时候，可以在高层次描述这个请求：通过这个URL和这些headers来获取响应。为了准确和更高的效率，OKHttp会在发送之前重现请求。\nOkHttp将会添加原请求没有的header，包括`Content-length`,`Transfer-Encoding`,`User-Agent`,`Host`,`Connection`，`Content-Type`。除非已经提供了，否则OKHttp回会添加 `Acceept-Encoding`来压缩响应。如果有Cookie，也会添加`Cookie`。\n有些请求会缓存响应。当被缓存的响应过期后，OKHttp会发送一个有条件的GET请求来获取新的响应，如果新现在的比缓存的响应更新，将会更新缓存过的响应。这要求`If-Modified-Since`和`If-None-Match`添加到headers中。\n##### 重写响应\n如果透明压缩启用了，OKHttp将会把`Content-Encoding`和`Content-Length`从headers中移除，因为他们不是用来解压缩的。\n如果条件GET请求成功，从网上下载的响应和缓存的响应根据Spec合并。\n##### 后续请求\n当请求的URL被转移了，web server 将会返回一个302的状态码来表示这个文档的新URL，OKHttp将会重定向到新的URL获取最终的响应。\n如果响应需要认证，OKHttp将会使用`Authenticator`（如果提供了一个）来认证。如果认证器提供了凭证，请求回使用凭证重试。\n##### 重试请求\n有时连接失败，例如：连接池过期断开链接，或者无法连接服务器。OKHttp会通过不同的可用路由来重试请求。\n#### calls\n通过重写，重定向，继续请求和重试，一个简单的请求可能会产生很多请求和响应。OKHttp使用`call`建立一个不管多少中间请求和响应的任务模型。总的来说这不多。但是了解代码将会继续工作，不管是URL重定向或者是转移故障其他IP。\ncall有两种工作方\n   * 同步：线程将会阻塞道到响应可读。\n   * 异步：将请求加入到其他线程的队列，当响应可读诗时，会在其他的线程获取回调。\n请求调用可以在任何线程取消。如果调用未完成，这个请求将会失败。当调用取消时，在先请求踢体或者读响应体的代码将会跑出IOException的异常。\n##### 调度\n对于同步调用，将会由自身线程控制多少并发请求。太多并发连接浪费资源，太少又回有高延迟。\n对于异步来说，Dispatcher实现了最大并发的策略。可以设置没个服务器的最大并发（默认是5）和总体的并发（默认64）。\n","date":"2017-03-18"},{"title":"OKHttp connections","tags":["OKHttp","Translate","Java","HTTP","backend"],"iso8601Date":"2017-03-19T03:05:48+08:00","basename":"connections","body":"\n\n[原文地址](https://github.com/square/okhttp/wiki/Connections)\n虽然只提供了URL，但是OKHttp会使用URL，Address，Route三种方式来连接服务器。\n\n#### URLS\nURLs例如（https://github.com/square/okhttp) 是HTTP和Internet的基础。除了是一个表示互联网一切的命名方案，也指定了如何访问Web资源。\nURLs是抽象的：\n  * 它指出，调用可以是纯文本（http）或者加密（https），但是并没有指定一种加密算法。也没有指定如何验证各个端点的证书([HostnameVerifier](http://developer.android.com/reference/javax/net/ssl/HostnameVerifier.html))，或者是哪个证书可信([SSLSocketFactory](http://developer.android.com/reference/org/apache/http/conn/ssl/SSLSocketFactory.html))\n  * 它为指定是否需要使用代理服务器以及代理服务器如何授权。\n 它也是具体的，每个URL标识一个具体的路径（/square/okhttp)和查询（?q=sharks&lang=en)。每个服务器有很多URL。\n\n #### Addresses\n Address指定了一个服务器（例如：github.com），以及连接服务器必要的所有的静态配置，包括：端口号，HTTPS设置，优先协议（例如，HTTP／2，SPDY）。\n URL使用了相同的Address，底层也可能实用了相同的TCP链接。复用连接可以提高性能：低延迟，高吞吐（[TCP 慢启动](http://www.igvita.com/2011/10/20/faster-web-vs-tcp-slow-start/))，低电量。OKHttp使用[ConnectionPool](http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionPool.html)自动复用HTTP／1.x连接，多路复用HTT／2和SPDY的连接。\n 在OKHttp，address的一些字段来源于URL（协议，主机名，端口），剩下的来自[OKHttpClient](http://square.github.io/okhttp/3.x/okhttp/okhttp3/OkHttpClient.html)。\n #### Routes\n Route提供了连接服务器必要的动态信息。包括，具体的IP地址（通过DNS查询），具体使用那个代理（[ProxySelector](http://developer.android.com/reference/java/net/ProxySelector.html)），协n哪个TLS版本（HTTPS).\n 一个服务器可能有多条路有信息。例如：多台服务器部署在多个数据中心，DNS查询返回多个IP地址。\n #### Connections\n 当发起一个URL的请求的时候：\n   1. 使用URL和OKHttpCLient确定具体的**Address**。这个地址明确如何连接服务器。\n   2. 尝试从**连接池**中查找具体Address的连接。\n   3. 如果未找到有效的连接，使用Route来尝试获取。一般这样意味着通过DNS或去IP地址。然后，如果需要，选择一个TLS的版本和代理服务器。\n   4. 如果是一个新的Route，要么使用Socket直连，TLS隧道（HTTS方式），或者直接使用TLS。也会进行必要的TLS握手。\n   5. 发送请求，接受响应。\n 如果连接发生错误，OKHttp会选择另一个路由重试。这样OKHttp就可以在服务器端一些地址无法访问的时候恢复访问。同时如果连接池的连接失效或者常识的TLS 版本不支持也很有用。\n 当响应接收到了之后，连接会放回到连接池以便之后使用。连接在一段时间过期后回被移除连接池。\n\n","date":"2017-03-19"},{"title":"OKHttp https","tags":["Translate","Java","OKHttp","HTTP","backend"],"iso8601Date":"2017-03-23T21:32:29+08:00","basename":"https","body":"\n\n[原文链接](https://github.com/square/okhttp/wiki/HTTPS)\n\nOKHttp尝试平衡两个相互矛盾的内容：\n * 连接尽可能多的主机。包括使用[boringssl](https://boringssl.googlesource.com/boringssl/)的高级的主机和一些使用[openssl](https://www.openssl.org/)的过时的主机。\n * 连接的安全性。包括验证远程主机的证书，通过强密码进行数据交换。\n\n协商连接到HTTPS的时候，OKHttp需要知道需要提供的[TLS版本](http://square.github.io/okhttp/3.x/okhttp/okhttp3/TlsVersion.html)和[密码套件](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CipherSuite.html)。如果一个客户端需要最大化链接就需要包含过时的TLS版本和弱设计的密码组合。一个严格的客户端想要最大化安全就需要只包含最新的TLS版本和强密码套件。\n安全和连接规范具体是由[ConnectionSpec](http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionSpec.html)实现的。OKHttp包含三个内置的规范：\n * `MODERN_TLS` 是连接现代HTTPS服务器的配置。\n * `COMPATIBLE_TLS` 是连接非现代，但安全的HTTPS服务器的配置。\n * `CLEARTEXT` 是非安全的http的配置。\n\n默认OKHttp会尝试使用`MODERN_TLS`连接，如果现代配置失败，回到使用`COMPATIBLE_TLS`配置。\nTLS版本和密码套件在任一一个发布版本的人一个规范中都可能改变。例如，在OKHttp2.2，因为[POODLE](http://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html)攻击就移除了SSL 3.0的支持。在OKHttp 3.0，移除了[RC4](http://en.wikipedia.org/wiki/RC4#Security)的支持。同桌面浏览器一样，使用罪行的OKHttp版本可以获得最好的安全保障。\n也可以根据一组定制的TLS 版本和密码套件构建自己的规范。例如，下面这个配置要求使用三组高强度的密码套件。它的缺点就是必须是Android5.0+或者是最新的浏览器。\n```Java\nConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)  \n    .tlsVersions(TlsVersion.TLS_1_2)\n    .cipherSuites(\n          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n          CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256)\n    .build();\n\nOkHttpClient client = new OkHttpClient.Builder() \n    .connectionSpecs(Collections.singletonList(spec))\n    .build();\n```\n#### 证书锁定\n默认情况下OKHttp信任主机平台的证书颁发机构。这个策略可以最大化连接，但是也有可能收到权威证书攻击，例如[2011 DigiNotar attack](http://www.computerworld.com/article/2510951/cybercrime-hacking/hackers-spied-on-300-000-iranians-using-fake-google-certificate.html)。同样也假设你的证书是权威机构颁发的。\n使用[CertificatePinner](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CertificatePinner.html)限制了哪些证书和证书颁发机构值得信任。使用证书锁定可以提高安全性，但是限制了服务端团队升级他们的TLS证书。**在没的到服务端团队的许可的时候不要使用证书锁定**。\n```Java\n  public CertificatePinning() {\n    client = new OkHttpClient.Builder()\n        .certificatePinner(new CertificatePinner.Builder()\n            .add(\"publicobject.com\", \"sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=\")\n            .build())\n        .build();\n  }\n\n  public void run() throws Exception {\n    Request request = new Request.Builder()\n        .url(\"https://publicobject.com/robots.txt\")\n        .build();\n\n    Response response = client.newCall(request).execute();\n    if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n    for (Certificate certificate : response.handshake().peerCertificates()) {\n      System.out.println(CertificatePinner.pin(certificate));\n    }\n  }\n```\n#### 定制信任证书\n下面所有的代码展示了如何使用你自己的配置代替服务端的证书配置。正如上述所言，**在没的到服务端团队的许可的时候不要使用定制证书*。\n```Java\n  private final OkHttpClient client;\n\n  public CustomTrust() {\n    SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());\n    client = new OkHttpClient.Builder()\n        .sslSocketFactory(sslContext.getSocketFactory())\n        .build();\n  }\n\n  public void run() throws Exception {\n    Request request = new Request.Builder()\n        .url(\"https://publicobject.com/helloworld.txt\")\n        .build();\n\n    Response response = client.newCall(request).execute();\n    System.out.println(response.body().string());\n  }\n\n  private InputStream trustedCertificatesInputStream() {\n    ... // Full source omitted. See sample.\n  }\n\n  public SSLContext sslContextForTrustedCertificates(InputStream in) {\n    ... // Full source omitted. See sample.\n  }\n```\n","date":"2017-03-23"},{"title":"OKHttp 拦截器","tags":["Translate","Java","OKHttp","HTTP","backend"],"iso8601Date":"2017-03-19T23:47:42+08:00","basename":"interceptors","body":"\n\n[原文地址](https://github.com/square/okhttp/wiki/Interceptors)\n拦截器是一种监控，重写，重试请求的强大机制。下面这个例子是一个记录出发出请求和接受响应的简单的拦截器的例子。\n```Java\nclass LoggingInterceptor implements Interceptor {\n  @Override public Response intercept(Interceptor.Chain chain) throws IOException {\n    Request request = chain.request();\n\n    long t1 = System.nanoTime();\n    logger.info(String.format(\"Sending request %s on %s%n%s\",\n        request.url(), chain.connection(), request.headers()));\n\n    Response response = chain.proceed(request);\n\n    long t2 = System.nanoTime();\n    logger.info(String.format(\"Received response for %s in %.1fms%n%s\",\n        response.request().url(), (t2 - t1) / 1e6d, response.headers()));\n\n    return response;\n  }\n}\n```\n调用`chain.proceed(request)`是每个拦截器最重要的实现。这个看起来简单的方法是所有HTTP工作的地方，也是对请求响应的地方。\n拦截器可以链式调用。假设你有一个压缩的拦截器和一个校验和的拦截器：你要先确定是先压缩再校验，还是先校验再压缩。OKHTTP使用列表跟踪拦截器，而且拦截器是顺序取消的。\n![Interceptors](https://raw.githubusercontent.com/wiki/square/okhttp/interceptors@2x.png)\n#### 应用拦截器\n拦截器注册为应用拦截器或者网络拦截器。我们将使用上面定义的`LoggingInterceptor`来展示这两者的不同。\n通过调用`OkHttpClient.Builder`的`addInterceptor()`来注册一个应用拦截器。\n```Java\nOkHttpClient client = new OkHttpClient.Builder()\n    .addInterceptor(new LoggingInterceptor())\n    .build();\n\nRequest request = new Request.Builder()\n    .url(\"http://www.publicobject.com/helloworld.txt\")\n    .header(\"User-Agent\", \"OkHttp Example\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nresponse.body().close();\n```\n链接`http://www.publicobject.com/helloworld.txt`重定向到链接`http://www.publicobject.com/helloworld.txt`,OKHttp回自动重定向。应用拦截器只会被调用一次。`chain.proceed()`返回的响应是重定向之后的响应。\n```bash\nINFO: Sending request http://www.publicobject.com/helloworld.txt on null\nUser-Agent: OkHttp Example\n\nINFO: Received response for https://publicobject.com/helloworld.txt in 1179.7ms\nServer: nginx/1.4.6 (Ubuntu)\nContent-Type: text/plain\nContent-Length: 1759\nConnection: keep-alive\n```\n因为`response.request().url()`和`request.url()`获取的URL不同，所以可以得出上述结论。两行日志记录了两个不同的URL。\n#### 网络拦截器\n注册网络拦截器和应用拦截器差不多，只是用`addNetworkInterceptor()`代替了`addInterceptor()`。\n```Java\nOkHttpClient client = new OkHttpClient.Builder()\n    .addNetworkInterceptor(new LoggingInterceptor())\n    .build();\n\nRequest request = new Request.Builder()\n    .url(\"http://www.publicobject.com/helloworld.txt\")\n    .header(\"User-Agent\", \"OkHttp Example\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nresponse.body().close();\n```\n当运行这段代码的时候拦截器运行了两次，一次初始的地址`http://www.publicobject.com/helloworld.txt`，一次是重定向的地址`https://publicobject.com/helloworld.txt`。\n```bash\nINFO: Sending request http://www.publicobject.com/helloworld.txt on Connection{www.publicobject.com:80, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=none protocol=http/1.1}\nUser-Agent: OkHttp Example\nHost: www.publicobject.com\nConnection: Keep-Alive\nAccept-Encoding: gzip\n\nINFO: Received response for http://www.publicobject.com/helloworld.txt in 115.6ms\nServer: nginx/1.4.6 (Ubuntu)\nContent-Type: text/html\nContent-Length: 193\nConnection: keep-alive\nLocation: https://publicobject.com/helloworld.txt\n\nINFO: Sending request https://publicobject.com/helloworld.txt on Connection{publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA protocol=http/1.1}\nUser-Agent: OkHttp Example\nHost: publicobject.com\nConnection: Keep-Alive\nAccept-Encoding: gzip\n\nINFO: Received response for https://publicobject.com/helloworld.txt in 80.9ms\nServer: nginx/1.4.6 (Ubuntu)\nContent-Type: text/plain\nContent-Length: 1759\nConnection: keep-alive\n```\n网络请求同时也包含了更多的数据，例如:由OKHttp添加的用来支持响应压缩的`Accept-Encoding: gzip`header。网络拦截器的`chain`有一个非空的`Connection`，用来查询连接服务器的IP地址和TLS配置信息。\n#### 如何选择拦截器\n每种拦截器都有优点。\n##### 应用拦截器\n * 无需关心像重试，重定向等这样的中间过程。\n * 即使是从缓存响应，也会调用一次。\n * 只关心应用最初的目的，并不需要关心OKHttp注入的header，例如`If-None-Match`\n * 允许短路，不执行`Chain.proceed()`\n * 允许重试，执行多次`Chain.proceed()`\n##### 网络拦截器\n * 可以操作想重试，重定向这样的中间过程。\n * 短路网络连接的从cache返回响应的时候不执行。\n * 可以监控呗发送到网络上的数据\n * 访问包含request的`Connection`\n#### 重写请求\n拦截器可以添加，删除，替换请求头。如果请求有请求体，拦截器也可以转换请求体。例如：如果远程连接的服务器支持压缩，可以使用应用拦截器添加压缩请求体的拦截器。\n```Java\n/** This interceptor compresses the HTTP request body. Many webservers can't handle this! */\nfinal class GzipRequestInterceptor implements Interceptor {\n  @Override public Response intercept(Interceptor.Chain chain) throws IOException {\n    Request originalRequest = chain.request();\n    if (originalRequest.body() == null || originalRequest.header(\"Content-Encoding\") != null) {\n      return chain.proceed(originalRequest);\n    }\n\n    Request compressedRequest = originalRequest.newBuilder()\n        .header(\"Content-Encoding\", \"gzip\")\n        .method(originalRequest.method(), gzip(originalRequest.body()))\n        .build();\n    return chain.proceed(compressedRequest);\n  }\n\n  private RequestBody gzip(final RequestBody body) {\n    return new RequestBody() {\n      @Override public MediaType contentType() {\n        return body.contentType();\n      }\n\n      @Override public long contentLength() {\n        return -1; // We don't know the compressed length in advance!\n      }\n\n      @Override public void writeTo(BufferedSink sink) throws IOException {\n        BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));\n        body.writeTo(gzipSink);\n        gzipSink.close();\n      }\n    };\n  }\n}\n```\n#### 重写响应\n同样拦截器也可以重写响应，转化请求体。通常这样做比重写请求头更危险，因为这样做可能返回的并不是服务器预期值。\n如果你处在一个比较棘手的场景，并且准备处理后果，重写响应头就是一个很好的方式处理这类问题。例如：可以修复服务器未配置的`Cache-Control`来获取更好的缓存响应配置。\n```Java\n/** Dangerous interceptor that rewrites the server's cache-control header. */\nprivate static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() {\n  @Override public Response intercept(Interceptor.Chain chain) throws IOException {\n    Response originalResponse = chain.proceed(chain.request());\n    return originalResponse.newBuilder()\n        .header(\"Cache-Control\", \"max-age=60\")\n        .build();\n  }\n};\n```\n通常为了补充服务器相应的修复，这个方法是最好的。\n#### 那些可以使用拦截器\n使用拦截器要求OKHttp 2.0即以上。不行的是拦截器不可以和`OkUrlFactory`，或者依赖于他的库同时使用，包括[Retrofit](http://square.github.io/retrofit/)1.8以下，[Picasso](http://square.github.io/picasso/)2.4以下。\n","date":"2017-03-19"}]}}