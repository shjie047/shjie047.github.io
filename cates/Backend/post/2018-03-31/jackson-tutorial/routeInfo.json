{"path":"cates/Backend/post/2018-03-31/jackson-tutorial","templateID":1,"sharedPropsHashes":{"tags":"Zpc8p0"},"localProps":{"post":{"title":"Jackson 简明教程","cover":"http://p6jqy6mfr.bkt.clouddn.com/0_ZclbzbQKdYKcf4Lv.jpg","iso8601Date":"2018-03-31T08:39:10+08:00","basename":"jackson-tutorial","tags":["JSON","Java","Jackson","Translate","Backend"],"date":"2018-03-31","cate":"Backend","summary":"原文地址  \n\n一分钟教程：POJOs和JSON的互相转换\n\n最常用的功能就是将一段JSON片段组装成POJOs。所以我们首先从这个入手。下面是一个简单的，有两个属性的POJO：  \n\nJava\n// Note: can use getters/setters as well; here we just use public fields directly:\npublic class MyValue {\n  public String name;\n  public int age;\n  // NOTE: if using getters/setters, can keep fields `protected` or `private`\n}\n\n\n我们需要一个com.fasterxml.jackson.databind.ObjectMapper的实例来做所有的数据绑定，ObjectMapper仅需要创建一次即可。  \n\nJava\nObjectMapper mapper = new ObjectMapper(); // create once, reuse\n\n采用默认构造函数目前基本够用，当需要处理特殊情况的时候再学习如何根据情况配置ObjectMapper。以下是使用ObjectMapper的示例：  \n\nJava\nMyValue value = mapper.readValue(new File(&quot;data.json&quot;), MyValue.class);\n// or:\nvalue = mapper.readValue(new URL(&quot;http://some.com/api/entry.json&quot;), MyValue.class);\n// or:\nvalue = mapper.readValue(&quot;{\\&quot;name\\&quot;:\\&quot;Bob\\&quot;, \\&quot;age\\&quot;:13}&quot;, MyValue.class);\n\n如果想要生成JSON，只需要反过来就行：\n\nJava\nmapper.writeValue(new File(&quot;result.json&quot;), myResultObject);\n// or:\nbyte[] jsonBytes = mapper.writeValueAsBytes(myResultObject);\n// or:\nString jsonString = mapper.writeValueAsString(myResultObject);\n\n\n三分钟教程：泛型集合和树模型\n\n除了处理Bean风格的POJO，Jackson同时可以处理JDK的List和Map:`Java\nMap&lt;String, Integer&gt; scoreByName = mapper.readValue(jsonSource, Map.class);\nList&lt;String&gt; names = mapper.readValue(jsonSource, List.class);\n\n// and can obviously write out as well\nmapper.writeValue(new File(&quot;names.json&quot;), names);\n\n匹配这种，只要JSON的结构匹配，并且类型简单就可以。如果有POJO值，则需要声明他的实际类型(PS:POJO的属性如果是List`等类型，则不需要指定类型)  \n\nJava\nMap&lt;String, ResultValue&gt; results = mapper.readValue(jsonSource,\n   new TypeReference&lt;Map&lt;String, ResultValue&gt;&gt;() { } );\n// why extra work? Java Type Erasure will prevent type detection otherwise })\n\n然而，处理Map,List和其他&#39;简单&#39;类型(String,Number,Boolean)可以更见简单，对象遍历非常麻烦，所以Jackson的Tree Model迟早有用。  \n\n`Java\n// can be read as generic JsonNode, if it can be Object or Array; or,\n// if known to be Object, as ObjectNode, if array, ArrayNode etc:\nObjectNode root = mapper.readTree(&quot;stuff.json&quot;);\nString name = root.get(&quot;name&quot;).asText();\nint age = root.get(&quot;age&quot;).asInt();\n\n// can modify as well: this adds child Object as property &#39;other&#39;, set property &#39;type&#39;\nroot.with(&quot;other&quot;).put(&quot;type&quot;, &quot;student&quot;);\nString json = mapper.writeValueAsString(root);\n\n// with above, we end up with something like as &#39;json&#39; String:\n// {\n//   &quot;name&quot; : &quot;Bob&quot;, &quot;age&quot; : 13,\n//   &quot;other&quot; : {\n//      &quot;type&quot; : &quot;student&quot;\n//   }\n// }\n`\n树模型比data-bind更加的方便，尤其是高度动态的数据结构，或者JSON无法完美映射Java类的时候。\n\n五分钟教程：Streaming parser, generator\n\n有一种更见标准的处理模型，叫做incremental model，也叫Stream model ，这种处理方法和data-bind方式同样方便，和Tree Model同样灵活。data-bind和Tree Model 底层都是基于它。但是同样也暴露给那些想要极致性能和完全掌控解析JSON的用户。\n\n`Java\nJsonFactory f = mapper.getFactory(); // may alternatively construct directly too\n\n// First: write simple JSON output\nFile jsonFile = new File(&quot;test.json&quot;);\nJsonGenerator g = f.createGenerator(jsonFile);\n// write JSON: { &quot;message&quot; : &quot;Hello world!&quot; }\ng.writeStartObject();\ng.writeStringField(&quot;message&quot;, &quot;Hello world!&quot;);\ng.writeEndObject();\ng.close();\n\n// Second: read file back\nJsonParser p = f.createParser(jsonFile);\n\nJsonToken t = p.nextToken(); // Should be JsonToken.STARTOBJECT\nt = p.nextToken(); // JsonToken.FIELDNAME\nif ((t != JsonToken.FIELDNAME) || !&quot;message&quot;.equals(p.getCurrentName())) {\n   // handle error\n}\nt = p.nextToken();\nif (t != JsonToken.VALUESTRING) {\n   // similarly\n}\nString msg = p.getText();\nSystem.out.printf(&quot;My message to you is: %s!\\n&quot;, msg);\np.close(); }\n`\n\n10分钟教程：配置\n\n有两种入门的配置方法：feature 和 Annotation\n\nfeature 配置\n\n下面是一些最常用的配置\n首先从高层的data-bind配置开始：\n\n`Java\n// SerializationFeature for changing how JSON is written\n\n// to enable standard indentation (&quot;pretty-printing&quot;):\nmapper.enable(SerializationFeature.INDENTOUTPUT);\n// to allow serialization of &quot;empty&quot; POJOs (no properties to serialize)\n// (without this setting, an exception is thrown in those cases)\nmapper.disable(SerializationFeature.FAILONEMPTYBEANS);\n// to write java.util.Date, Calendar as number (timestamp):\nmapper.disable(SerializationFeature.WRITEDATESAS_TIMESTAMPS);\n\n// DeserializationFeature for changing how JSON is read as POJOs:\n\n// to prevent exception when encountering unknown property:\nmapper.disable(DeserializationFeature.FAILONUNKNOWNPROPERTIES);\n// to allow coercion of JSON empty String (&quot;&quot;) to null Object value:\nmapper.enable(DeserializationFeature.ACCEPTEMPTYSTRINGASNULLOBJECT);\n`\n下面是一些可以控制JSON底层解析，生成的配置：\n\n`Java\n// JsonParser.Feature for configuring parsing settings:\n\n// to allow C/C++ style comments in JSON (non-standard, disabled by default)\n// (note: with Jackson 2.5, there is also mapper.enable(feature) / mapper.disable(feature))\nmapper.configure(JsonParser.Feature.ALLOWCOMMENTS, true);\n// to allow (non-standard) unquoted field names in JSON:\nmapper.configure(JsonParser.Feature.ALLOWUNQUOTEDFIELDNAMES, true);\n// to allow use of apostrophes (single quotes), non standard\nmapper.configure(JsonParser.Feature.ALLOWSINGLEQUOTES, true);\n\n// JsonGenerator.Feature for configuring low-level JSON generation:\n\n// to force escaping of non-ASCII characters:\nmapper.configure(JsonGenerator.Feature.ESCAPENONASCII, true);\n`\n\n注解配置：修改属性名\n\n最简单的使用注解配置的方式是使用@JsonProperty:  \n\n`Java\npublic class MyBean {\n   private String _name;\n\n   // without annotation, we&#39;d get &quot;theName&quot;, but we want &quot;name&quot;:\n   @JsonProperty(&quot;name&quot;)\n   public String getTheName() { return _name; }\n\n   // note: it is enough to add annotation on just getter OR setter;\n   // so we can omit it here\n   public void setTheName(String n) { _name = n; }\n} \n`\n\n注解配置：忽略属性\n\n有两个可以设置忽略属性的注解，一个是@JsonIgnore 修饰的是单个属性，一个是@JsonIgnoreProperties 修饰的类。\n\n`Java\n// means that if we see &quot;foo&quot; or &quot;bar&quot; in JSON, they will be quietly skipped\n// regardless of whether POJO has such properties\n@JsonIgnoreProperties({ &quot;foo&quot;, &quot;bar&quot; })\npublic class MyBean\n{\n   // will not be written as JSON; nor assigned from JSON:\n   @JsonIgnore\n   public String internal;\n\n   // no annotation, public field is read/written normally\n   public String external;\n\n   @JsonIgnore\n   public void setCode(int c) { _code = c; }\n\n   // note: will also be ignored because setter has annotation!\n   public int getCode() { return _code; }\n} \n\n由于重命名，所以注解是在匹配的的字段，get，set中共享的：如果其中一个设置了@JsonIgnore`，其他的也受影响。当然也可以使用分离的注解来解决问题：\n\nJava\npublic class ReadButDontWriteProps {\n   private String _name;\n   @JsonProperty public void setName(String n) { _name = n; }\n   @JsonIgnore public String getName() { return _name; }\n} \n\n在这个例子中，name不会被写入到JSON中，但是如果JSON中有，则会映射到Java对象中。\n\n注解配置：定制注解构造器\n\n和其他的data-bind包不同，jackson 不需要定义默认的构造函数（即不包含参数的构造函数）。如果需要，可以定义一个简单的包含参数的构造函数:  \n\n`Java\npublic class CtorBean\n{\n  public final String name;\n  public final int age;\n\n  @JsonCreator // constructor can be public, private, whatever\n  private CtorBean(@JsonProperty(&quot;name&quot;) String name,\n    @JsonProperty(&quot;age&quot;) int age)\n  {\n      this.name = name;\n      this.age = age;\n  }\n}\n`\n构造函数在不可变对象中非常实用。也可以直接定义一个工厂方法：\n\n`Java\npublic class FactoryBean\n{\n    // fields etc omitted for brewity\n\n@JsonCreator\npublic static FactoryBean create(@JsonProperty(&quot;name&quot;) String name) {\n  // construct and return an instance\n}\n\n}\n`\n\n其他特性：\n\n一个有用，但是不被广泛知晓的功能就是Jackson可以任意转换两个POJO。可以将其想象成两步，第一步，将POJO写成JSON，第二步讲JSON写成另一个POJO。实现的时候用了更加高效的一种方法，并没有生成中间的JSON。\n转换在兼容的类型中运行的很好：\n\nJava\nResultType result = mapper.convertValue(sourceObject, ResultType.class);\n\n只要这两个POJO的类型兼容，即to json 和 from json的成功，那么就可以成功：\n\nJava\n// Convert from List&lt;Integer&gt; to int[]\nList&lt;Integer&gt; sourceList = ...;\nint[] ints = mapper.convertValue(sourceList, int[].class);\n// Convert a POJO into Map!\nMap&lt;String,Object&gt; propertyMap = mapper.convertValue(pojoValue, Map.class);\n// ... and back\nPojoType pojo = mapper.convertValue(propertyMap, PojoType.class);\n// decode Base64! (default byte[] representation is base64-encoded String)\nString base64 = &quot;TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz&quot;;\nbyte[] binary = mapper.convertValue(base64, byte[].class);\n\n基本上Jackson可以替换很多Apache Commons的组件，例如Base64的编码解码，处理动态POJO等。","readingtime":14,"url":"/cates/Backend/post/2018-03-31/jackson-tutorial","dirs":["jackson"],"relatives":[],"body":"\n\n[原文地址](https://github.com/FasterXML/jackson-databind/)  \n\n#### 一分钟教程：POJOs和JSON的互相转换\n\n最常用的功能就是将一段JSON片段组装成POJOs。所以我们首先从这个入手。下面是一个简单的，有两个属性的POJO：  \n\n```Java\n// Note: can use getters/setters as well; here we just use public fields directly:\npublic class MyValue {\n  public String name;\n  public int age;\n  // NOTE: if using getters/setters, can keep fields `protected` or `private`\n}\n```\n\n我们需要一个`com.fasterxml.jackson.databind.ObjectMapper`的实例来做所有的数据绑定，`ObjectMapper`仅需要创建一次即可。  \n\n```Java\nObjectMapper mapper = new ObjectMapper(); // create once, reuse\n```\n采用默认构造函数目前基本够用，当需要处理特殊情况的时候再学习如何根据情况配置ObjectMapper。以下是使用`ObjectMapper`的示例：  \n\n```Java\nMyValue value = mapper.readValue(new File(\"data.json\"), MyValue.class);\n// or:\nvalue = mapper.readValue(new URL(\"http://some.com/api/entry.json\"), MyValue.class);\n// or:\nvalue = mapper.readValue(\"{\\\"name\\\":\\\"Bob\\\", \\\"age\\\":13}\", MyValue.class);\n```\n如果想要生成JSON，只需要反过来就行：\n\n```Java\nmapper.writeValue(new File(\"result.json\"), myResultObject);\n// or:\nbyte[] jsonBytes = mapper.writeValueAsBytes(myResultObject);\n// or:\nString jsonString = mapper.writeValueAsString(myResultObject);\n```\n#### 三分钟教程：泛型集合和树模型\n除了处理Bean风格的POJO，Jackson同时可以处理JDK的`List`和`Map`:  \n```Java\nMap<String, Integer> scoreByName = mapper.readValue(jsonSource, Map.class);\nList<String> names = mapper.readValue(jsonSource, List.class);\n\n// and can obviously write out as well\nmapper.writeValue(new File(\"names.json\"), names);\n```\n匹配这种，只要JSON的结构匹配，并且类型简单就可以。如果有POJO值，则需要声明他的实际类型(PS:POJO的属性如果是`List`等类型，则不需要指定类型)  \n\n```Java\nMap<String, ResultValue> results = mapper.readValue(jsonSource,\n   new TypeReference<Map<String, ResultValue>>() { } );\n// why extra work? Java Type Erasure will prevent type detection otherwise })\n```\n然而，处理`Map`,`List`和其他'简单'类型(String,Number,Boolean)可以更见简单，对象遍历非常麻烦，所以Jackson的`Tree Model`迟早有用。  \n\n```Java\n// can be read as generic JsonNode, if it can be Object or Array; or,\n// if known to be Object, as ObjectNode, if array, ArrayNode etc:\nObjectNode root = mapper.readTree(\"stuff.json\");\nString name = root.get(\"name\").asText();\nint age = root.get(\"age\").asInt();\n\n// can modify as well: this adds child Object as property 'other', set property 'type'\nroot.with(\"other\").put(\"type\", \"student\");\nString json = mapper.writeValueAsString(root);\n\n// with above, we end up with something like as 'json' String:\n// {\n//   \"name\" : \"Bob\", \"age\" : 13,\n//   \"other\" : {\n//      \"type\" : \"student\"\n//   }\n// }\n```\n树模型比data-bind更加的方便，尤其是高度动态的数据结构，或者JSON无法完美映射Java类的时候。\n#### 五分钟教程：Streaming parser, generator\n有一种更见标准的处理模型，叫做incremental model，也叫Stream model ，这种处理方法和data-bind方式同样方便，和Tree Model同样灵活。data-bind和Tree Model 底层都是基于它。但是同样也暴露给那些想要极致性能和完全掌控解析JSON的用户。\n\n```Java\nJsonFactory f = mapper.getFactory(); // may alternatively construct directly too\n\n// First: write simple JSON output\nFile jsonFile = new File(\"test.json\");\nJsonGenerator g = f.createGenerator(jsonFile);\n// write JSON: { \"message\" : \"Hello world!\" }\ng.writeStartObject();\ng.writeStringField(\"message\", \"Hello world!\");\ng.writeEndObject();\ng.close();\n\n// Second: read file back\nJsonParser p = f.createParser(jsonFile);\n\nJsonToken t = p.nextToken(); // Should be JsonToken.START_OBJECT\nt = p.nextToken(); // JsonToken.FIELD_NAME\nif ((t != JsonToken.FIELD_NAME) || !\"message\".equals(p.getCurrentName())) {\n   // handle error\n}\nt = p.nextToken();\nif (t != JsonToken.VALUE_STRING) {\n   // similarly\n}\nString msg = p.getText();\nSystem.out.printf(\"My message to you is: %s!\\n\", msg);\np.close(); }\n```\n#### 10分钟教程：配置\n有两种入门的配置方法：feature 和 Annotation\n##### feature 配置\n下面是一些最常用的配置\n首先从高层的data-bind配置开始：\n\n```Java\n// SerializationFeature for changing how JSON is written\n\n// to enable standard indentation (\"pretty-printing\"):\nmapper.enable(SerializationFeature.INDENT_OUTPUT);\n// to allow serialization of \"empty\" POJOs (no properties to serialize)\n// (without this setting, an exception is thrown in those cases)\nmapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);\n// to write java.util.Date, Calendar as number (timestamp):\nmapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n\n// DeserializationFeature for changing how JSON is read as POJOs:\n\n// to prevent exception when encountering unknown property:\nmapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);\n// to allow coercion of JSON empty String (\"\") to null Object value:\nmapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n```\n下面是一些可以控制JSON底层解析，生成的配置：\n\n```Java\n// JsonParser.Feature for configuring parsing settings:\n\n// to allow C/C++ style comments in JSON (non-standard, disabled by default)\n// (note: with Jackson 2.5, there is also `mapper.enable(feature)` / `mapper.disable(feature)`)\nmapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);\n// to allow (non-standard) unquoted field names in JSON:\nmapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);\n// to allow use of apostrophes (single quotes), non standard\nmapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);\n\n// JsonGenerator.Feature for configuring low-level JSON generation:\n\n// to force escaping of non-ASCII characters:\nmapper.configure(JsonGenerator.Feature.ESCAPE_NON_ASCII, true);\n```\n##### 注解配置：修改属性名\n最简单的使用注解配置的方式是使用`@JsonProperty`:  \n\n```Java\npublic class MyBean {\n   private String _name;\n\n   // without annotation, we'd get \"theName\", but we want \"name\":\n   @JsonProperty(\"name\")\n   public String getTheName() { return _name; }\n\n   // note: it is enough to add annotation on just getter OR setter;\n   // so we can omit it here\n   public void setTheName(String n) { _name = n; }\n} \n```\n##### 注解配置：忽略属性\n有两个可以设置忽略属性的注解，一个是`@JsonIgnore` 修饰的是单个属性，一个是`@JsonIgnoreProperties` 修饰的类。\n\n```Java\n// means that if we see \"foo\" or \"bar\" in JSON, they will be quietly skipped\n// regardless of whether POJO has such properties\n@JsonIgnoreProperties({ \"foo\", \"bar\" })\npublic class MyBean\n{\n   // will not be written as JSON; nor assigned from JSON:\n   @JsonIgnore\n   public String internal;\n\n   // no annotation, public field is read/written normally\n   public String external;\n\n   @JsonIgnore\n   public void setCode(int c) { _code = c; }\n\n   // note: will also be ignored because setter has annotation!\n   public int getCode() { return _code; }\n} \n```\n由于重命名，所以注解是在匹配的的字段，get，set中共享的：如果其中一个设置了`@JsonIgnore`，其他的也受影响。当然也可以使用分离的注解来解决问题：\n\n```Java\npublic class ReadButDontWriteProps {\n   private String _name;\n   @JsonProperty public void setName(String n) { _name = n; }\n   @JsonIgnore public String getName() { return _name; }\n} \n```\n在这个例子中，`name`不会被写入到JSON中，但是如果JSON中有，则会映射到Java对象中。\n\n##### 注解配置：定制注解构造器\n和其他的data-bind包不同，jackson 不需要定义默认的构造函数（即不包含参数的构造函数）。如果需要，可以定义一个简单的包含参数的构造函数:  \n\n```Java\npublic class CtorBean\n{\n  public final String name;\n  public final int age;\n\n  @JsonCreator // constructor can be public, private, whatever\n  private CtorBean(@JsonProperty(\"name\") String name,\n    @JsonProperty(\"age\") int age)\n  {\n      this.name = name;\n      this.age = age;\n  }\n}\n```\n构造函数在不可变对象中非常实用。  \n也可以直接定义一个工厂方法：\n\n```Java\npublic class FactoryBean\n{\n    // fields etc omitted for brewity\n\n    @JsonCreator\n    public static FactoryBean create(@JsonProperty(\"name\") String name) {\n      // construct and return an instance\n    }\n}\n```\n#### 其他特性：\n一个有用，但是不被广泛知晓的功能就是Jackson可以任意转换两个POJO。可以将其想象成两步，第一步，将POJO写成JSON，第二步讲JSON写成另一个POJO。实现的时候用了更加高效的一种方法，并没有生成中间的JSON。\n转换在兼容的类型中运行的很好：\n\n```Java\nResultType result = mapper.convertValue(sourceObject, ResultType.class);\n```\n只要这两个POJO的类型兼容，即to json 和 from json的成功，那么就可以成功：\n\n```Java\n// Convert from List<Integer> to int[]\nList<Integer> sourceList = ...;\nint[] ints = mapper.convertValue(sourceList, int[].class);\n// Convert a POJO into Map!\nMap<String,Object> propertyMap = mapper.convertValue(pojoValue, Map.class);\n// ... and back\nPojoType pojo = mapper.convertValue(propertyMap, PojoType.class);\n// decode Base64! (default byte[] representation is base64-encoded String)\nString base64 = \"TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz\";\nbyte[] binary = mapper.convertValue(base64, byte[].class);\n```\n基本上Jackson可以替换很多Apache Commons的组件，例如Base64的编码解码，处理动态POJO等。\n"}}}