{"path":"cates/Backend/post/2018-04-09/spring-mvc-dispatcher-servlet","templateID":2,"sharedPropsHashes":{"tags":"Zpc8p0"},"localProps":{"post":{"title":"SpringMVC 教程 - DispatcherServlet","iso8601Date":"2018-04-09T08:39:10+08:00","basename":"spring-mvc-dispatcher-servlet","cover":"https://coding.net/u/shjie047/p/images/git/raw/master/stock-photo-239935763.jpg","tags":["Backend","Java","SpringMVC","Spring"],"date":"2018-04-09","cate":"Backend","summary":"简介\n\n同许多其他的web框架一样，SpringMVC使用了前端控制器的设计模式，即一个以DispatcherServlet为核心的Servlet为处理请求提供了一个共享的算法，而实际的工作是由可配置的委托组件执行的。这个模式即灵活又支持多样的工作流。\n同其他的Servlet,依照Servlet 规范DispatcherServlet需要在web.xml或者Java配置中声明并映射URL。接着DispatcherServlet使用Spring的配置来查找委托组件，用来映射URL，解析视图，异常处理等。\n下面这个示例是使用Java配置来注册并初始化DispatcherServlet，这个类由Servlet容器自动发现。\n`Java\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n\n@Override\npublic void onStartup(ServletContext servletCxt) {\n\n    // Load Spring web application configuration\n    AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();\n    ac.register(AppConfig.class);\n    ac.refresh();\n\n    // Create and register the DispatcherServlet\n    DispatcherServlet servlet = new DispatcherServlet(ac);\n    ServletRegistration.Dynamic registration = servletCxt.addServlet(&quot;app&quot;, servlet);\n    registration.setLoadOnStartup(1);\n    registration.addMapping(&quot;/app/*&quot;);\n}\n\n}\n`\n\n下面这个示例是使用web.xml来注册并初始化的\n`xml\n&lt;web-app&gt;\n\n&lt;listener&gt;\n    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;\n&lt;/listener&gt;\n\n&lt;context-param&gt;\n    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n    &lt;param-value&gt;/WEB-INF/app-context.xml&lt;/param-value&gt;\n&lt;/context-param&gt;\n\n&lt;servlet&gt;\n    &lt;servlet-name&gt;app&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n&lt;/servlet&gt;\n\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;app&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n\n&lt;/web-app&gt;\n`\n\n层次结构\n\nDispatcherServlet需要一个扩展了的ApplicationContext的WebApplicationContext来配置自己的信息。WebApplicationContext包含了Servlet的ServletContext的引用，可以使用RequestContextUtils中的静态方法从WebApplicationContext中查找ServletContext。\n对于大多数应用来说一个WebApplicationContext就足够了。当然WebApplicatioContext也可以是有层次结构的，例如由多个Servlet共享的一个根WebApplicationContext，每个Servlet又有自己的子WebApplicationContext。\n根WebApplicationContext一般包括需要在多个Servlet中共享的基础bean，例如数据仓库，业务逻辑等。在Servlet规范中，这些bean可以被有效的继承和改写，子WebApplicationContext仅包含在其属于的Servlet中。\n\n下面这个例子就是WebApplicationContext的层级配置\n`Java\npublic class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n@Override\nprotected Class&lt;?&gt;[] getRootConfigClasses() {\n    return new Class&lt;?&gt;[] { RootConfig.class };\n}\n\n@Override\nprotected Class&lt;?&gt;[] getServletConfigClasses() {\n    return new Class&lt;?&gt;[] { App1Config.class };\n}\n\n@Override\nprotected String[] getServletMappings() {\n    return new String[] { &quot;/app1/*&quot; };\n}\n\n} \n`\n\n同样的，在web.xml中的配置\n`xml\n&lt;web-app&gt;\n\n&lt;listener&gt;\n    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;\n&lt;/listener&gt;\n\n&lt;context-param&gt;\n    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n    &lt;param-value&gt;/WEB-INF/root-context.xml&lt;/param-value&gt;\n&lt;/context-param&gt;\n\n&lt;servlet&gt;\n    &lt;servlet-name&gt;app1&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;/WEB-INF/app1-context.xml&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n&lt;/servlet&gt;\n\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;app1&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/app1/*&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n\n&lt;/web-app&gt;\n`\n\n特殊的bean类型\n\nDispatcherServlet委托专用的bean来处理请求，渲染响应。专用的bean指的是Spring管理的，实现WebFlux框架约定的实例。这些bean一般都是内建的约定，但是可以定制他们的属性，扩展或者代替这些bean。\n\nbean 类型 | 解释\n:---------- | :---------\nHandlerMapping | 处理器映射，具体由其子类实现。两个重要的子类，RequestMappingHandlerMapping,SimpleUrlHandlerMapping\nHandlerAdapter | 辅助DispatcherServlet执行特定的处理器。\nHandlerExceptionResolver | 将异常重定向到其他处理器或者是显示HTML的错误界面。\nViewResolver | 通过处理器返回的视图字符串查找具体的视图并渲染。 \nLocaleResolver, LocaleContextResolver | 支持国际化页面，使用例如时区等来解析本地化问题。 \nThemeResolver | 解析应用可用的主题，例如提供个性化框架 \nMultipartResolver | 处理上传文件 \nFlashMapManager | 保存和检索输入输出的FlashMap，它可以将属性从一个请求传递到另一个请求的输入输出，一般应用在重定向中。 \n\nWeb MVC 配置\n\n应用可以声明在特殊的bean类型中列出的bean来处理请求。DispatcherServlet会检查每一个bean的WebApplicationContext。如果没有指定的bean，那么就会使用DispatcherServlet.properties中定义的bean。\nMVC配置将会在以后详细的列出。\n\nServlet 配置\n\n在Servlet 3.0+中，可以使用编程的方式来代替web.xml配置。下面这个例子就是通过编程注册DispatcherServlet\n`Java\nimport org.springframework.web.WebApplicationInitializer;\n\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n\n@Override\npublic void onStartup(ServletContext container) {\n    XmlWebApplicationContext appContext = new XmlWebApplicationContext();\n    appContext.setConfigLocation(&quot;/WEB-INF/spring/dispatcher-config.xml&quot;);\n\n    ServletRegistration.Dynamic registration = container.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(appContext));\n    registration.setLoadOnStartup(1);\n    registration.addMapping(&quot;/&quot;);\n}\n\n}\n`\n\nWebApplicationInitializer是由SpringMVC提供的接口，用来保证上述实现可以由支持Servlet 3.0的容器自动检测并初始化。抽象类AbstractDispatcherServletInitializerl实现了WebApplicationInitializer 可以更加容易的注册DispathcerServlet。\n下面是使用Java配置的Spring\n`Java\npublic class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n@Override\nprotected Class&lt;?&gt;[] getRootConfigClasses() {\n    return null;\n}\n\n@Override\nprotected Class&lt;?&gt;[] getServletConfigClasses() {\n    return new Class&lt;?&gt;[] { MyWebConfig.class };\n}\n\n@Override\nprotected String[] getServletMappings() {\n    return new String[] { &quot;/&quot; };\n}\n\n}\n`\n\n如果使用的是xml配置，需要直接继承AbstractDispatcherServletInitializer\n`Java\npublic class MyWebAppInitializer extends AbstractDispatcherServletInitializer {\n\n@Override\nprotected WebApplicationContext createRootApplicationContext() {\n    return null;\n}\n\n@Override\nprotected WebApplicationContext createServletApplicationContext() {\n    XmlWebApplicationContext cxt = new XmlWebApplicationContext();\n    cxt.setConfigLocation(&quot;/WEB-INF/spring/dispatcher-config.xml&quot;);\n    return cxt;\n}\n\n@Override\nprotected String[] getServletMappings() {\n    return new String[] { &quot;/&quot; };\n}\n\n}\n`\n\nAbstractDispatcherServletInitializer同样提供了一个方便的函数来添加过滤器。\n`Java\npublic class MyWebAppInitializer extends AbstractDispatcherServletInitializer {\n\n// ...\n\n@Override\nprotected Filter[] getServletFilters() {\n    return new Filter[] {\n        new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };\n}\n\n}\n`\n\n每个过滤器根据他具体的类型添加一个默认的名字，并且自动映射到DispatcherServlet。\nisAsyncSupported方法是AbstractDispatcherServletInitializer的protect的方法，可以启动DispatcherServlet支持异步处理\n如果要定义自己的DispatcherServlet，那么可以重写createDispatcherServlet方法。\n\n处理请求\n\nDispatcherServlet处理请求的流程如下：  - 查找WebApplicationContext并将其作为request的一个属性保存起来，以便其他控制器或者处理链中的组件可以使用。默认保存键为DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE \n  - 本地化解析器保存在request中，以便处理链中的其他组件使用他来处理请求做本地化处理。如果不需要本地化，那么就不需要使用他。\n  - 主题解析器保存在request中，以便其他组件，例如视图查找器使用，如果不需要要主题定制，直接忽略。\n  - 如果指定了文件上传解析器，那么就会检查请求是否有文件上传，如果有请求有MultipartHttpServletRequest封装，以便其他组件处理。\n  - 查找合适的处理器处理请求。如果找到了处理器，那么就依次执行处理链上的组件，返回一个model或者视图。如果是注解的controller也可以直接渲染而不需要返回视图。\n  - 如果返回一个model，会渲染一个视图，如果没有返回model，那么就无需渲染视图了，因为视图可能已经被渲染了。\n\n在请求处理过程中如果出现了一场那么就可以使用WebApplicatioContext中的HandlerExceptionResolver来定制异常处理。\nSpringMVC 同样支持返回last-modification-date，对指定请求处理如何判断是否有last-modification-date非常直接：DispatcherServlet查找适合的处理器，并且检查其是否实现了LastModified接口，如果实现了，调用long getLastModified(request)返回给客户端。\n通过web.xml中Servlet的初始化参数可以定制DispatcherServlet.\n\n参数 | 解释 |\n:---------- | :---------\ncontextClass | 实现WebApplicationContext的类，默认使用XmlWebApplicationContext \ncontextConfigLocation | 传递给Context 实例的字符串，包括了bean的定义 \nnamespace | WebApplicationContext 的命名空间，默认[servlet-name]-servlet \n\n拦截器\n\nHandlerMapping支持拦截器，在对某些请求添加处理的时候非常有用，比如，权限检查。拦截器必须实现org.springframework.web.servlet包中的HandlerInterceptor，这个接口有三个处理函数分别对应请求处理前，请求处理后，完成请求处理。\n  - preHandle(..) 在请求处理前执行\n  - postHandle(..) 请求处理后执行\n  - afterCompletion(..) 整个请求处理结束后执行\npreHandle(..) 返回一个boolean值。可以使用这个值来中断处理请求链。当返回true的时候，处理将会继续执行，如果返回false，DispatcherServelt假定拦截器已经对请求正确处理了，例如渲染了一个页面等。将会中断请求处理链。\n注意，postHandle方法很少使用@ResponseBody和ResponseEntity。因为响应已经在postHandle执行之前有HandlerAdapter返回了。意味着在postHandle的时候再修改响应已经晚了。对应这种场景可以继承ResponseBodyAdvice或者实现ControllerAdvice或者直接配置RequestMappingHandlerAdapter来实现。\n\n异常处理\n\n如果在请求映射或者处理请求的时候抛出异常，DispatcherServelt会委托HandlerExceptionResolver来解析异常并提供可选择的处理，即返一个错误响应。\n下表是HandlerExceptionResolver的实现\n\n HandlerExceptionResolver | 描述 \n:---------- | :---------\nSimpleMappingExceptionResolver | 异常类名和错误页面名的映射。浏览器渲染错误页面的时候非常实用 \nDefaultHandlerExceptionResolver | 解析SpringMVC抛出的异常，同时将其映射到HTTP的错误码上ResponseStatusExceptionResolver | 解析@ResponseStatus注解，同时根据其注解值将其映射到HTTP的错误码上ExceptionHandlerExceptionResolver | 调用@Controller 或者@ControllerAdvice 类中使用@ExceptionHandler注解的方法 \n\n解析链\n\n可以通过在Spring的配置中声明多个HandlerExceptionResolverbean，来构成一个异常处理解析链，如果需要的话，同时可以设置他们解析的顺序。序号越大，处理越靠后。\nHandlerExceptionResolver可以返回：\n  - 指向错误页面的 ModelAndView\n  - 如果异常在解析链中被处理返回空ModelAndView\n  - 如果异常为被处理返回null，后续的解析起继续处理异常，如果异常一直未被处理，那么将会冒泡到Servlet容器处理\nSpring MVC的异常是有MVC配置自动声明的，@ResponseStatus注解异常，支持@ExceptionHandler方法的异常。这些处理器都是可以定制和替换的\n\nServlet容器异常\n\n如果HandlerExceptionResolver无法处理异常，那么异常将会继续传播，或者是返回了错误的HTTP状态码，例如4xx，5xx。Servlet容器可能会渲染一个错误的页面。这个页面也是可以定制的：\nxml\n&lt;error-page&gt;\n    &lt;location&gt;/error&lt;/location&gt;\n&lt;/error-page&gt;\n\n\n根据上述代码，当出现了无法处理的异常，或者返回错误码，容器会根据配置返回一个错误的URL。这个请求将会继续被DispatcherServlet处理，比如映射到一个@Controller的错误处理控制器上：\n`Java\n@RestController\npublic class ErrorController {\n\n@RequestMapping(path = &quot;/error&quot;)\npublic Map&lt;String, Object&gt; handle(HttpServletRequest request) {\n    Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();\n    map.put(&quot;status&quot;, request.getAttribute(&quot;javax.servlet.error.status_code&quot;));\n    map.put(&quot;reason&quot;, request.getAttribute(&quot;javax.servlet.error.message&quot;));\n    return map;\n}\n\n}\n`\n\n视图解析\n\nSpring MVC通过定义了ViewResolver和View两个接口可以让我们直接通过返回model来渲染视图，而不需要指定某一个特定的视图技术。ViewResolver提供了视图名和视图之间的映射关系。在提交给特定视图技术之前由View来准备数据。\n下列表格展示了ViewResolver的层级：\n\n ViewResolver | 描述 \n:---------- | :---------\nAbstractCachingViewResolver | 缓存解析过的视图。可设置cache属性为false来关闭缓存。在需要刷新缓存的场景可调用removeFromCache(String viewName, Locale loc)刷新。\nXmlViewResolver | 实现ViewResolver，可以接收一个同Spring XML bean同DTD的xml配置文件。默认在/WEB-INF/views.xml\nResourceBundleViewResolver | 解析定义在ResourceBundle中的视图，使用viewname.class作为视图类，viewname.url作为视图名\nUrlBasedViewResolver | 无需明确指定映射，直接通过解析url来查找视图名。\nInternalResourceViewResolver | 实现UrlBasedViewResolver,JstlView,TilesView，支持InternalResourceView例如：jsp，servlet class等。\nFreeMarkerViewResolver | UrlBasedViewResolver的子类，用来支持FreeMarker\nContentNegotiatingViewResolver | 根据请求的文件名或者Accept来确定视图\n\n视图处理\n\n如果需要的话，可以声明多个视图处理器，通过设置order属性来确定他们的顺序。order越大，处理越靠后。\n默认情况下ViewResolver可以返回null代表找不到视图。当然在JSP中，使用InternalResourceViewResolver来检查JSP是否存在的唯一方式就是通过RequestDispatcher执行一次调度。因此InternalResourceViewResolver必须是最后一个视图解析器。\n\n视图redirect\n\n视图前缀redirect: 表示视图需要执行一次redirect。UrlBasedViewResolver和其子类会识别出这是要给重定向，剩下的部分就是视图名。\n这个效果和Controller返回一个RedirectView一样，但是使用这个指令，controller就可以简单的返回一个视图名就可以了。视图名redirect:/myapp/some/resource将会返回相对于当前Servlet Context的视图，redirect:http://myhost.com/some/arbitrary/path 这种则会返回绝对URL。\n注意，如果一个controller被@ResponseStatus修饰，那么注解值优先级高于RedirectView\n\n视图Forwarding\n\n视图前缀forward: 表示视图执行forwarding。同样由UrlBasedViewResolver和其子类解析。通过创建InternalResourceView执行RequestDispatcher.forward()实现。因此这个指令对于InternalResourceViewResolver和InternalResourceViewResolver没啥用，但是对于使用了其他的视图技术但是仍然想用强制使用JSP或者Servlet的时候就很有用了。\n\n视图内容协商\n\nContentNegotiatingViewResolver并不会解析视图，而是将其委托给其他视图解析器，并且选择客户端请求描述选择视图。描述可以是Accept头或者参数，例如/path?format=pdf\nContentNegotiatingViewResolver通过对比请求的媒体类型和ViewResolvers支持的媒体类型来选择合适的View。被选中的列表中的第一个View将会被返回给客户端。\n\n本地化\n\n同Spring MVC，大多数Spring架构支持国际化。DispatcherServlet通过LocaleResolver根据客户端的区域自动解析消息。\n当请求到来时DispatcherServlet查找本地化解析器，如果找到则会设置本地化。通过RequestContext.getLocale()方法可以获取由本地化解析器解析的本地化语言。\n为了自动化解析，可以通过拦截器对具体的场景进行本地化解析，例如根据请求参数来解析。\n本地化解析器和拦截器定义在org.springframework.web.servlet.i18n包中，可以在应用中配置。下面是一些Spring使用的配置\n\nTimeZone\n\n通过获取客户端的时区来做本地化。LocaleContextResolver接口扩展了LocalResolver，提供了一个可能包含时区信息的LocaleContext。\n如果可以，用户的时区可以通过RequestContext.getTimeZone()方法获取。时区信息可以自动的被注册到Spring中的ConversionService 日期时间的Converter和Formatter使用。\n\nHeader resolver\n\n这个解析器检查accept-language头，一般来说包含的是客户端操作系统的区域。注意这个不支持时区。\n\nCookie resolver\n\n这个解析器检查cookie中可能包含的TimeZone和Locale。通过如下定义来使用：\n`xml\n&lt;bean id=&quot;localeResolver&quot; class=&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;&gt;\n\n&lt;property name=&quot;cookieName&quot; value=&quot;clientlanguage&quot;/&gt;\n\n&lt;!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --&gt;\n&lt;property name=&quot;cookieMaxAge&quot; value=&quot;100000&quot;/&gt;\n\n&lt;/bean&gt;\n`\n\nCookieLocaleResolver的属性：\n\n 名字 | 默认值 | 描述 \n:---------- | :--------- | :----------\ncookieName | classname + LOCALE | cookie名\ncookieMaxAge | Servlet容器默认值 | cookie生效时间\ncookiePath | / | cookie 保存位置\n\nSession resolver\n\nSessionLocaleResolver通过从session中检查可能包含的TimeZone和Locale。相对于CookieLocaleResolver，他将信息保存在HttpSession中。\n\nLocale interceptor\n\n可以通过拦截器启动针对某些映射的本地化策略，例如如下：\n`xml\n&lt;bean id=&quot;localeChangeInterceptor&quot;\n        class=&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;&gt;\n    &lt;property name=&quot;paramName&quot; value=&quot;siteLanguage&quot;/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;localeResolver&quot;\n        class=&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;/&gt;\n\n&lt;bean id=&quot;urlMapping&quot;\n        class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;\n    &lt;property name=&quot;interceptors&quot;&gt;\n        &lt;list&gt;\n            &lt;ref bean=&quot;localeChangeInterceptor&quot;/&gt;\n        &lt;/list&gt;\n    &lt;/property&gt;\n    &lt;property name=&quot;mappings&quot;&gt;\n        &lt;value&gt;/**/*.view=someController&lt;/value&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n`\n\n主题\n\n可以通过设置Spring MVC的主题来整体设置应用的外观，从而提高用户体验。主题是一些静态资源的集合，主要是可以影响外观的样式表和图片。\n为了应用主题，首先要设置一个org.springframework.ui.context.ThemeSource的接口。WebApplicationContext继承了ThemeSource，但是将其实现委托给了子类。默认使用的是org.springframework.ui.context.support.ResourceBundleThemeSource来从classpath的根目录下加载配置文件。配置文件格式如下：\n\nstyleSheet=/themes/cool/style.css\nbackground=/themes/cool/img/coolBg.jpg\n\n配置文件的名字是视图代码中的变量名。对于JSP而言可以如下显示：\nJSP\n&lt;%@ taglib prefix=&quot;spring&quot; uri=&quot;http://www.springframework.org/tags&quot;%&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;spring:theme code=&#39;styleSheet&#39;/&gt;&quot; type=&quot;text/css&quot;/&gt;\n    &lt;/head&gt;\n    &lt;body style=&quot;background=&lt;spring:theme code=&#39;background&#39;/&gt;&quot;&gt;\n        ...\n    &lt;/body&gt;\n&lt;/html&gt;\n\n\n默认情况下ResourceBundleThemeSource使用空的前缀名，这样配置文件直接从classpath根目录下加载。这样就可以将cool.properties定义放到classpath根目录下，ResourceBundleThemeSource默认使用标准的Java资源加载工具，同时也完全支持国际化，所以通过命名来支持cool_nl.properties。\n\n解析主题\n\nDispatcherServlet通过bean的名字themeResolver来查找ThemeResolver的实现。\nThemeResolver 的实现如下：\n\nClass | 描述 \n:---------- | :---------\nFixedThemeResolver | 选中一个固定的主题，设置defaultThemeName属性\nSessionThemeResolver | 主题由用户session维护。每个session只需要设置一次\nCookieThemeResolver | 通过cookie选择主题\n\nMultipart resolver\n\norg.springframework.web.multipart中的MultipartResolver是用来处理multipart请求的。共有给予Common Fileupload和Servlet 3.0 两种实现。\n为了使用multipart，需要在DispatcherServlet的Spring配置中声明一个名字为multipartResolver的bean。当POST请求的content-type是multipart/form-data的时候，解析器解析这个请求并且将HttpServletRequest封装成MultipartHttpServletRequest来处理请求。\n\nApache FileUpload\n\n使用Apache Commons FileUpload 只需要简单的配置一个类型为CommonsMultipartResolver，名字为multipartResolver的bean即可。当然也需要将commons-fileupload加入到依赖中。\n\nServlet 3.0\n\n使用Servlet 3.0则需要Servlet 容器的配置\n  - 使用Java配置，在Servlet注册中设置MultipartConfigElement。\n  - 使用web.xml 添加要给&lt;multipart-config&gt;的配置\n如下是使用Java的配置：\n\n`Java\npublic class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n// ...\n\n@Override\nprotected void customizeRegistration(ServletRegistration.Dynamic registration) {\n\n    // Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold\n    registration.setMultipartConfig(new MultipartConfigElement(&quot;/tmp&quot;));\n}\n\n}\n`\n\nServlet 3.0配置好之后，只需要添加类型为StandardServletMultipartResolver，名字为multipartResolver的配置即可。","readingtime":24,"url":"/cates/Backend/post/2018-04-09/spring-mvc-dispatcher-servlet","dirs":["spring-mvc"],"relatives":[{"url":"/cates/Backend/post/2018-04-07/deep-in-spring-mvc","title":"深入理解Spring MVC"},{"url":"/cates/Backend/post/2018-04-10/spring-mvc-controller","title":"SpringMVC 教程 - Controller"},{"url":"/cates/Backend/post/2018-04-09/spring-mvc-filter","title":"SpringMVC 教程 - Filter"}],"body":"\n\n##### 简介\n同许多其他的web框架一样，SpringMVC使用了前端控制器的设计模式，即一个以`DispatcherServlet`为核心的`Servlet`为处理请求提供了一个共享的算法，而实际的工作是由可配置的委托组件执行的。这个模式即灵活又支持多样的工作流。\n同其他的`Servlet`,依照Servlet 规范`DispatcherServlet`需要在web.xml或者Java配置中声明并映射URL。接着`DispatcherServlet`使用Spring的配置来查找委托组件，用来映射URL，解析视图，异常处理等。\n下面这个示例是使用Java配置来注册并初始化`DispatcherServlet`，这个类由Servlet容器自动发现。\n```Java\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n\n    @Override\n    public void onStartup(ServletContext servletCxt) {\n\n        // Load Spring web application configuration\n        AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();\n        ac.register(AppConfig.class);\n        ac.refresh();\n\n        // Create and register the DispatcherServlet\n        DispatcherServlet servlet = new DispatcherServlet(ac);\n        ServletRegistration.Dynamic registration = servletCxt.addServlet(\"app\", servlet);\n        registration.setLoadOnStartup(1);\n        registration.addMapping(\"/app/*\");\n    }\n}\n```\n\n下面这个示例是使用`web.xml`来注册并初始化的\n```xml\n<web-app>\n\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>/WEB-INF/app-context.xml</param-value>\n    </context-param>\n\n    <servlet>\n        <servlet-name>app</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value></param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>app</servlet-name>\n        <url-pattern>/app/*</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n```\n\n##### 层次结构\n`DispatcherServlet`需要一个扩展了的`ApplicationContext`的`WebApplicationContext`来配置自己的信息。`WebApplicationContext`包含了`Servlet`的`ServletContext`的引用，可以使用`RequestContextUtils`中的静态方法从`WebApplicationContext`中查找`ServletContext`。\n对于大多数应用来说一个`WebApplicationContext`就足够了。当然`WebApplicatioContext`也可以是有层次结构的，例如由多个Servlet共享的一个根`WebApplicationContext`，每个Servlet又有自己的子`WebApplicationContext`。\n根`WebApplicationContext`一般包括需要在多个Servlet中共享的基础bean，例如数据仓库，业务逻辑等。在Servlet规范中，这些bean可以被有效的继承和改写，子`WebApplicationContext`仅包含在其属于的Servlet中。\n![spring mvc context](https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/mvc-context-hierarchy.png)\n下面这个例子就是`WebApplicationContext`的层级配置\n```Java\npublic class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class<?>[] { RootConfig.class };\n    }\n\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class<?>[] { App1Config.class };\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[] { \"/app1/*\" };\n    }\n} \n```\n\n同样的，在web.xml中的配置\n```xml\n<web-app>\n\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>/WEB-INF/root-context.xml</param-value>\n    </context-param>\n\n    <servlet>\n        <servlet-name>app1</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>/WEB-INF/app1-context.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>app1</servlet-name>\n        <url-pattern>/app1/*</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n```\n\n##### 特殊的bean类型\n`DispatcherServlet`委托专用的bean来处理请求，渲染响应。专用的bean指的是Spring管理的，实现WebFlux框架约定的实例。这些bean一般都是内建的约定，但是可以定制他们的属性，扩展或者代替这些bean。\n\nbean 类型 | 解释\n:---------- | :---------\nHandlerMapping | 处理器映射，具体由其子类实现。两个重要的子类，`RequestMappingHandlerMapping`,`SimpleUrlHandlerMapping`\nHandlerAdapter | 辅助`DispatcherServlet`执行特定的处理器。\nHandlerExceptionResolver | 将异常重定向到其他处理器或者是显示HTML的错误界面。\nViewResolver | 通过处理器返回的视图字符串查找具体的视图并渲染。 \nLocaleResolver, LocaleContextResolver | 支持国际化页面，使用例如时区等来解析本地化问题。 \nThemeResolver | 解析应用可用的主题，例如提供个性化框架 \nMultipartResolver | 处理上传文件 \nFlashMapManager | 保存和检索输入输出的FlashMap，它可以将属性从一个请求传递到另一个请求的输入输出，一般应用在重定向中。 \n\n##### Web MVC 配置\n应用可以声明在特殊的bean类型中列出的bean来处理请求。`DispatcherServlet`会检查每一个bean的`WebApplicationContext`。如果没有指定的bean，那么就会使用DispatcherServlet.properties中定义的bean。\nMVC配置将会在以后详细的列出。\n##### Servlet 配置\n在Servlet 3.0+中，可以使用编程的方式来代替web.xml配置。下面这个例子就是通过编程注册`DispatcherServlet`\n```Java\nimport org.springframework.web.WebApplicationInitializer;\n\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n\n    @Override\n    public void onStartup(ServletContext container) {\n        XmlWebApplicationContext appContext = new XmlWebApplicationContext();\n        appContext.setConfigLocation(\"/WEB-INF/spring/dispatcher-config.xml\");\n\n        ServletRegistration.Dynamic registration = container.addServlet(\"dispatcher\", new DispatcherServlet(appContext));\n        registration.setLoadOnStartup(1);\n        registration.addMapping(\"/\");\n    }\n}\n```\n\n`WebApplicationInitializer`是由SpringMVC提供的接口，用来保证上述实现可以由支持Servlet 3.0的容器自动检测并初始化。抽象类`AbstractDispatcherServletInitializerl`实现了`WebApplicationInitializer` 可以更加容易的注册`DispathcerServlet`。\n下面是使用Java配置的Spring\n```Java\npublic class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return null;\n    }\n\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class<?>[] { MyWebConfig.class };\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[] { \"/\" };\n    }\n}\n```\n\n如果使用的是xml配置，需要直接继承`AbstractDispatcherServletInitializer`\n```Java\npublic class MyWebAppInitializer extends AbstractDispatcherServletInitializer {\n\n    @Override\n    protected WebApplicationContext createRootApplicationContext() {\n        return null;\n    }\n\n    @Override\n    protected WebApplicationContext createServletApplicationContext() {\n        XmlWebApplicationContext cxt = new XmlWebApplicationContext();\n        cxt.setConfigLocation(\"/WEB-INF/spring/dispatcher-config.xml\");\n        return cxt;\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[] { \"/\" };\n    }\n}\n```\n\n`AbstractDispatcherServletInitializer`同样提供了一个方便的函数来添加过滤器。\n```Java\npublic class MyWebAppInitializer extends AbstractDispatcherServletInitializer {\n\n    // ...\n\n    @Override\n    protected Filter[] getServletFilters() {\n        return new Filter[] {\n            new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };\n    }\n}\n```\n\n每个过滤器根据他具体的类型添加一个默认的名字，并且自动映射到DispatcherServlet。\n`isAsyncSupported`方法是`AbstractDispatcherServletInitializer`的protect的方法，可以启动`DispatcherServlet`支持异步处理\n如果要定义自己的DispatcherServlet，那么可以重写`createDispatcherServlet`方法。\n##### 处理请求\n`DispatcherServlet`处理请求的流程如下：  \n  - 查找`WebApplicationContext`并将其作为request的一个属性保存起来，以便其他控制器或者处理链中的组件可以使用。默认保存键为`DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE` \n  - 本地化解析器保存在request中，以便处理链中的其他组件使用他来处理请求做本地化处理。如果不需要本地化，那么就不需要使用他。\n  - 主题解析器保存在request中，以便其他组件，例如视图查找器使用，如果不需要要主题定制，直接忽略。\n  - 如果指定了文件上传解析器，那么就会检查请求是否有文件上传，如果有请求有`MultipartHttpServletRequest`封装，以便其他组件处理。\n  - 查找合适的处理器处理请求。如果找到了处理器，那么就依次执行处理链上的组件，返回一个model或者视图。如果是注解的controller也可以直接渲染而不需要返回视图。\n  - 如果返回一个model，会渲染一个视图，如果没有返回model，那么就无需渲染视图了，因为视图可能已经被渲染了。\n\n在请求处理过程中如果出现了一场那么就可以使用`WebApplicatioContext`中的`HandlerExceptionResolver`来定制异常处理。\nSpringMVC 同样支持返回`last-modification-date`，对指定请求处理如何判断是否有`last-modification-date`非常直接：`DispatcherServlet`查找适合的处理器，并且检查其是否实现了`LastModified`接口，如果实现了，调用`long getLastModified(request)`返回给客户端。\n通过web.xml中Servlet的初始化参数可以定制DispatcherServlet.\n\n参数 | 解释 |\n:---------- | :---------\ncontextClass | 实现`WebApplicationContext`的类，默认使用`XmlWebApplicationContext` \ncontextConfigLocation | 传递给Context 实例的字符串，包括了bean的定义 \nnamespace | `WebApplicationContext` 的命名空间，默认`[servlet-name]-servlet` \n\n##### 拦截器\n`HandlerMapping`支持拦截器，在对某些请求添加处理的时候非常有用，比如，权限检查。拦截器必须实现`org.springframework.web.servlet`包中的`HandlerInterceptor`，这个接口有三个处理函数分别对应请求处理前，请求处理后，完成请求处理。\n  - preHandle(..) 在请求处理前执行\n  - postHandle(..) 请求处理后执行\n  - afterCompletion(..) 整个请求处理结束后执行\n`preHandle(..)` 返回一个boolean值。可以使用这个值来中断处理请求链。当返回true的时候，处理将会继续执行，如果返回false，`DispatcherServelt`假定拦截器已经对请求正确处理了，例如渲染了一个页面等。将会中断请求处理链。\n注意，`postHandle`方法很少使用`@ResponseBody`和`ResponseEntity`。因为响应已经在`postHandle`执行之前有`HandlerAdapter`返回了。意味着在`postHandle`的时候再修改响应已经晚了。对应这种场景可以继承`ResponseBodyAdvice`或者实现ControllerAdvice或者直接配置`RequestMappingHandlerAdapter`来实现。\n\n##### 异常处理\n如果在请求映射或者处理请求的时候抛出异常，`DispatcherServelt`会委托`HandlerExceptionResolver`来解析异常并提供可选择的处理，即返一个错误响应。\n下表是`HandlerExceptionResolver`的实现\n\n HandlerExceptionResolver | 描述 \n:---------- | :---------\nSimpleMappingExceptionResolver | 异常类名和错误页面名的映射。浏览器渲染错误页面的时候非常实用 \nDefaultHandlerExceptionResolver | 解析SpringMVC抛出的异常，同时将其映射到HTTP的错误码上  \nResponseStatusExceptionResolver | 解析@ResponseStatus注解，同时根据其注解值将其映射到HTTP的错误码上  \nExceptionHandlerExceptionResolver | 调用@Controller 或者@ControllerAdvice 类中使用@ExceptionHandler注解的方法 \n\n###### 解析链\n可以通过在Spring的配置中声明多个`HandlerExceptionResolver`bean，来构成一个异常处理解析链，如果需要的话，同时可以设置他们解析的顺序。序号越大，处理越靠后。\n`HandlerExceptionResolver`可以返回：\n  - 指向错误页面的 `ModelAndView`\n  - 如果异常在解析链中被处理返回空`ModelAndView`\n  - 如果异常为被处理返回`null`，后续的解析起继续处理异常，如果异常一直未被处理，那么将会冒泡到Servlet容器处理\nSpring MVC的异常是有MVC配置自动声明的，@ResponseStatus注解异常，支持@ExceptionHandler方法的异常。这些处理器都是可以定制和替换的\n###### Servlet容器异常\n如果`HandlerExceptionResolver`无法处理异常，那么异常将会继续传播，或者是返回了错误的HTTP状态码，例如4xx，5xx。Servlet容器可能会渲染一个错误的页面。这个页面也是可以定制的：\n```xml\n<error-page>\n    <location>/error</location>\n</error-page>\n```\n\n根据上述代码，当出现了无法处理的异常，或者返回错误码，容器会根据配置返回一个错误的URL。这个请求将会继续被DispatcherServlet处理，比如映射到一个@Controller的错误处理控制器上：\n```Java\n@RestController\npublic class ErrorController {\n\n    @RequestMapping(path = \"/error\")\n    public Map<String, Object> handle(HttpServletRequest request) {\n        Map<String, Object> map = new HashMap<String, Object>();\n        map.put(\"status\", request.getAttribute(\"javax.servlet.error.status_code\"));\n        map.put(\"reason\", request.getAttribute(\"javax.servlet.error.message\"));\n        return map;\n    }\n}\n```\n\n##### 视图解析\nSpring MVC通过定义了`ViewResolver`和`View`两个接口可以让我们直接通过返回model来渲染视图，而不需要指定某一个特定的视图技术。`ViewResolver`提供了视图名和视图之间的映射关系。在提交给特定视图技术之前由`View`来准备数据。\n下列表格展示了ViewResolver的层级：\n\n ViewResolver | 描述 \n:---------- | :---------\nAbstractCachingViewResolver | 缓存解析过的视图。可设置cache属性为false来关闭缓存。在需要刷新缓存的场景可调用`removeFromCache(String viewName, Locale loc)`刷新。\nXmlViewResolver | 实现`ViewResolver`，可以接收一个同Spring XML bean同DTD的xml配置文件。默认在/WEB-INF/views.xml\nResourceBundleViewResolver | 解析定义在`ResourceBundle`中的视图，使用viewname.class作为视图类，viewname.url作为视图名\nUrlBasedViewResolver | 无需明确指定映射，直接通过解析url来查找视图名。\nInternalResourceViewResolver | 实现`UrlBasedViewResolver`,`JstlView`,`TilesView`，支持`InternalResourceView`例如：jsp，servlet class等。\nFreeMarkerViewResolver | `UrlBasedViewResolver`的子类，用来支持FreeMarker\nContentNegotiatingViewResolver | 根据请求的文件名或者Accept来确定视图\n\n###### 视图处理\n如果需要的话，可以声明多个视图处理器，通过设置`order`属性来确定他们的顺序。order越大，处理越靠后。\n默认情况下`ViewResolver`可以返回null代表找不到视图。当然在JSP中，使用InternalResourceViewResolver来检查JSP是否存在的唯一方式就是通过`RequestDispatcher`执行一次调度。因此`InternalResourceViewResolver`必须是最后一个视图解析器。\n###### 视图redirect\n视图前缀`redirect:` 表示视图需要执行一次redirect。`UrlBasedViewResolver`和其子类会识别出这是要给重定向，剩下的部分就是视图名。\n这个效果和Controller返回一个`RedirectView`一样，但是使用这个指令，controller就可以简单的返回一个视图名就可以了。视图名`redirect:/myapp/some/resource`将会返回相对于当前Servlet Context的视图，`redirect:http://myhost.com/some/arbitrary/path` 这种则会返回绝对URL。\n注意，如果一个controller被`@ResponseStatus`修饰，那么注解值优先级高于`RedirectView`\n###### 视图Forwarding\n视图前缀`forward: `表示视图执行forwarding。同样由`UrlBasedViewResolver`和其子类解析。通过创建`InternalResourceView`执行`RequestDispatcher.forward()`实现。因此这个指令对于`InternalResourceViewResolver`和`InternalResourceViewResolver`没啥用，但是对于使用了其他的视图技术但是仍然想用强制使用JSP或者Servlet的时候就很有用了。\n###### 视图内容协商\n`ContentNegotiatingViewResolver`并不会解析视图，而是将其委托给其他视图解析器，并且选择客户端请求描述选择视图。描述可以是Accept头或者参数，例如`/path?format=pdf`\n`ContentNegotiatingViewResolver`通过对比请求的媒体类型和`ViewResolvers`支持的媒体类型来选择合适的View。被选中的列表中的第一个View将会被返回给客户端。\n##### 本地化\n同Spring MVC，大多数Spring架构支持国际化。`DispatcherServlet`通过`LocaleResolver`根据客户端的区域自动解析消息。\n当请求到来时`DispatcherServlet`查找本地化解析器，如果找到则会设置本地化。通过`RequestContext.getLocale()`方法可以获取由本地化解析器解析的本地化语言。\n为了自动化解析，可以通过拦截器对具体的场景进行本地化解析，例如根据请求参数来解析。\n本地化解析器和拦截器定义在`org.springframework.web.servlet.i18n`包中，可以在应用中配置。下面是一些Spring使用的配置\n\n###### TimeZone\n通过获取客户端的时区来做本地化。`LocaleContextResolver`接口扩展了`LocalResolver`，提供了一个可能包含时区信息的`LocaleContext`。\n如果可以，用户的时区可以通过`RequestContext.getTimeZone()`方法获取。时区信息可以自动的被注册到Spring中的ConversionService 日期时间的Converter和Formatter使用。\n###### Header resolver\n这个解析器检查`accept-language`头，一般来说包含的是客户端操作系统的区域。注意这个不支持时区。\n###### Cookie resolver\n这个解析器检查cookie中可能包含的`TimeZone`和`Locale`。通过如下定义来使用：\n```xml\n<bean id=\"localeResolver\" class=\"org.springframework.web.servlet.i18n.CookieLocaleResolver\">\n\n    <property name=\"cookieName\" value=\"clientlanguage\"/>\n\n    <!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) -->\n    <property name=\"cookieMaxAge\" value=\"100000\"/>\n\n</bean>\n```\n\nCookieLocaleResolver的属性：\n\n 名字 | 默认值 | 描述 \n:---------- | :--------- | :----------\ncookieName | classname + LOCALE | cookie名\ncookieMaxAge | Servlet容器默认值 | cookie生效时间\ncookiePath | / | cookie 保存位置\n\n###### Session resolver\n`SessionLocaleResolver`通过从session中检查可能包含的`TimeZone`和`Locale`。相对于`CookieLocaleResolver`，他将信息保存在`HttpSession`中。\n###### Locale interceptor\n可以通过拦截器启动针对某些映射的本地化策略，例如如下：\n```xml\n<bean id=\"localeChangeInterceptor\"\n        class=\"org.springframework.web.servlet.i18n.LocaleChangeInterceptor\">\n    <property name=\"paramName\" value=\"siteLanguage\"/>\n</bean>\n\n<bean id=\"localeResolver\"\n        class=\"org.springframework.web.servlet.i18n.CookieLocaleResolver\"/>\n\n<bean id=\"urlMapping\"\n        class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\">\n    <property name=\"interceptors\">\n        <list>\n            <ref bean=\"localeChangeInterceptor\"/>\n        </list>\n    </property>\n    <property name=\"mappings\">\n        <value>/**/*.view=someController</value>\n    </property>\n</bean>\n```\n\n##### 主题\n可以通过设置Spring MVC的主题来整体设置应用的外观，从而提高用户体验。主题是一些静态资源的集合，主要是可以影响外观的样式表和图片。\n为了应用主题，首先要设置一个`org.springframework.ui.context.ThemeSource`的接口。`WebApplicationContext`继承了`ThemeSource`，但是将其实现委托给了子类。默认使用的是`org.springframework.ui.context.support.ResourceBundleThemeSource`来从classpath的根目录下加载配置文件。配置文件格式如下：\n```\nstyleSheet=/themes/cool/style.css\nbackground=/themes/cool/img/coolBg.jpg\n```\n配置文件的名字是视图代码中的变量名。对于JSP而言可以如下显示：\n```JSP\n<%@ taglib prefix=\"spring\" uri=\"http://www.springframework.org/tags\"%>\n<html>\n    <head>\n        <link rel=\"stylesheet\" href=\"<spring:theme code='styleSheet'/>\" type=\"text/css\"/>\n    </head>\n    <body style=\"background=<spring:theme code='background'/>\">\n        ...\n    </body>\n</html>\n```\n\n默认情况下`ResourceBundleThemeSource`使用空的前缀名，这样配置文件直接从classpath根目录下加载。这样就可以将`cool.properties`定义放到classpath根目录下，`ResourceBundleThemeSource`默认使用标准的Java资源加载工具，同时也完全支持国际化，所以通过命名来支持`cool_nl.properties`。\n###### 解析主题\n`DispatcherServlet`通过bean的名字`themeResolver`来查找`ThemeResolver`的实现。\nThemeResolver 的实现如下：\n\nClass | 描述 \n:---------- | :---------\nFixedThemeResolver | 选中一个固定的主题，设置`defaultThemeName`属性\nSessionThemeResolver | 主题由用户session维护。每个session只需要设置一次\nCookieThemeResolver | 通过cookie选择主题\n##### Multipart resolver\n`org.springframework.web.multipart`中的`MultipartResolver`是用来处理multipart请求的。共有给予Common Fileupload和Servlet 3.0 两种实现。\n为了使用multipart，需要在`DispatcherServlet`的Spring配置中声明一个名字为`multipartResolver`的bean。当POST请求的`content-type`是`multipart/form-data`的时候，解析器解析这个请求并且将`HttpServletRequest`封装成`MultipartHttpServletRequest`来处理请求。\n###### Apache FileUpload\n使用Apache Commons FileUpload 只需要简单的配置一个类型为`CommonsMultipartResolver`，名字为`multipartResolver`的bean即可。当然也需要将`commons-fileupload`加入到依赖中。\n###### Servlet 3.0\n使用Servlet 3.0则需要Servlet 容器的配置\n  - 使用Java配置，在Servlet注册中设置`MultipartConfigElement`。\n  - 使用web.xml 添加要给`<multipart-config>`的配置\n如下是使用Java的配置：\n\n```Java\npublic class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    // ...\n\n    @Override\n    protected void customizeRegistration(ServletRegistration.Dynamic registration) {\n\n        // Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold\n        registration.setMultipartConfig(new MultipartConfigElement(\"/tmp\"));\n    }\n\n}\n```\n\nServlet 3.0配置好之后，只需要添加类型为`StandardServletMultipartResolver`，名字为`multipartResolver`的配置即可。\n\n"}}}