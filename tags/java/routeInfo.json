{"path":"tags/java","templateID":3,"sharedPropsHashes":{},"localProps":{"posts":[{"title":"Jackson 简明教程","tags":["JSON","Java","Jackson","Translate","backend"],"iso8601Date":"2018-03-31T08:39:10+08:00","basename":"jackson-tutorial","body":"\n\n[原文地址](https://github.com/FasterXML/jackson-databind/)  \n\n#### 一分钟教程：POJOs和JSON的互相转换\n\n最常用的功能就是将一段JSON片段组装成POJOs。所以我们首先从这个入手。下面是一个简单的，有两个属性的POJO：  \n\n```Java\n// Note: can use getters/setters as well; here we just use public fields directly:\npublic class MyValue {\n  public String name;\n  public int age;\n  // NOTE: if using getters/setters, can keep fields `protected` or `private`\n}\n```\n\n我们需要一个`com.fasterxml.jackson.databind.ObjectMapper`的实例来做所有的数据绑定，`ObjectMapper`仅需要创建一次即可。  \n\n```Java\nObjectMapper mapper = new ObjectMapper(); // create once, reuse\n```\n采用默认构造函数目前基本够用，当需要处理特殊情况的时候再学习如何根据情况配置ObjectMapper。以下是使用`ObjectMapper`的示例：  \n\n```Java\nMyValue value = mapper.readValue(new File(\"data.json\"), MyValue.class);\n// or:\nvalue = mapper.readValue(new URL(\"http://some.com/api/entry.json\"), MyValue.class);\n// or:\nvalue = mapper.readValue(\"{\\\"name\\\":\\\"Bob\\\", \\\"age\\\":13}\", MyValue.class);\n```\n如果想要生成JSON，只需要反过来就行：\n\n```Java\nmapper.writeValue(new File(\"result.json\"), myResultObject);\n// or:\nbyte[] jsonBytes = mapper.writeValueAsBytes(myResultObject);\n// or:\nString jsonString = mapper.writeValueAsString(myResultObject);\n```\n#### 三分钟教程：泛型集合和树模型\n除了处理Bean风格的POJO，Jackson同时可以处理JDK的`List`和`Map`:  \n```Java\nMap<String, Integer> scoreByName = mapper.readValue(jsonSource, Map.class);\nList<String> names = mapper.readValue(jsonSource, List.class);\n\n// and can obviously write out as well\nmapper.writeValue(new File(\"names.json\"), names);\n```\n匹配这种，只要JSON的结构匹配，并且类型简单就可以。如果有POJO值，则需要声明他的实际类型(PS:POJO的属性如果是`List`等类型，则不需要指定类型)  \n\n```Java\nMap<String, ResultValue> results = mapper.readValue(jsonSource,\n   new TypeReference<Map<String, ResultValue>>() { } );\n// why extra work? Java Type Erasure will prevent type detection otherwise })\n```\n然而，处理`Map`,`List`和其他'简单'类型(String,Number,Boolean)可以更见简单，对象遍历非常麻烦，所以Jackson的`Tree Model`迟早有用。  \n\n```Java\n// can be read as generic JsonNode, if it can be Object or Array; or,\n// if known to be Object, as ObjectNode, if array, ArrayNode etc:\nObjectNode root = mapper.readTree(\"stuff.json\");\nString name = root.get(\"name\").asText();\nint age = root.get(\"age\").asInt();\n\n// can modify as well: this adds child Object as property 'other', set property 'type'\nroot.with(\"other\").put(\"type\", \"student\");\nString json = mapper.writeValueAsString(root);\n\n// with above, we end up with something like as 'json' String:\n// {\n//   \"name\" : \"Bob\", \"age\" : 13,\n//   \"other\" : {\n//      \"type\" : \"student\"\n//   }\n// }\n```\n树模型比data-bind更加的方便，尤其是高度动态的数据结构，或者JSON无法完美映射Java类的时候。\n#### 五分钟教程：Streaming parser, generator\n有一种更见标准的处理模型，叫做incremental model，也叫Stream model ，这种处理方法和data-bind方式同样方便，和Tree Model同样灵活。data-bind和Tree Model 底层都是基于它。但是同样也暴露给那些想要极致性能和完全掌控解析JSON的用户。\n\n```Java\nJsonFactory f = mapper.getFactory(); // may alternatively construct directly too\n\n// First: write simple JSON output\nFile jsonFile = new File(\"test.json\");\nJsonGenerator g = f.createGenerator(jsonFile);\n// write JSON: { \"message\" : \"Hello world!\" }\ng.writeStartObject();\ng.writeStringField(\"message\", \"Hello world!\");\ng.writeEndObject();\ng.close();\n\n// Second: read file back\nJsonParser p = f.createParser(jsonFile);\n\nJsonToken t = p.nextToken(); // Should be JsonToken.START_OBJECT\nt = p.nextToken(); // JsonToken.FIELD_NAME\nif ((t != JsonToken.FIELD_NAME) || !\"message\".equals(p.getCurrentName())) {\n   // handle error\n}\nt = p.nextToken();\nif (t != JsonToken.VALUE_STRING) {\n   // similarly\n}\nString msg = p.getText();\nSystem.out.printf(\"My message to you is: %s!\\n\", msg);\np.close(); }\n```\n#### 10分钟教程：配置\n有两种入门的配置方法：feature 和 Annotation\n##### feature 配置\n下面是一些最常用的配置\n首先从高层的data-bind配置开始：\n\n```Java\n// SerializationFeature for changing how JSON is written\n\n// to enable standard indentation (\"pretty-printing\"):\nmapper.enable(SerializationFeature.INDENT_OUTPUT);\n// to allow serialization of \"empty\" POJOs (no properties to serialize)\n// (without this setting, an exception is thrown in those cases)\nmapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);\n// to write java.util.Date, Calendar as number (timestamp):\nmapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n\n// DeserializationFeature for changing how JSON is read as POJOs:\n\n// to prevent exception when encountering unknown property:\nmapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);\n// to allow coercion of JSON empty String (\"\") to null Object value:\nmapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n```\n下面是一些可以控制JSON底层解析，生成的配置：\n\n```Java\n// JsonParser.Feature for configuring parsing settings:\n\n// to allow C/C++ style comments in JSON (non-standard, disabled by default)\n// (note: with Jackson 2.5, there is also `mapper.enable(feature)` / `mapper.disable(feature)`)\nmapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);\n// to allow (non-standard) unquoted field names in JSON:\nmapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);\n// to allow use of apostrophes (single quotes), non standard\nmapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);\n\n// JsonGenerator.Feature for configuring low-level JSON generation:\n\n// to force escaping of non-ASCII characters:\nmapper.configure(JsonGenerator.Feature.ESCAPE_NON_ASCII, true);\n```\n##### 注解配置：修改属性名\n最简单的使用注解配置的方式是使用`@JsonProperty`:  \n\n```Java\npublic class MyBean {\n   private String _name;\n\n   // without annotation, we'd get \"theName\", but we want \"name\":\n   @JsonProperty(\"name\")\n   public String getTheName() { return _name; }\n\n   // note: it is enough to add annotation on just getter OR setter;\n   // so we can omit it here\n   public void setTheName(String n) { _name = n; }\n} \n```\n##### 注解配置：忽略属性\n有两个可以设置忽略属性的注解，一个是`@JsonIgnore` 修饰的是单个属性，一个是`@JsonIgnoreProperties` 修饰的类。\n\n```Java\n// means that if we see \"foo\" or \"bar\" in JSON, they will be quietly skipped\n// regardless of whether POJO has such properties\n@JsonIgnoreProperties({ \"foo\", \"bar\" })\npublic class MyBean\n{\n   // will not be written as JSON; nor assigned from JSON:\n   @JsonIgnore\n   public String internal;\n\n   // no annotation, public field is read/written normally\n   public String external;\n\n   @JsonIgnore\n   public void setCode(int c) { _code = c; }\n\n   // note: will also be ignored because setter has annotation!\n   public int getCode() { return _code; }\n} \n```\n由于重命名，所以注解是在匹配的的字段，get，set中共享的：如果其中一个设置了`@JsonIgnore`，其他的也受影响。当然也可以使用分离的注解来解决问题：\n\n```Java\npublic class ReadButDontWriteProps {\n   private String _name;\n   @JsonProperty public void setName(String n) { _name = n; }\n   @JsonIgnore public String getName() { return _name; }\n} \n```\n在这个例子中，`name`不会被写入到JSON中，但是如果JSON中有，则会映射到Java对象中。\n\n##### 注解配置：定制注解构造器\n和其他的data-bind包不同，jackson 不需要定义默认的构造函数（即不包含参数的构造函数）。如果需要，可以定义一个简单的包含参数的构造函数:  \n\n```Java\npublic class CtorBean\n{\n  public final String name;\n  public final int age;\n\n  @JsonCreator // constructor can be public, private, whatever\n  private CtorBean(@JsonProperty(\"name\") String name,\n    @JsonProperty(\"age\") int age)\n  {\n      this.name = name;\n      this.age = age;\n  }\n}\n```\n构造函数在不可变对象中非常实用。  \n也可以直接定义一个工厂方法：\n\n```Java\npublic class FactoryBean\n{\n    // fields etc omitted for brewity\n\n    @JsonCreator\n    public static FactoryBean create(@JsonProperty(\"name\") String name) {\n      // construct and return an instance\n    }\n}\n```\n#### 其他特性：\n一个有用，但是不被广泛知晓的功能就是Jackson可以任意转换两个POJO。可以将其想象成两步，第一步，将POJO写成JSON，第二步讲JSON写成另一个POJO。实现的时候用了更加高效的一种方法，并没有生成中间的JSON。\n转换在兼容的类型中运行的很好：\n\n```Java\nResultType result = mapper.convertValue(sourceObject, ResultType.class);\n```\n只要这两个POJO的类型兼容，即to json 和 from json的成功，那么就可以成功：\n\n```Java\n// Convert from List<Integer> to int[]\nList<Integer> sourceList = ...;\nint[] ints = mapper.convertValue(sourceList, int[].class);\n// Convert a POJO into Map!\nMap<String,Object> propertyMap = mapper.convertValue(pojoValue, Map.class);\n// ... and back\nPojoType pojo = mapper.convertValue(propertyMap, PojoType.class);\n// decode Base64! (default byte[] representation is base64-encoded String)\nString base64 = \"TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz\";\nbyte[] binary = mapper.convertValue(base64, byte[].class);\n```\n基本上Jackson可以替换很多Apache Commons的组件，例如Base64的编码解码，处理动态POJO等。\n","date":"2018-03-31"},{"title":"Linux 如何查找Java 程序CPU负载过高","tags":["CPU","Java","Linux","backend"],"iso8601Date":"2017-03-25T19:20:26+08:00","basename":"cpu-load-high","body":"\n\n\n准备程序：\n\n```Java\npackage test;\n\npublic class Test{\n    public static void main(String[] args){\n        new Thread(new Runnable(){\n            public void run(){\n                while(true){\n\n                }\n            }\n        }).start();\n    }\n}\n```\n其中一个线程回导致一直占用CPU，编译运行。通过`top` 获取CPU占用信息\n![top cpu](https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/top.png)\n可以看到占用最高的 pid是 25955\n通过`top -p 25955 -H` 获取进程内部线程的CPU使用率。\n![topph](https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/tophp.png)\n可以发现占用最高的线程ID是 `25965` 将其转换为16进制`python -c 'print hex(25965)'` 得到的值是`0x656d` \n使用 `jstack -l 25955 > jstack.log` 得到Java进程的Thread dump，通过 `grep -i 0x656d -A 30 jstack.log` 获取Java Thread id为0x656d的线程的thread dump。\n![jstack](https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/jstack.png)\n然后就可以定位相应代码查找代码占用CPU过高问题。\n","date":"2017-03-25"},{"title":"MyBatis 配置","tags":["Java","Mybatis","Translate","backend"],"iso8601Date":"2017-06-28T22:13:32+08:00","basename":"mybaits-configuration","body":"\n\n[原文链接](http://www.mybatis.org/mybatis-3/configuration.html)\n\nMyBatis的配置包含了设置和属性，他们对MyBatis的行为有很大的影响。MyBatis的配置文件层次结构如下：\n* configuration\n    * properties\n    * settings\n    * typeAliases\n    * typeHandlers\n    * objectFactory\n    * plugins\n    * environments\n        * environment\n            * transactionManager\n            * dataSource\n    * databaseIdProvider\n    * mappers\n\n### properties\n可以通过一个典型的Java Properties 类实例配置可替换的外部属性，也可以通过子元素传递这些配置属性，例如\n```xml\n<properties resource=\"org/mybatis/example/config.properties\">\n  <property name=\"username\" value=\"dev_user\"/>\n  <property name=\"password\" value=\"F2Fa3!33TYyg\"/>\n</properties>\n```\n然后这些配置属性就可以应用于配置文件中需要动态配置的其他属性。例如：\n```xml\n<dataSource type=\"POOLED\">\n  <property name=\"driver\" value=\"${driver}\"/>\n  <property name=\"url\" value=\"${url}\"/>\n  <property name=\"username\" value=\"${username}\"/>\n  <property name=\"password\" value=\"${password}\"/>\n</dataSource>\n```\n在这个例子中的username和password将会被properties的配置属性替换。driver和url属性会被config.properties的配置替换。这个为配置提供了很多的选项。    \nProperties同样可以直传入SqlSessionFactoryBuild.build() 方法中，例如：\n```Java\nSqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props);\n\n// ... or ...\n\nSqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props);\n```\n如果同一个属性同时配置到不同的位置，MyBatis按照如下的顺序加载它们：    \n1. 在Properties内的子元素首先被加载。     \n2. 其次从resource classpath和url中加载属性并覆盖已存在的属性。    \n3. 作为方法参数的属性最后被加载，并且覆盖前面两次相同的属性。\n\n因此，优先级最高的是直接作为参数传入方法，其次是从resource classpath或者url加载的配置文件，最后是Properties中的子元素定义的属性。    \nMyBatis 3.4.2 之后可以如下使用默认占位符。\n```xml\n<dataSource type=\"POOLED\">\n  <!-- ... -->\n  <property name=\"username\" value=\"${username:ut_user}\"/> <!-- If 'username' property not present, username become 'ut_user' -->\n</dataSource>\n```\n这个功能默认是无效的，如果要开启这个功能，需要在配置属性中如下开启：\n```xml\n<properties resource=\"org/mybatis/example/config.properties\">\n  <!-- ... -->\n  <property name=\"org.apache.ibatis.parsing.PropertyParser.enable-default-value\" value=\"true\"/> <!-- Enable this feature -->\n</properties>\n```\n注意：如果已经使用了“：”作为属性的键例如：`db:username`，或者是在sql的定义中使用了OGNL的三元符，例如：`${tableName != null ? tableName : 'global_constants'}`那么就需要修改默认的分隔符，如下：\n```xml\n<properties resource=\"org/mybatis/example/config.properties\">\n  <!-- ... -->\n  <property name=\"org.apache.ibatis.parsing.PropertyParser.default-value-separator\" value=\"?:\"/> <!-- Change default value of separator -->\n</properties>\n```\n```xml\n<dataSource type=\"POOLED\">\n  <!-- ... -->\n  <property name=\"username\" value=\"${db:username?:ut_user}\"/>\n</dataSource>\n```\n","date":"2017-06-28"},{"title":"mybatis 入门","tags":["Java","Mybatis","Translate","backend"],"iso8601Date":"2017-03-21T19:58:14+08:00","basename":"mybatis-started","body":"\n[原文链接](http://www.mybatis.org/mybatis-3/getting-started.html)\n#### 安装\n使用Mybatis只需要将[mybatis-x.x.x.jar](https://github.com/mybatis/mybatis-3/releases)添加到类路径即可。\n如果使用maven只需要将下列代码添加到pom.xml中。\n```xml\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis</artifactId>\n  <version>x.x.x</version>\n</dependency>\n```\n#### 根据XML配置构建SqlSessionFactory\n每一个Mybatis应用都围绕SqlSessionFactory展开。一个SqlSessionFactory实例由SqlSessionFactoryBuilder创建。SqlSessionFacotryBuilder可以通过XML的配置文件或者一个配置好的Configuration类来创建SqlSessionFactory。\n根据XML配置来构建SqlSessionFacotry非常的简单。推荐使用在类路径来配置，但是同样可以使用任何的InputStream实例，包括一个普通的文件路径或者是file:// 的URL。Mybatis有一个叫`Resource`的工具函数，可以很容易的从类路径或者其他文件路径加载资源。\n```Java\nString resource = \"org/mybatis/example/mybatis-config.xml\";\nInputStream inputStream = Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n```\nXML配置文件包含了Mybatis的核心设置，包括对应数据库连接的数据源，同样还有一个事务管理器来决定事务的范围和控制。完整的XML配置稍后会在文档中列出，下面是一个示例配置。\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n  PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n  <environments default=\"development\">\n    <environment id=\"development\">\n      <transactionManager type=\"JDBC\"/>\n      <dataSource type=\"POOLED\">\n        <property name=\"driver\" value=\"${driver}\"/>\n        <property name=\"url\" value=\"${url}\"/>\n        <property name=\"username\" value=\"${username}\"/>\n        <property name=\"password\" value=\"${password}\"/>\n      </dataSource>\n    </environment>\n  </environments>\n  <mappers>\n    <mapper resource=\"org/mybatis/example/BlogMapper.xml\"/>\n  </mappers>\n</configuration>\n```\nXML配置文件的元素还有很多，上面这个配置只是指出了最重要的一部分。注意XML的header，是用来验证xml文件的。`environment`元素包含了一个事务管理器和一个连接池。`mappers`元素包含了很多`mapper`，mapper可以是xml配置或者只Java 的interface，他们都包含了SQL代码和mapper的定义。\n#### 不使用XML构建SqlSessionFactory\n如果你不想使用XML配置或者想自己创建配置构造器，可以直接使用Java来构建配置。MyBatis提供了一个Configuration类可以提供所有XML配置文件所能提供的配置。\n```Java\nDataSource dataSource = BlogDataSourceFactory.getBlogDataSource();\nTransactionFactory transactionFactory = new JdbcTransactionFactory();\nEnvironment environment = new Environment(\"development\", transactionFactory, dataSource);\nConfiguration configuration = new Configuration(environment);\nconfiguration.addMapper(BlogMapper.class);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);\n```\n注意在这个配置中添加了一个mapper类。mapper类包含了一个SQL映射的注解，这样可以避免使用XML配置mapper。但是由于Java注解的限制和一些MyBatis复杂的mapper配置，XML mapper仍然是一些复杂的高级映射的首选（例如，inner join)。因此MyBatis会自动寻找并加载每一个XML配置（在这个例子中BlogMapper.xml将会被从类路径中加载)。更多的稍后介绍。\n#### 从SqlSessionFactory获取SqlSession\n 现在你已经有了SqlSessionFactory了，根据名字的提示，可以从它得到一个SqlSession实例。SqlSession包含了所有执行数据库操作的SQL方法。你可以直接通过SqlSession执行映射的SQL。例如：\n```Java\nSqlSession session = sqlSessionFactory.openSession();\ntry {\n  Blog blog = session.selectOne(\"org.mybatis.example.BlogMapper.selectBlog\", 101);\n} finally {\n  session.close();\n}\n```\n虽然这种方式对于之前的MyBatis的用户来说很熟悉，但是现在有一种跟清晰的方式。使用接口（例如：BlogMapper.class），该接口的方法定义了参数和返回值，这样就可以使用更加清晰的，类型安全的代码，而不再需要容易发生错误的并且去要强制类型转换的代码。例如：\n```Java\nSqlSession session = sqlSessionFactory.openSession();\ntry {\n  BlogMapper mapper = session.getMapper(BlogMapper.class);\n  Blog blog = mapper.selectBlog(101);\n} finally {\n  session.close();\n}\n```\n现在让我们来看一下到底执行了些什么。\n#### 探索映射的SQL语句\n现在你可能在想SqlSession和Mapper类到底执行了什么。映射SQL语句这个主题比较大，这个主题差不多占据了此文档的一大部分。但是下面这些语句会展示这些示例到底执行了些什么。\n无论是上面还是下面这些例子，这些语句都可以被定义在XML或者注解上。让我们先使用XML类配置。通过XML映射实现的MyBatis全套功能使得MyBatis流行了很多年。如果你以前用过MyBatis，这些概念你可能很熟悉，但是也有为数众多的对XML映射文档的改进。下面是一个可以满足上面的SqlSesion调用的XML配置的映射语句。\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n  PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"org.mybatis.example.BlogMapper\">\n  <select id=\"selectBlog\" resultType=\"Blog\">\n    select * from Blog where id = #{id}\n  </select>\n</mapper>\n```\n虽然这个例子对于这个简单的项目看起来很重量级，实际上他是很轻量级的。你可以在一个XML的映射文件中定义许多的映射语句，因此你可以减少很多的XML的header和doctype声明。文件余下的部分完全可以自解释。在命名空间`org.mybatis.example.BlogMapper`中定义了一个名为`selectBlog`的映射语句。他可以让你像例子中那样通过全限定名`org.mybatis.example.BlogMapper.selectBlog`调用他。\n```Java\nBlog blog = session.selectOne(\"org.mybatis.example.BlogMapper.selectBlog\", 101);\n```\n注意他和调用的Java函数很相似，这么做是有原因的。这个名字可以直接映射具有相同名字的命名空间，函数名，参数，返回值都可以和select语句匹配。这样就可以通过简单的调用Mapper接口的函数来使用映射的SQL语句了。\n```Java\nBlogMapper mapper = session.getMapper(BlogMapper.class);\nBlog blog = mapper.selectBlog(101);\n```\n第二个例子有很多优势，首先他并不依赖于字符串字面量，这样他更加的安全。其次，IDE都有代码补全，当导航到映射一句的时候可以利用这个。\n> namespace 的注意事项  \n> MyBatis之前的版本**Namespace**是可选的，这样既没用又困惑。现在namespace是必须的，通过一个很长的，全限定名的语句来区分不同的语句。  \n> 正如所见，namespace绑定了接口，即使你现在不使用他们，也要遵守这个规则，以防哪天改变想法。从长远来看，使用Namespace将他放在一个Java的package名中可以使代码更清晰，提高可用性。\n> 名字解析：为了减少输入，对于所有的命名配置，包括语句，result map， cache，使用下列名字解析规则：\n> * 全限定名（例如：com.mypackage.MyMapper.selectAllThings）直接查找，找到后直接使用。\n> * 短名字（例如：selectAllThings）可以使用任何明确的条目。然而如果匹配了多了个（例如：com.foo.selectAllThings and com.bar.selectAllThing），那么将会报名字模糊的错误，这个时候必须使用全限定名。\n\n对于BlogMapper还有一个小诀窍。他们的映射语句完全不需要XML配置文件，可以使用注解来代替。例如下面这个例子就可以代替XML配置：\n```Java\npackage org.mybatis.example;\npublic interface BlogMapper {\n  @Select(\"SELECT * FROM blog WHERE id = #{id}\")\n  Blog selectBlog(int id);\n}\n```\n注解相对来说更加的简洁，但是由于注解自身的限制和一些复杂语句的复杂性，如果使用复杂的SQL语句最好还是使用XML配置。\n这个完全取决于你和你的团队和定义映射语句的一致性类决定使用哪个方式。也就是说你不需要仅仅选择一个。从注解到XML的迁移是很方便的，反之亦然。\n#### 作用域和生命周期\n明白我们现在所讨论的类的作用域和生命周期是很重要的。错误的使用会导致并发错误。\n> **对象生命周期和依赖注入框架**    \n> 依赖注入框架可以创建线程安全的，带事务管理的SqlSession和mapper并且将它们注入到需要的Bean中，因此你可以直接忽略他的生命周期。如果要熟悉MyBatis和DI 框架的关系可以看一下MyBatis-Spring 和MyBatis-Guice两个项目\n\n##### SqlSessionFactoryBuilder\n这个类被初始化，使用完之后可以直接丢弃了。当你创建完SqlSessionFactory之后就没必要留着他了。因此SqlSessionFactoryBuilder最好的作用域是在方法作用域中（例如一个本地变量）。可以重用SqlSessionFactoryBuilder来创建多个SqlSessionFactory实例，但是最好还是不要保留它，保证所有的XML都被解析用来做更重要的事情。\n##### SqlSessionFactory\n当SqlSesslionFactory创建了之后，就应该一直存在你的应用中。一般来说是没有理由重新创建或处理他的。在程序运行的时候最好不要多次重新构建SqlSessionFactory。如果这样做就会有坏代码的味道了。因此SqlSessionFactory的作用域最好是应用作用域。实现的方法有很多，最好的方法就是使用单例模式或者是静态单例模式。\n##### SqlSession\n每个线程都应该有自己的SqlSession。SqlSession的示例不能分享且非线程安全。因此最好的作用域是请求作用域和方法作用域。永远不要在静态域或者类实例中引用SqlSession。永远不要将SqlSession放到managed 作用域中，例如Servlet框架的HttpSession。如果使用的是web框架，可以将其放到HTTP 请求的作用域中。换句话说就是，接收到HTTP请求的时候可以打开SqlSesslion连接，响应的时候关闭。关闭SqlSession非常的重要，永远记得将其放在finally块中来关闭他。下面这个例子就是确保在finally中关闭SqlSesslion\n```Java\nSqlSession session = sqlSessionFactory.openSession();\ntry {\n  // do work\n} finally {\n  session.close();\n}\n```\n使用这个模式可以保证你的代码关闭了数据库的连接。\n##### Mapper Instances\nMappers是你创建用来绑定映射语句的接口。每一个mapper实例都从SqlSession中获取。因此mapper的作用域和获取他们的SqlSession的作用域是一样的。然而mapper最好的租用与是方法作用域。他们应该在一个方法使用时创建，方法结束时丢弃。他们不需要显示的关闭。和SqlSession相同，将它们放到请求作用域中也是没问题的，但是在这个层次上处理如此多的资源会很棘手。所以就简单一点，把mapper实例放到方法作用域中，下面这个例子解释了如何使用他\n```Java\nSqlSession session = sqlSessionFactory.openSession();\ntry {\n  BlogMapper mapper = session.getMapper(BlogMapper.class);\n  // do work\n} finally {\n  session.close();\n}\n```\n","date":"2017-03-21"},{"title":"OKHttp Recipes","tags":["Java","Translate","OKHttp","HTTP","backend"],"iso8601Date":"2017-03-19T03:44:10+08:00","basename":"Recipes","body":"\n\n[原文地址](https://github.com/square/okhttp/wiki/Recipes)\n我们写了一些建议，来演示如何使用OKHttp来解决一些常见问题。\n\n#### 同步GET\n下载文件，打印header，打印body。\n`string()`方法对于小文档的响应来说是个既方便有高效的方法。但是如果一个文档太大（大于1M），就不要使用`string()`方法了，以为他会把整个文档加载到内存中,在这种情况下可以把body当作流来处理。  \n\n```Java\nprivate final OkHttpClient client = new OkHttpClient();\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://publicobject.com/helloworld.txt\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nHeaders responseHeaders = response.headers();\nfor (int i = 0; i < responseHeaders.size(); i++) {\nSystem.out.println(responseHeaders.name(i) + \": \" + responseHeaders.value(i));\n}\nSystem.out.println(response.body().string());\n    \n```\n\n #### 异步GET\n 在工作线程下载文件，响应可读后回调。在响应的header准备好的时候回调。响应体可能仍然阻塞。现在OKHttp没有提供获取响应体的异步API。\n\n```Java\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://publicobject.com/helloworld.txt\")\n    .build();\n\nclient.newCall(request).enqueue(new Callback() {\n    @Override public void onFailure(Call call, IOException e) {\n    e.printStackTrace();\n    }\n\n    @Override public void onResponse(Call call, Response response) throws IOException {\n    if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n    Headers responseHeaders = response.headers();\n    for (int i = 0, size = responseHeaders.size(); i < size; i++) {\n        System.out.println(responseHeaders.name(i) + \": \" + responseHeaders.value(i));\n    }\n\n    System.out.println(response.body().string());\n    }\n});\n}\n```\n\n #### 访问Header\n 总体上说Header有点像`Map<String,String>`，每一个字段都有或没有值。但是一些Header允许有多个值，就像Guava的`[Multimap](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Multimap.html)`。\n 例如HTTP提供多个Vary`的值是很常见并且合法的。OKHttp的API在这两种情况下都能轻松使用。\n 当写入请求header的时候使用`header(name,value)`设置仅有一个的`name`和`value`。如果有存在的值，会先移除值再添加。 使用`addHeader(name,value)`添加header不会移除已经存在的header。\n 当读响应header的时候，`header(name)`只返回最后一个值，通常也仅有一个。如果没有值，将会返回null。以一个list的方式获取所有的值可以使用`headers(name)`。\n 如果要访问所有的header，可以使用Headers类，支持坐标访问。\n\n```Java\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/repos/square/okhttp/issues\")\n    .header(\"User-Agent\", \"OkHttp Headers.java\")\n    .addHeader(\"Accept\", \"application/json; q=0.5\")\n    .addHeader(\"Accept\", \"application/vnd.github.v3+json\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(\"Server: \" + response.header(\"Server\"));\nSystem.out.println(\"Date: \" + response.header(\"Date\"));\nSystem.out.println(\"Vary: \" + response.headers(\"Vary\"));\n}\n```\n\n #### 使用POST发送String请求。\n 使用HTTP的POST给服务发送请求。这个例子发送了一个markdown文档到服务器用来将markdown渲染成HTML。因为整个请求是放在内存中的，所以使用此API的时候避免大文档（小于1M）。\n\n```Java\npublic static final MediaType MEDIA_TYPE_MARKDOWN\n    = MediaType.parse(\"text/x-markdown; charset=utf-8\");\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nString postBody = \"\"\n    + \"Releases\\n\"\n    + \"--------\\n\"\n    + \"\\n\"\n    + \" * _1.0_ May 6, 2013\\n\"\n    + \" * _1.1_ June 15, 2013\\n\"\n    + \" * _1.2_ August 11, 2013\\n\";\n\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/markdown/raw\")\n    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n\n #### 使用POST发送流\n 使用POST将请求体以流的方式发送。请求体在被写入的时候生成。这个例子直接使用了`[Okio](https://github.com/square/okio)`的缓冲库。可能你更熟悉`OutputStream`可以通过`BufferedSink.outputStream`获取。\n\n\n```Java\npublic static final MediaType MEDIA_TYPE_MARKDOWN\n    = MediaType.parse(\"text/x-markdown; charset=utf-8\");\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequestBody requestBody = new RequestBody() {\n    @Override public MediaType contentType() {\n    return MEDIA_TYPE_MARKDOWN;\n    }\n\n    @Override public void writeTo(BufferedSink sink) throws IOException {\n    sink.writeUtf8(\"Numbers\\n\");\n    sink.writeUtf8(\"-------\\n\");\n    for (int i = 2; i <= 997; i++) {\n        sink.writeUtf8(String.format(\" * %s = %s\\n\", i, factor(i)));\n    }\n    }\n\n    private String factor(int n) {\n    for (int i = 2; i < n; i++) {\n        int x = n / i;\n        if (x * i == n) return factor(x) + \" × \" + i;\n    }\n    return Integer.toString(n);\n    }\n};\n\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/markdown/raw\")\n    .post(requestBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n\n #### 使用POST发送一个文件\n 文件很容易当作一个请求体。\n\n```Java\npublic static final MediaType MEDIA_TYPE_MARKDOWN\n    = MediaType.parse(\"text/x-markdown; charset=utf-8\");\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nFile file = new File(\"README.md\");\n\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/markdown/raw\")\n    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n\n #### 发送form 参数\n 使用`FormBody.Builder`来创建一个同HTML 的`form`标签方式相同的请求踢。名字和值会被编码成HTML兼容的URL编码。\n\n```Java\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequestBody formBody = new FormBody.Builder()\n    .add(\"search\", \"Jurassic Park\")\n    .build();\nRequest request = new Request.Builder()\n    .url(\"https://en.wikipedia.org/w/index.php\")\n    .post(formBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n\n #### 发送multipart请求\n `MultipartBody.Builder`可以创建和HTML上传文件兼容的请求。每一个multipart请求体自身也是请求体，可以有自己的header。如果提供了，这些header仅描述自身的一部分，例如`Content-Dispositon`。`Content-Type`,`Content-Length`如果可用会自动添加。\n \n```Java\nprivate static final String IMGUR_CLIENT_ID = \"...\";\nprivate static final MediaType MEDIA_TYPE_PNG = MediaType.parse(\"image/png\");\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\n// Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image\nRequestBody requestBody = new MultipartBody.Builder()\n    .setType(MultipartBody.FORM)\n    .addFormDataPart(\"title\", \"Square Logo\")\n    .addFormDataPart(\"image\", \"logo-square.png\",\n        RequestBody.create(MEDIA_TYPE_PNG, new File(\"website/static/logo-square.png\")))\n    .build();\n\nRequest request = new Request.Builder()\n    .header(\"Authorization\", \"Client-ID \" + IMGUR_CLIENT_ID)\n    .url(\"https://api.imgur.com/3/image\")\n    .post(requestBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n #### 使用Gson解析响应JSON\n [Gson](http://code.google.com/p/google-gson/)是一个很顺手的转换Java对象和JSON的API。这里我们用它来解析GitHub响应的JSON。\n 注意，`ResponseBody.charStream()`使用`content-type`的响应header来选择解码响应流的字符集，如果没有提供默认使用UTF-8。\n\n```Java\nprivate final OkHttpClient client = new OkHttpClient();\nprivate final Gson gson = new Gson();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"https://api.github.com/gists/c2a7c39532239ff261be\")\n    .build();\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nGist gist = gson.fromJson(response.body().charStream(), Gist.class);\nfor (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {\n    System.out.println(entry.getKey());\n    System.out.println(entry.getValue().content);\n}\n}\n\nstatic class Gist {\nMap<String, GistFile> files;\n}\n\nstatic class GistFile {\nString content;\n}\n```\n\n #### 响应缓存\n 为了换成响应需要又一个可读写的缓存目录并且限制缓存的大小。缓存目录应该是私有的，并且非信任的应用无权访问。  \n 同时访问一个缓冲目录回出现错误。大多数应用应该调用一次`new OkHttpClient()`，配置它的缓存，在其他地方使用统一个实例。否则两个缓存实例会互相损害，损坏换成，可能是你的应用崩溃。\n 响应缓存使用HTTP的header来配置。如果请求头添加了`Cache-Control: max-stale=3600`,OKHttp将会使用这些配置。是服务器来配置响应可以被缓存多长时间，通过响应头来配置，例如`Cache-Control: max-age=9600`。有一些header可以强制换成响应，强制一个网络返回或者强制一个有条件的GET确定缓存是否有效。\n \n```Java\nprivate final OkHttpClient client;\n\npublic CacheResponse(File cacheDirectory) throws Exception {\nint cacheSize = 10 * 1024 * 1024; // 10 MiB\nCache cache = new Cache(cacheDirectory, cacheSize);\n\nclient = new OkHttpClient.Builder()\n    .cache(cache)\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://publicobject.com/helloworld.txt\")\n    .build();\n\nResponse response1 = client.newCall(request).execute();\nif (!response1.isSuccessful()) throw new IOException(\"Unexpected code \" + response1);\n\nString response1Body = response1.body().string();\nSystem.out.println(\"Response 1 response:          \" + response1);\nSystem.out.println(\"Response 1 cache response:    \" + response1.cacheResponse());\nSystem.out.println(\"Response 1 network response:  \" + response1.networkResponse());\n\nResponse response2 = client.newCall(request).execute();\nif (!response2.isSuccessful()) throw new IOException(\"Unexpected code \" + response2);\n\nString response2Body = response2.body().string();\nSystem.out.println(\"Response 2 response:          \" + response2);\nSystem.out.println(\"Response 2 cache response:    \" + response2.cacheResponse());\nSystem.out.println(\"Response 2 network response:  \" + response2.networkResponse());\n\nSystem.out.println(\"Response 2 equals Response 1? \" + response1Body.equals(response2Body));\n}\n```\n\n 为了阻止缓冲可以使用`[CacheControl.FORCE_NETWORK](CacheControl.FORCE_NETWORK)`.为了阻止网络连接可以使用`[CacheControl.FORCE_CACHE](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CacheControl.html#FORCE_CACHE)`。警告：如果使用了`FORCE_CACHE`并且响应需要网络，将会返回`504 Unsatisfiable Request`。\n #### 取消请求\n 使用`Call.cancel()`立即取消正在进行的请求。如果一个线程正在写一个请求或者读一个响应将会抛出IOException。当一个请求不在需要的时候使用这个函数来保护网络。例如当用户导航离开应用的时候。同步和异步的请求都可以取消。\n \n```Java\nprivate final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://httpbin.org/delay/2\") // This URL is served with a 2 second delay.\n    .build();\n\nfinal long startNanos = System.nanoTime();\nfinal Call call = client.newCall(request);\n\n// Schedule a job to cancel the call in 1 second.\nexecutor.schedule(new Runnable() {\n    @Override public void run() {\n    System.out.printf(\"%.2f Canceling call.%n\", (System.nanoTime() - startNanos) / 1e9f);\n    call.cancel();\n    System.out.printf(\"%.2f Canceled call.%n\", (System.nanoTime() - startNanos) / 1e9f);\n    }\n}, 1, TimeUnit.SECONDS);\n\ntry {\n    System.out.printf(\"%.2f Executing call.%n\", (System.nanoTime() - startNanos) / 1e9f);\n    Response response = call.execute();\n    System.out.printf(\"%.2f Call was expected to fail, but completed: %s%n\",\n        (System.nanoTime() - startNanos) / 1e9f, response);\n} catch (IOException e) {\n    System.out.printf(\"%.2f Call failed as expected: %s%n\",\n        (System.nanoTime() - startNanos) / 1e9f, e);\n}\n}\n```\n\n #### 超时\n 当端点不可达的时候使用超时使请求失败。网络分区可能是客户端连接问题，服务器可用性问题或者其他问题。OKHttp支持连接，读，写超时。\n \n```Java\nprivate final OkHttpClient client;\n\npublic ConfigureTimeouts() throws Exception {\nclient = new OkHttpClient.Builder()\n    .connectTimeout(10, TimeUnit.SECONDS)\n    .writeTimeout(10, TimeUnit.SECONDS)\n    .readTimeout(30, TimeUnit.SECONDS)\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://httpbin.org/delay/2\") // This URL is served with a 2 second delay.\n    .build();\n\nResponse response = client.newCall(request).execute();\nSystem.out.println(\"Response completed: \" + response);\n}\n ```\n\n #### 调用前配置\n 所有的HTTP调用配置都会在`OkHttpClient`中，包括，代理设置，超时和缓存。当需要修改某个调用的配置的时候，使用`OKHttpClient.newBuilder()`。这个函数会返回共享的连接池，调度器，并且跟原始client相同的配置。在下面这个例子中，一个请求的超时时间是500ms另一个是3000ms。\n\n ```Java\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://httpbin.org/delay/1\") // This URL is served with a 1 second delay.\n    .build();\n\ntry {\n    // Copy to customize OkHttp for this request.\n    OkHttpClient copy = client.newBuilder()\n        .readTimeout(500, TimeUnit.MILLISECONDS)\n        .build();\n\n    Response response = copy.newCall(request).execute();\n    System.out.println(\"Response 1 succeeded: \" + response);\n} catch (IOException e) {\n    System.out.println(\"Response 1 failed: \" + e);\n}\n\ntry {\n    // Copy to customize OkHttp for this request.\n    OkHttpClient copy = client.newBuilder()\n        .readTimeout(3000, TimeUnit.MILLISECONDS)\n        .build();\n\n    Response response = copy.newCall(request).execute();\n    System.out.println(\"Response 2 succeeded: \" + response);\n} catch (IOException e) {\n    System.out.println(\"Response 2 failed: \" + e);\n}\n}\n ```\n\n #### 处理认证\n OKHttp会自动重试认证请求。当响应是`401 Not Authorized`,`Authenticator`需要用来提供凭证。将会重新实现一个带有凭证的请求，如果没有凭证可用跳过重试，返回null。\n 使用` Response.challenges()`来获取任何认证口令的方案和域。当使用`Basic`认证的时候使用`Credentials.basic(username,password)`来编码一个header。\n \n```Java\nprivate final OkHttpClient client;\n\npublic Authenticate() {\nclient = new OkHttpClient.Builder()\n    .authenticator(new Authenticator() {\n        @Override public Request authenticate(Route route, Response response) throws IOException {\n        System.out.println(\"Authenticating for response: \" + response);\n        System.out.println(\"Challenges: \" + response.challenges());\n        String credential = Credentials.basic(\"jesse\", \"password1\");\n        return response.request().newBuilder()\n            .header(\"Authorization\", credential)\n            .build();\n        }\n    })\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(\"http://publicobject.com/secrets/hellosecret.txt\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\nSystem.out.println(response.body().string());\n}\n```\n","date":"2017-03-19"},{"title":"OKHttp的调用","tags":["Translate","Java","OKHttp","HTTP","backend"],"iso8601Date":"2017-03-18T23:10:03+08:00","basename":"calls","body":"\n\n[原文地址](https://github.com/square/okhttp/wiki/Calls)\n\nHTTP客户端的任务是接受请求和产生响应。理论很简单，但是实战的时候就有点棘手了。\n#### Requests\n每一个HTTP请求都包含一个URL，一个方法（例如，GET，POST）和一些headers。请求同时可以包含一个特定类型的数据流作为body。\n#### Responses\nResponse 通过一个一个状态码（例如，200 成功，404未找到），headers，和一个可选的Body来响应请求。\n##### 重写请求\n当使用OkHttp发送HTTP请求的时候，可以在高层次描述这个请求：通过这个URL和这些headers来获取响应。为了准确和更高的效率，OKHttp会在发送之前重现请求。\nOkHttp将会添加原请求没有的header，包括`Content-length`,`Transfer-Encoding`,`User-Agent`,`Host`,`Connection`，`Content-Type`。除非已经提供了，否则OKHttp回会添加 `Acceept-Encoding`来压缩响应。如果有Cookie，也会添加`Cookie`。\n有些请求会缓存响应。当被缓存的响应过期后，OKHttp会发送一个有条件的GET请求来获取新的响应，如果新现在的比缓存的响应更新，将会更新缓存过的响应。这要求`If-Modified-Since`和`If-None-Match`添加到headers中。\n##### 重写响应\n如果透明压缩启用了，OKHttp将会把`Content-Encoding`和`Content-Length`从headers中移除，因为他们不是用来解压缩的。\n如果条件GET请求成功，从网上下载的响应和缓存的响应根据Spec合并。\n##### 后续请求\n当请求的URL被转移了，web server 将会返回一个302的状态码来表示这个文档的新URL，OKHttp将会重定向到新的URL获取最终的响应。\n如果响应需要认证，OKHttp将会使用`Authenticator`（如果提供了一个）来认证。如果认证器提供了凭证，请求回使用凭证重试。\n##### 重试请求\n有时连接失败，例如：连接池过期断开链接，或者无法连接服务器。OKHttp会通过不同的可用路由来重试请求。\n#### calls\n通过重写，重定向，继续请求和重试，一个简单的请求可能会产生很多请求和响应。OKHttp使用`call`建立一个不管多少中间请求和响应的任务模型。总的来说这不多。但是了解代码将会继续工作，不管是URL重定向或者是转移故障其他IP。\ncall有两种工作方\n   * 同步：线程将会阻塞道到响应可读。\n   * 异步：将请求加入到其他线程的队列，当响应可读诗时，会在其他的线程获取回调。\n请求调用可以在任何线程取消。如果调用未完成，这个请求将会失败。当调用取消时，在先请求踢体或者读响应体的代码将会跑出IOException的异常。\n##### 调度\n对于同步调用，将会由自身线程控制多少并发请求。太多并发连接浪费资源，太少又回有高延迟。\n对于异步来说，Dispatcher实现了最大并发的策略。可以设置没个服务器的最大并发（默认是5）和总体的并发（默认64）。\n","date":"2017-03-18"},{"title":"OKHttp connections","tags":["OKHttp","Translate","Java","HTTP","backend"],"iso8601Date":"2017-03-19T03:05:48+08:00","basename":"connections","body":"\n\n[原文地址](https://github.com/square/okhttp/wiki/Connections)\n虽然只提供了URL，但是OKHttp会使用URL，Address，Route三种方式来连接服务器。\n\n#### URLS\nURLs例如（https://github.com/square/okhttp) 是HTTP和Internet的基础。除了是一个表示互联网一切的命名方案，也指定了如何访问Web资源。\nURLs是抽象的：\n  * 它指出，调用可以是纯文本（http）或者加密（https），但是并没有指定一种加密算法。也没有指定如何验证各个端点的证书([HostnameVerifier](http://developer.android.com/reference/javax/net/ssl/HostnameVerifier.html))，或者是哪个证书可信([SSLSocketFactory](http://developer.android.com/reference/org/apache/http/conn/ssl/SSLSocketFactory.html))\n  * 它为指定是否需要使用代理服务器以及代理服务器如何授权。\n 它也是具体的，每个URL标识一个具体的路径（/square/okhttp)和查询（?q=sharks&lang=en)。每个服务器有很多URL。\n\n #### Addresses\n Address指定了一个服务器（例如：github.com），以及连接服务器必要的所有的静态配置，包括：端口号，HTTPS设置，优先协议（例如，HTTP／2，SPDY）。\n URL使用了相同的Address，底层也可能实用了相同的TCP链接。复用连接可以提高性能：低延迟，高吞吐（[TCP 慢启动](http://www.igvita.com/2011/10/20/faster-web-vs-tcp-slow-start/))，低电量。OKHttp使用[ConnectionPool](http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionPool.html)自动复用HTTP／1.x连接，多路复用HTT／2和SPDY的连接。\n 在OKHttp，address的一些字段来源于URL（协议，主机名，端口），剩下的来自[OKHttpClient](http://square.github.io/okhttp/3.x/okhttp/okhttp3/OkHttpClient.html)。\n #### Routes\n Route提供了连接服务器必要的动态信息。包括，具体的IP地址（通过DNS查询），具体使用那个代理（[ProxySelector](http://developer.android.com/reference/java/net/ProxySelector.html)），协n哪个TLS版本（HTTPS).\n 一个服务器可能有多条路有信息。例如：多台服务器部署在多个数据中心，DNS查询返回多个IP地址。\n #### Connections\n 当发起一个URL的请求的时候：\n   1. 使用URL和OKHttpCLient确定具体的**Address**。这个地址明确如何连接服务器。\n   2. 尝试从**连接池**中查找具体Address的连接。\n   3. 如果未找到有效的连接，使用Route来尝试获取。一般这样意味着通过DNS或去IP地址。然后，如果需要，选择一个TLS的版本和代理服务器。\n   4. 如果是一个新的Route，要么使用Socket直连，TLS隧道（HTTS方式），或者直接使用TLS。也会进行必要的TLS握手。\n   5. 发送请求，接受响应。\n 如果连接发生错误，OKHttp会选择另一个路由重试。这样OKHttp就可以在服务器端一些地址无法访问的时候恢复访问。同时如果连接池的连接失效或者常识的TLS 版本不支持也很有用。\n 当响应接收到了之后，连接会放回到连接池以便之后使用。连接在一段时间过期后回被移除连接池。\n\n","date":"2017-03-19"},{"title":"OKHttp https","tags":["Translate","Java","OKHttp","HTTP","backend"],"iso8601Date":"2017-03-23T21:32:29+08:00","basename":"https","body":"\n\n[原文链接](https://github.com/square/okhttp/wiki/HTTPS)\n\nOKHttp尝试平衡两个相互矛盾的内容：\n * 连接尽可能多的主机。包括使用[boringssl](https://boringssl.googlesource.com/boringssl/)的高级的主机和一些使用[openssl](https://www.openssl.org/)的过时的主机。\n * 连接的安全性。包括验证远程主机的证书，通过强密码进行数据交换。\n\n协商连接到HTTPS的时候，OKHttp需要知道需要提供的[TLS版本](http://square.github.io/okhttp/3.x/okhttp/okhttp3/TlsVersion.html)和[密码套件](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CipherSuite.html)。如果一个客户端需要最大化链接就需要包含过时的TLS版本和弱设计的密码组合。一个严格的客户端想要最大化安全就需要只包含最新的TLS版本和强密码套件。\n安全和连接规范具体是由[ConnectionSpec](http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionSpec.html)实现的。OKHttp包含三个内置的规范：\n * `MODERN_TLS` 是连接现代HTTPS服务器的配置。\n * `COMPATIBLE_TLS` 是连接非现代，但安全的HTTPS服务器的配置。\n * `CLEARTEXT` 是非安全的http的配置。\n\n默认OKHttp会尝试使用`MODERN_TLS`连接，如果现代配置失败，回到使用`COMPATIBLE_TLS`配置。\nTLS版本和密码套件在任一一个发布版本的人一个规范中都可能改变。例如，在OKHttp2.2，因为[POODLE](http://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html)攻击就移除了SSL 3.0的支持。在OKHttp 3.0，移除了[RC4](http://en.wikipedia.org/wiki/RC4#Security)的支持。同桌面浏览器一样，使用罪行的OKHttp版本可以获得最好的安全保障。\n也可以根据一组定制的TLS 版本和密码套件构建自己的规范。例如，下面这个配置要求使用三组高强度的密码套件。它的缺点就是必须是Android5.0+或者是最新的浏览器。\n```Java\nConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)  \n    .tlsVersions(TlsVersion.TLS_1_2)\n    .cipherSuites(\n          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n          CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256)\n    .build();\n\nOkHttpClient client = new OkHttpClient.Builder() \n    .connectionSpecs(Collections.singletonList(spec))\n    .build();\n```\n#### 证书锁定\n默认情况下OKHttp信任主机平台的证书颁发机构。这个策略可以最大化连接，但是也有可能收到权威证书攻击，例如[2011 DigiNotar attack](http://www.computerworld.com/article/2510951/cybercrime-hacking/hackers-spied-on-300-000-iranians-using-fake-google-certificate.html)。同样也假设你的证书是权威机构颁发的。\n使用[CertificatePinner](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CertificatePinner.html)限制了哪些证书和证书颁发机构值得信任。使用证书锁定可以提高安全性，但是限制了服务端团队升级他们的TLS证书。**在没的到服务端团队的许可的时候不要使用证书锁定**。\n```Java\n  public CertificatePinning() {\n    client = new OkHttpClient.Builder()\n        .certificatePinner(new CertificatePinner.Builder()\n            .add(\"publicobject.com\", \"sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=\")\n            .build())\n        .build();\n  }\n\n  public void run() throws Exception {\n    Request request = new Request.Builder()\n        .url(\"https://publicobject.com/robots.txt\")\n        .build();\n\n    Response response = client.newCall(request).execute();\n    if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response);\n\n    for (Certificate certificate : response.handshake().peerCertificates()) {\n      System.out.println(CertificatePinner.pin(certificate));\n    }\n  }\n```\n#### 定制信任证书\n下面所有的代码展示了如何使用你自己的配置代替服务端的证书配置。正如上述所言，**在没的到服务端团队的许可的时候不要使用定制证书*。\n```Java\n  private final OkHttpClient client;\n\n  public CustomTrust() {\n    SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());\n    client = new OkHttpClient.Builder()\n        .sslSocketFactory(sslContext.getSocketFactory())\n        .build();\n  }\n\n  public void run() throws Exception {\n    Request request = new Request.Builder()\n        .url(\"https://publicobject.com/helloworld.txt\")\n        .build();\n\n    Response response = client.newCall(request).execute();\n    System.out.println(response.body().string());\n  }\n\n  private InputStream trustedCertificatesInputStream() {\n    ... // Full source omitted. See sample.\n  }\n\n  public SSLContext sslContextForTrustedCertificates(InputStream in) {\n    ... // Full source omitted. See sample.\n  }\n```\n","date":"2017-03-23"},{"title":"OKHttp 拦截器","tags":["Translate","Java","OKHttp","HTTP","backend"],"iso8601Date":"2017-03-19T23:47:42+08:00","basename":"interceptors","body":"\n\n[原文地址](https://github.com/square/okhttp/wiki/Interceptors)\n拦截器是一种监控，重写，重试请求的强大机制。下面这个例子是一个记录出发出请求和接受响应的简单的拦截器的例子。\n```Java\nclass LoggingInterceptor implements Interceptor {\n  @Override public Response intercept(Interceptor.Chain chain) throws IOException {\n    Request request = chain.request();\n\n    long t1 = System.nanoTime();\n    logger.info(String.format(\"Sending request %s on %s%n%s\",\n        request.url(), chain.connection(), request.headers()));\n\n    Response response = chain.proceed(request);\n\n    long t2 = System.nanoTime();\n    logger.info(String.format(\"Received response for %s in %.1fms%n%s\",\n        response.request().url(), (t2 - t1) / 1e6d, response.headers()));\n\n    return response;\n  }\n}\n```\n调用`chain.proceed(request)`是每个拦截器最重要的实现。这个看起来简单的方法是所有HTTP工作的地方，也是对请求响应的地方。\n拦截器可以链式调用。假设你有一个压缩的拦截器和一个校验和的拦截器：你要先确定是先压缩再校验，还是先校验再压缩。OKHTTP使用列表跟踪拦截器，而且拦截器是顺序取消的。\n![Interceptors](https://raw.githubusercontent.com/wiki/square/okhttp/interceptors@2x.png)\n#### 应用拦截器\n拦截器注册为应用拦截器或者网络拦截器。我们将使用上面定义的`LoggingInterceptor`来展示这两者的不同。\n通过调用`OkHttpClient.Builder`的`addInterceptor()`来注册一个应用拦截器。\n```Java\nOkHttpClient client = new OkHttpClient.Builder()\n    .addInterceptor(new LoggingInterceptor())\n    .build();\n\nRequest request = new Request.Builder()\n    .url(\"http://www.publicobject.com/helloworld.txt\")\n    .header(\"User-Agent\", \"OkHttp Example\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nresponse.body().close();\n```\n链接`http://www.publicobject.com/helloworld.txt`重定向到链接`http://www.publicobject.com/helloworld.txt`,OKHttp回自动重定向。应用拦截器只会被调用一次。`chain.proceed()`返回的响应是重定向之后的响应。\n```bash\nINFO: Sending request http://www.publicobject.com/helloworld.txt on null\nUser-Agent: OkHttp Example\n\nINFO: Received response for https://publicobject.com/helloworld.txt in 1179.7ms\nServer: nginx/1.4.6 (Ubuntu)\nContent-Type: text/plain\nContent-Length: 1759\nConnection: keep-alive\n```\n因为`response.request().url()`和`request.url()`获取的URL不同，所以可以得出上述结论。两行日志记录了两个不同的URL。\n#### 网络拦截器\n注册网络拦截器和应用拦截器差不多，只是用`addNetworkInterceptor()`代替了`addInterceptor()`。\n```Java\nOkHttpClient client = new OkHttpClient.Builder()\n    .addNetworkInterceptor(new LoggingInterceptor())\n    .build();\n\nRequest request = new Request.Builder()\n    .url(\"http://www.publicobject.com/helloworld.txt\")\n    .header(\"User-Agent\", \"OkHttp Example\")\n    .build();\n\nResponse response = client.newCall(request).execute();\nresponse.body().close();\n```\n当运行这段代码的时候拦截器运行了两次，一次初始的地址`http://www.publicobject.com/helloworld.txt`，一次是重定向的地址`https://publicobject.com/helloworld.txt`。\n```bash\nINFO: Sending request http://www.publicobject.com/helloworld.txt on Connection{www.publicobject.com:80, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=none protocol=http/1.1}\nUser-Agent: OkHttp Example\nHost: www.publicobject.com\nConnection: Keep-Alive\nAccept-Encoding: gzip\n\nINFO: Received response for http://www.publicobject.com/helloworld.txt in 115.6ms\nServer: nginx/1.4.6 (Ubuntu)\nContent-Type: text/html\nContent-Length: 193\nConnection: keep-alive\nLocation: https://publicobject.com/helloworld.txt\n\nINFO: Sending request https://publicobject.com/helloworld.txt on Connection{publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA protocol=http/1.1}\nUser-Agent: OkHttp Example\nHost: publicobject.com\nConnection: Keep-Alive\nAccept-Encoding: gzip\n\nINFO: Received response for https://publicobject.com/helloworld.txt in 80.9ms\nServer: nginx/1.4.6 (Ubuntu)\nContent-Type: text/plain\nContent-Length: 1759\nConnection: keep-alive\n```\n网络请求同时也包含了更多的数据，例如:由OKHttp添加的用来支持响应压缩的`Accept-Encoding: gzip`header。网络拦截器的`chain`有一个非空的`Connection`，用来查询连接服务器的IP地址和TLS配置信息。\n#### 如何选择拦截器\n每种拦截器都有优点。\n##### 应用拦截器\n * 无需关心像重试，重定向等这样的中间过程。\n * 即使是从缓存响应，也会调用一次。\n * 只关心应用最初的目的，并不需要关心OKHttp注入的header，例如`If-None-Match`\n * 允许短路，不执行`Chain.proceed()`\n * 允许重试，执行多次`Chain.proceed()`\n##### 网络拦截器\n * 可以操作想重试，重定向这样的中间过程。\n * 短路网络连接的从cache返回响应的时候不执行。\n * 可以监控呗发送到网络上的数据\n * 访问包含request的`Connection`\n#### 重写请求\n拦截器可以添加，删除，替换请求头。如果请求有请求体，拦截器也可以转换请求体。例如：如果远程连接的服务器支持压缩，可以使用应用拦截器添加压缩请求体的拦截器。\n```Java\n/** This interceptor compresses the HTTP request body. Many webservers can't handle this! */\nfinal class GzipRequestInterceptor implements Interceptor {\n  @Override public Response intercept(Interceptor.Chain chain) throws IOException {\n    Request originalRequest = chain.request();\n    if (originalRequest.body() == null || originalRequest.header(\"Content-Encoding\") != null) {\n      return chain.proceed(originalRequest);\n    }\n\n    Request compressedRequest = originalRequest.newBuilder()\n        .header(\"Content-Encoding\", \"gzip\")\n        .method(originalRequest.method(), gzip(originalRequest.body()))\n        .build();\n    return chain.proceed(compressedRequest);\n  }\n\n  private RequestBody gzip(final RequestBody body) {\n    return new RequestBody() {\n      @Override public MediaType contentType() {\n        return body.contentType();\n      }\n\n      @Override public long contentLength() {\n        return -1; // We don't know the compressed length in advance!\n      }\n\n      @Override public void writeTo(BufferedSink sink) throws IOException {\n        BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));\n        body.writeTo(gzipSink);\n        gzipSink.close();\n      }\n    };\n  }\n}\n```\n#### 重写响应\n同样拦截器也可以重写响应，转化请求体。通常这样做比重写请求头更危险，因为这样做可能返回的并不是服务器预期值。\n如果你处在一个比较棘手的场景，并且准备处理后果，重写响应头就是一个很好的方式处理这类问题。例如：可以修复服务器未配置的`Cache-Control`来获取更好的缓存响应配置。\n```Java\n/** Dangerous interceptor that rewrites the server's cache-control header. */\nprivate static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() {\n  @Override public Response intercept(Interceptor.Chain chain) throws IOException {\n    Response originalResponse = chain.proceed(chain.request());\n    return originalResponse.newBuilder()\n        .header(\"Cache-Control\", \"max-age=60\")\n        .build();\n  }\n};\n```\n通常为了补充服务器相应的修复，这个方法是最好的。\n#### 那些可以使用拦截器\n使用拦截器要求OKHttp 2.0即以上。不行的是拦截器不可以和`OkUrlFactory`，或者依赖于他的库同时使用，包括[Retrofit](http://square.github.io/retrofit/)1.8以下，[Picasso](http://square.github.io/picasso/)2.4以下。\n","date":"2017-03-19"}]}}