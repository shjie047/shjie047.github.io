{"path":"tags/web","templateID":4,"sharedPropsHashes":{"tags":"Zpc8p0"},"localProps":{"posts":[{"title":"Go Web 架构","cover":"https://p6jqy6mfr.bkt.clouddn.com/stock-photo-251622641.jpg","iso8601Date":"2015-11-11T03:01:21+08:00","basename":"Go-Web-architecture","tags":["Go","Architecture","Translate","Backend","Web"],"date":"2015-11-11","cate":"Backend","summary":"原文地址\n\n使用Golang来创建Web项目是一件很麻烦的事情。如果你使用Rails，那么你可能不会有这个感触。我在Refer Madness中使用了下面这个架构。\n\nbash\n-public/\n-views/\n-models/\n-utils/\n-controllers/\n-web/\n-main.go\n\n\n我将打破这个体系，介绍各个目录的作用。在每个目录下，文件只能访问其同级或者上一级。这就意味着utils只能访问他自己和models，web只能访问它自己，controllers，utils，models。models只能访问它自己。我这么做是为了让层次清晰，防止出现递归依赖。现在来分析每一个目录，文件的作用。\n\nmain.go\n\nmain.go是创建依赖，获取环境变量，启动服务的主要文件。下面是它的实例。\n\n`Go\npackage main\n\nimport (\n  &quot;github.com/larryprice/refermadness/utils&quot;\n  &quot;github.com/larryprice/refermadness/web&quot;\n  &quot;github.com/stretchr/graceful&quot;\n  &quot;os&quot;\n)\n\nfunc main() {\n  isDevelopment := os.Getenv(&quot;ENVIRONMENT&quot;) == &quot;development&quot;\n  dbURL := os.Getenv(&quot;MONGOLABURI&quot;)\n  if isDevelopment {\n    dbURL = os.Getenv(&quot;DBPORT27017TCP_ADDR&quot;)\n  }\n\n  dbAccessor := utils.NewDatabaseAccessor(dbURL, os.Getenv(&quot;DATABASE_NAME&quot;), 0)\n  cuAccessor := utils.NewCurrentUserAccessor(1)\n  s := web.NewServer(dbAccessor, cuAccessor, os.Getenv(&quot;GOOGLEOAUTH2CLIENTID&quot;),\n    os.Getenv(&quot;GOOGLEOAUTH2CLIENTSECRET&quot;), os.Getenv(&quot;SESSIONSECRET&quot;),\n    isDevelopment, os.Getenv(&quot;GOOGLEANALYTICS_KEY&quot;))\n\n  port := os.Getenv(&quot;PORT&quot;)\n  if port == &quot;&quot; {\n    port = &quot;3000&quot;\n  }\n\n  graceful.Run(&quot;:&quot;+port, 0, s)\n}\n\n`\n\n因为main.go实在最低的层级，所以它可以访问所有的目录：在这个例子里是web和utils。在这里获取了所有的环境变量并把它们注入到合适的地方。在main.go中创建了服务器，注入依赖，并且在配置的端口启动服务器。\n\nweb\n\nweb目录下是主要的服务代码，同时也包括了中间件代码。下面是web目录的内部结构：\n\nbash\n-web/\n|-middleware/\n|-server.go\n\n\nserver.go包含了web server的定义。这个web server 创建了所有的web controller并且给negroni添加了中间件。下面是他的例子：\n\n`Go\npackage web\n\nimport (\n  &quot;github.com/codegangsta/negroni&quot;\n  &quot;github.com/goincremental/negroni-sessions&quot;\n  &quot;github.com/goincremental/negroni-sessions/cookiestore&quot;\n  &quot;github.com/gorilla/mux&quot;\n  &quot;github.com/larryprice/refermadness/controllers&quot;\n  &quot;github.com/larryprice/refermadness/utils&quot;\n  &quot;github.com/larryprice/refermadness/web/middleware&quot;\n  &quot;github.com/unrolled/secure&quot;\n  &quot;gopkg.in/unrolled/render.v1&quot;\n  &quot;html/template&quot;\n  &quot;net/http&quot;\n)\n\ntype Server struct {\n  *negroni.Negroni\n}\n\nfunc NewServer(dba utils.DatabaseAccessor, cua utils.CurrentUserAccessor, clientID, clientSecret,\n  sessionSecret string, isDevelopment bool, gaKey string) *Server {\n  s := Server{negroni.Classic()}\n  session := utils.NewSessionManager()\n  basePage := utils.NewBasePageCreator(cua, gaKey)\n  renderer := render.New()\n\n  router := mux.NewRouter()\n\n  // ...\n\n  accountController := controllers.NewAccountController(clientID, clientSecret, isDevelopment, session, dba, cua, basePage, renderer)\n  accountController.Register(router)\n\n  // ...\n\n  s.Use(sessions.Sessions(&quot;refermadness&quot;, cookiestore.New([]byte(sessionSecret))))\n  s.Use(middleware.NewAuthenticator(dba, session, cua).Middleware())\n  s.UseHandler(router)\n  return &amp;s\n}\n`\n\nServer结构体是一个negroni.Negroni的web server，在这个文件里有对utils和其他第三方包的引用，创建了一个router，一些controller，并且将controller注册到当前router。同时也引入了必要的中间件。说到中间件，下面是它的代码：\n\n`Go\npackage middleware\n\nimport (\n  &quot;github.com/codegangsta/negroni&quot;\n  &quot;github.com/larryprice/refermadness/utils&quot;\n  &quot;net/http&quot;\n)\n\ntype Database struct {\n  da utils.DatabaseAccessor\n}\n\nfunc NewDatabase(da utils.DatabaseAccessor) *Database {\n  return &amp;Database{da}\n}\n\nfunc (d Database) Middleware() negroni.HandlerFunc {\n  return func(rw http.ResponseWriter, r http.Request, next http.HandlerFunc) {\n    reqSession := d.da.Clone()\n    defer reqSession.Close()\n    d.da.Set(r, reqSession)\n    next(rw, r)\n  }\n}\n`\n\n这个是通过HTTP router访问数据库session的标注中间件。基本文件是从Brian Gesiak’s blog post on RESTful Go中得到，将其修改为适合我的文件。\n\ncontrollers/\n\n这里的controller与Rails里的controller的概念很像。Controller注册自己的router，设置自己的函数调用。一个简短的例子如下：\n\n`Go\npackage controllers\n\nimport (\n  &quot;encoding/json&quot;\n  &quot;errors&quot;\n  &quot;github.com/gorilla/mux&quot;\n  &quot;github.com/larryprice/refermadness/models&quot;\n  &quot;github.com/larryprice/refermadness/utils&quot;\n  &quot;gopkg.in/mgo.v2/bson&quot;\n  &quot;gopkg.in/unrolled/render.v1&quot;\n  &quot;html/template&quot;\n  &quot;net/http&quot;\n  &quot;strings&quot;\n)\n\ntype ServiceControllerImpl struct {\n  currentUser utils.CurrentUserAccessor\n  basePage    utils.BasePageCreator\n  renderer    *render.Render\n  database    utils.DatabaseAccessor\n}\n\nfunc NewServiceController(currentUser utils.CurrentUserAccessor, basePage utils.BasePageCreator,\n  renderer render.Render, database utils.DatabaseAccessor) ServiceControllerImpl {\n  return &amp;ServiceControllerImpl{\n    currentUser: currentUser,\n    basePage:    basePage,\n    renderer:    renderer,\n    database:    database,\n  }\n}\n\nfunc (sc ServiceControllerImpl) Register(router mux.Router) {\n  router.HandleFunc(&quot;/service/{id}&quot;, sc.single)\n  // ...\n}\n\n// ...\n\ntype serviceResult struct {\n  models.Service\n  RandomCode models.ReferralCode\n  UserCode   *models.ReferralCode\n}\n\ntype servicePage struct {\n  utils.BasePage\n  ResultString string\n}\n\nfunc (sc ServiceControllerImpl) single(w http.ResponseWriter, r http.Request) {\n  data, err := sc.get(w, r)\n\n  if len(r.Header[&quot;Content-Type&quot;]) == 1 &amp;&amp; strings.Contains(r.Header[&quot;Content-Type&quot;][0], &quot;application/json&quot;) {\n    if err != nil {\n      sc.renderer.JSON(w, http.StatusBadRequest, map[string]string{\n        &quot;error&quot;: err.Error(),\n      })\n      return\n    }\n    sc.renderer.JSON(w, http.StatusOK, data)\n    return\n  } else if err != nil {\n    http.Error(w, err.Error(), http.StatusBadRequest)\n  }\n\n  resultString,  := json.Marshal(data)\n  t,  := template.ParseFiles(&quot;views/layout.html&quot;, &quot;views/service.html&quot;)\n  t.Execute(w, servicePage{sc.basePage.Get(r), string(resultString)})\n}\n`\n\nutils/\n\n在utils目录下的文件提供了一些底层功能用来支持其他的代码。在这个例子中，主要是定义一个结构体来访问请求的上下文，处理session，定义一个特别的页面来继承。下面是通过访问上下文设置用户的例子：\n\n`Go\npackage utils\n\nimport (\n  &quot;github.com/gorilla/context&quot;\n  &quot;github.com/larryprice/refermadness/models&quot;\n  &quot;net/http&quot;\n)\n\ntype CurrentUserAccessor struct {\n  key int\n}\n\nfunc NewCurrentUserAccessor(key int) *CurrentUserAccessor {\n  return &amp;CurrentUserAccessor{key}\n}\n\nfunc (cua CurrentUserAccessor) Set(r http.Request, user *models.User) {\n  context.Set(r, cua.key, user)\n}\n\nfunc (cua CurrentUserAccessor) Clear(r http.Request) {\n  context.Delete(r, cua.key)\n}\n\nfunc (cua CurrentUserAccessor) Get(r http.Request) models.User {\n  if rv := context.Get(r, cua.key); rv != nil {\n    return rv.(models.User)\n  }\n  return nil\n}\n`\n\nmodels/\n\nmodel 是为了描述数据库中的数据的数据结构。在这个例子中使用model来访问数据库，创建一个空的model，然后通过查询数据库为其赋值。下面是一个例子：\n\n`Go\npackage models\n\nimport (\n  &quot;gopkg.in/mgo.v2&quot;\n  &quot;gopkg.in/mgo.v2/bson&quot;\n  &quot;strings&quot;\n  &quot;time&quot;\n)\n\ntype Service struct {\n  // identification information\n  ID          bson.ObjectId bson:&quot;_id&quot;\n  Name        string        bson:&quot;name&quot;\n  Description string        bson:&quot;description&quot;\n  URL         string        bson:&quot;url&quot;\n  Search      string        bson:&quot;search&quot;\n}\n\nfunc NewService(name, description, url string, creatorID bson.ObjectId) *Service {\n  url = strings.TrimPrefix(strings.TrimPrefix(url, &quot;http://&quot;), &quot;https://&quot;)\n  return &amp;Service{\n    ID:            bson.NewObjectId(),\n    Name:          name,\n    URL:           url,\n    Description:   description,\n    Search:        strings.ToLower(name) + &quot;;&quot; + strings.ToLower(description) + &quot;;&quot; + strings.ToLower(url),\n  }\n}\n\nfunc (s Service) Save(db mgo.Database) error {\n  _, err := s.coll(db).UpsertId(s.ID, s)\n  return err\n}\n\nfunc (s Service) FindByID(id bson.ObjectId, db mgo.Database) error {\n  return s.coll(db).FindId(id).One(s)\n}\n\nfunc (Service) coll(db mgo.Database) *mgo.Collection {\n  return db.C(&quot;service&quot;)\n}\n\ntype Services []Service\n\nfunc (s Services) FindByIDs(ids []bson.ObjectId, db mgo.Database) error {\n  return s.coll(db).Find(bson.M{&quot;_id&quot;: bson.M{&quot;$in&quot;: ids}}).Sort(&quot;name&quot;).All(s)\n}\n\nfunc (Services) coll(db mgo.Database) *mgo.Collection {\n  return db.C(&quot;service&quot;)\n}\n\n`\n\nviews/\n\n将Golang的模板文件放到views目录下。这样，不管用什么样的模板引擎都可以直接放到views下。\n\npublic/\n\n跟以前一样，这个文件都是放公开的文件的，例如css,img,scripts。\n\n如何运行\n\n毫无疑问，我最喜欢的就是docker，因此我将使用他来运行这个应用。如果不使用docker，那么可以将文件放到$GOPATH/src/github.com/larryprice/refermadness,运行go get来获取所有的依赖，然后运行 go run main.go或者go build; ./refermadness运行程序。如果你也喜欢使用docker，那么可以直接通过Dockerfile来运行。\n\n`bash\nFROM golang:1.4\n\nRUN go get github.com/codegangsta/gin\n\nADD . /go/src/github.com/larryprice/refermadness\nWORKDIR /go/src/github.com/larryprice/refermadness\nRUN go get\n`\n\n同时我也很喜欢compose，所以我也通过compose 文件来运行所有的应用。我用了JSC ，SASS和mongodb，所以一下是我的docker-compose.yml文件。\n\nGo\nmain:\n  build: .\n  command: gin run\n  env_file: .env\n  volumes:\n    - ./:/go/src/github.com/larryprice/refermadness\n  working_dir: /go/src/github.com/larryprice/refermadness\n  ports:\n    - &quot;3000:3000&quot;\n  links:\n    - db\nsass:\n  image: larryprice/sass\n  volumes:\n    - ./public/css:/src\njsx:\n  image: larryprice/jsx\n  volumes:\n    - ./public/scripts:/src\ndb:\n  image: mongo:3.0\n  command: mongod --smallfiles --quiet --logpath=/dev/null\n  volumes_from:\n    - dbvolume\ndbvolume:\n  image: busybox:ubuntu-14.04\n  volumes:\n    - /data/db\n\n\n然后运行docker-compose up来运行所有的容器并启动服务器。","readingtime":19,"url":"/cates/Backend/post/2015-11-11/Go-Web-architecture","dirs":["go"],"relatives":[{"url":"/cates/Backend/post/2015-11-12/HTTP-2-And-GO","title":"HTTP/2 和GO"},{"url":"/cates/Backend/post/2015-11-15/create-a-homepage-for-Go-Web-App","title":"为Go Web App 创建一个主页面"},{"url":"/cates/Backend/post/2015-11-12/develop-HTTP-middleware-using-Go","title":"使用Go开发HTTP中间件"},{"url":"/cates/Backend/post/2015-11-13/http-Handler-And-Go-error-handle","title":"http.Handler 与Go的错误处理"}]},{"title":"深入理解Spring MVC","cover":"https://p6jqy6mfr.bkt.clouddn.com/stock-photo-249089429.jpg","iso8601Date":"2018-04-07T08:39:10+08:00","basename":"deep-in-spring-mvc","tags":["Backend","Java","Spring","SpringMVC","Web"],"date":"2018-04-07","cate":"Backend","summary":"原文地址  \n\n初始工程\n\n这篇文章中将使用最新的Spring Framework 5框架。主要关注的是Spring的经典Web技术栈，这套技术从最开始的Spring版本就开始支持，并且知道现在仍然是构建Spring Web应用的主要方式。使用Spring Boot和其他starter来设置初始工程。xml配置如下：\n`xml\n&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n    &lt;version&gt;2.0.1&lt;/version&gt;\n    &lt;relativePath/&gt;\n&lt;/parent&gt;\n\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n`\n\n测试项目\n\n为了理解Spring Web MVC是如何工作的，可以先实现一个简单的Login功能的。创建一个由@Controller来修饰的类InternalController，这个类包含一个Get的映射。hello()函数没有参数。返回一个由Spring解释的视图名字的字符串。（在本例中是login.html）  \n\n`Java\nimport org.springframework.web.bind.annotation.GetMapping;\n\n@GetMapping(&quot;/&quot;)\npublic String hello() {\n    return &quot;login&quot;;\n}\n`\n\n为了处理用户登陆逻辑，创建另一个接受POST请求的带有Login数据的方法。然后根据处理结果返回成功或者失败页面。\n注意，login()函数接受一个领域对象作为参数，返回的是ModelAndView对象。  \n\nJava\n@PostMapping(&quot;/login&quot;)\npublic ModelAndView login(LoginData loginData) {\n    if (LOGIN.equals(loginData.getLogin()) \n      &amp;&amp; PASSWORD.equals(loginData.getPassword())) {\n        return new ModelAndView(&quot;success&quot;, \n          Collections.singletonMap(&quot;login&quot;, loginData.getLogin()));\n    } else {\n        return new ModelAndView(&quot;failure&quot;, \n          Collections.singletonMap(&quot;login&quot;, loginData.getLogin()));\n    }\n}\n\n\nModelAndView保存了两个不同的对象：\n  - Model： 用来渲染页面用的键值对的map\n  - View： 填充Model数据的模版页面。  \n\n将它们合并起来是为了方便，这样controller的方法就可以同时返回这两个了。\n使用Thymeleaf作为模版引擎来渲染页面。  \n\nJava Web应用的基础-Servlet\n\n当你在浏览器里键入http://localhost:8080/ ，然后按回车键，请求到达服务器的时候到底发生了什么？是如何在浏览器中看到这个web请求的数据的？\n因为这个项目是一个简单的Spring Boot应用，所以可以通过Spring5Application来运行。\nSpring Boot默认使用Apache Tomcat运行程序，运行成功后可能会看到如下的日志：\n\n`bash\n2017-10-16 20:36:11.626  INFO 57414 --- [main] \n  o.s.b.w.embedded.tomcat.TomcatWebServer  : \n  Tomcat initialized with port(s): 8080 (http)\n\n2017-10-16 20:36:11.634  INFO 57414 --- [main] \n  o.apache.catalina.core.StandardService   : \n  Starting service [Tomcat]\n\n2017-10-16 20:36:11.635  INFO 57414 --- [main] \n  org.apache.catalina.core.StandardEngine  : \n  Starting Servlet Engine: Apache Tomcat/8.5.23\n`\n\n因为Tomcat是一个Servlet容器，所以几乎所有的HTTP请求都是由Java Servlet处理的。自然的Spring Web的入口就是一个Servlet。\nServlet是所有Java Web应用的核心组件；它非常的低成，并且没有暴露任何具体的编程模式，例如MVC。\n一个HTTP的Servelt只能接受HTTP请求，处理请求后返回响应。\n现在使用Servlet 3.0的API，可以不再使用XML配置，直接可以使用Java配置。\n\nSpring MVC的核心-DispatcherServlet\n\n作为Web开发者，我们希望抽象出以下枯燥和样板的任务，而关注于有用的业务逻辑  - 将HTTP请求映射到响应处理函数\n  - 将HTTP请求数据和header解析成数据传输对象（DTOs）或者领域对象\n  - model-view-controller 互相交互\n  - 从DTO，领域对象等生成响应  \n\nSpring的DispatcherServlet提供了以上的功能，是Spring WEB MVC框架的核心，是应用接受所有请求的核心组件。\n稍后就会了解到DispatcherServlet可扩展性非常强。例如：它允许你加入现有或者新的适配器来适应不同的任务：\n  - 将请求映射到处理它的类或者函数(由HandlerMapping实现）\n  - 使用特定模式来处理请求，例如一个普通的Servlet，一个复杂的MVC 工作流，或者只是一个方法。(由HandlerAdapter实现）\n  - 通过名字解析试图对象，允许你使用不同的模版引擎，例如：XML，XSLT或者其他视图技术(由ViewResolver实现）\n  - 默认使用Apache Comons 的文件上传组件解析文件上传，或者也可以自己实现。\n  - 由LocalResolver实现本地化，包括cookie，session，HTTP的Accept Header，或者其他由用户定义的本地化。    \n\n处理HTTP请求\n\n首先让我们重新审视一下在刚刚建立的应用中是如何处理HTTP请求的。\nDispatcherServlet有一个很长的继承层级。自顶向下理解每个单独的概念是非常有必要的。处理请求的函数将会更加有趣。\n\n理解HTTP请求在本地开发模式处理和远程处理是理解MVC架构非常重要的一步。\n\nGenericServlet\n\nGenericServlet时Servlet规范中的一部分，不直接处理HTTP。它定义了service()方法，来接受请求和返回响应。\n注意，ServletRequest和ServletResponse并不是绑定到HTTP协议的。\nJava\npublic abstract void service(ServletRequest req, ServletResponse res) \n  throws ServletException, IOException;\n\n服务器所有的请求，包括简单的GET请求都会调用这个方法。\n\nHttpServlet\n\n正如其名，HttpServelt是Servlet 规范中关于HTTP请求的实现。\n更确切的说，HttpServlet是一个实现了service()的抽象类。通过将不同的HTTP请求类型分开，由不同的函数处理，实现大约如下所示：\n`Java\nprotected void service(HttpServletRequest req, HttpServletResponse resp)\n    throws ServletException, IOException {\n\nString method = req.getMethod();\nif (method.equals(METHOD_GET)) {\n    // ...\n    doGet(req, resp);\n} else if (method.equals(METHOD_HEAD)) {\n    // ...\n    doHead(req, resp);\n} else if (method.equals(METHOD_POST)) {\n    doPost(req, resp);\n    // ...\n}\n\n`\n\nHttpServletBean\n\n在这个继承关系中HttpServletBean是第一个Spring的类。从web.xml或者WebApplicationInitialzer获取的初始参数来注入bean。\n在应用中的请求分别调用doGet,doPost等方法来处理不同的HTTP请求。\n\nFrameworkServlet\n\nFrameworkServlet实现了ApplicationContextAware,集成Web的Application Context。不过它也可以创建自己的Application Context。\n正如上述所言，父类HttpServletBean通过将初始参数作为bean的属性注入。因此如果contex的类名在contextClass这个初始参数中，那么就有这个参数创建application context的实例，否则默认使用XmlWebApplicationContext。\n由于XML配置现在已经过时了。Spring Boot默认使用AnnotationConfigWebApplicationContext来配置DispatcherServlet。不过这个是很容易修改的。\n例如，想要在Spring MVC中使用Groovy的application context，可以将下列配置在web.xml中\nbash\n  dispatcherServlet\n        org.springframework.web.servlet.DispatcherServlet\n        contextClass\n        org.springframework.web.context.support.GroovyWebApplicationContext\n\n相同的配置也可以在WebApplicationInitializer中配置。\n\nDispatcherServlet: 统一处理请求\n\nHttpServlet.service() 通过HTTP的动词类型来处理路由不同的请求到不同的方法，这个在底层的servlet实现的很好。但是，在SpringMVC的抽象层次中，不能仅靠方法类型来路由请求。\n同样的，FrameworkServlet的另一个主要功能就是将不同的处理使用processRequest()组合在一起。\n`Java\n@Override\nprotected final void doGet(HttpServletRequest request, \n  HttpServletResponse response) throws ServletException, IOException {\n    processRequest(request, response);\n}\n\n@Override\nprotected final void doPost(HttpServletRequest request, \n  HttpServletResponse response) throws ServletException, IOException {\n    processRequest(request, response);\n}\n`\n\nDispatcherServlet: 丰富请求\n\n最后,DispatcherServlet实现doService() 方法。它向请求中加入了一些有用的对象，继续在web 的管道中传递下去，例如：web application context, locale resolver, theme resolver, theme source等\nJava\nrequest.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, \n  getWebApplicationContext());\nrequest.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\nrequest.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\nrequest.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());\n\n同时，doService()加入了输入输出的Flash Map，Flash Map是将参数从一个请求传递到另一个请求的基本模式。在重定向中很有用。(例如在重定向之后向用户展示一段简单的信息）\nJava\nFlashMap inputFlashMap = this.flashMapManager\n  .retrieveAndUpdate(request, response);\nif (inputFlashMap != null) {\n    request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, \n      Collections.unmodifiableMap(inputFlashMap));\n}\nrequest.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());\n\n接着doService() 将会调用doDispatch()方法来分发请求。\n\nDispatcherServlet: 分发请求\n\ndispatch() 的主要目的就是知道一个合适的处理请求的处理器并且传递request/response参数。处理器可以是任何对象，并不局限于一个特定的接口。同样也意味着Spring需要找到如何使用这个处理器的适配器。\n为了给请求找到合适的处理器，Spring会遍历实现HandlerMapping接口的注册的实现。有很多不同的实现可以满足我们各种需求。\nSimpleUrlHandlerMapping使用URL将请求映射到处理bean中。例如：它可以通过Java.util.Properties 注入它的映射信息：\nbash\n/welcome.html=ticketController\n/show.html=ticketController\n\nRequestMappingHandlerMapping可能是最广泛使用的映射处理器。它将请求映射到@Controller类下的@RequestMapping修饰的方法上。这个就是上面那个例子中的hello()和login()。\n注意，上面两个方法分别是@GetMapping和@PostMapping修饰的。这两个注解来源于@RequestMapping。\ndispatch() 同时也可以处理一些其他的HTTP的任务：\n  - 如果资源不存在，对GET请求进行短路处理。\n  - 对相应的请求使用multipart 解析。\n  - 如果处理器选择异步处理请求，对请求进行短路处理。  \n\n处理请求\n\n现在Spring确定了处理请求的处理器和处理器的适配器，是时候处理请求了。下面是HandlerAdapter.handle() 的签名。比较重要的一点是处理器可以选择如何处理请求：\n  - 直接将相应写入到response body 和 返回null\n  - 返回一个ModelAndView对象由DispatcherServlet渲染。  \n\nJava\n@Nullable\nModelAndView handle(HttpServletRequest request, \n                    HttpServletResponse response, \n                    Object handler) throws Exception;\n\nSpring提供了很多类型的处理器，下面是SimpleControllerHandlerAdapter如何处理Spring MVC的controller实例的(不要和@Controller搞混)。\n注意，controller处理器返回ModelAndView对象并不是由起渲染的。\nJava\npublic ModelAndView handle(HttpServletRequest request, \n  HttpServletResponse response, Object handler) throws Exception {\n    return ((Controller) handler).handleRequest(request, response);\n}\n\n第二个是SimpleServletHandlerAdapter它对一个普通的servlet适配。\nservlet并不知道ModelAndView，完全自己处理请求，将返回写入到相应的body中。因此它的适配器就直接返回null。\nJava\npublic ModelAndView handle(HttpServletRequest request, \n  HttpServletResponse response, Object handler) throws Exception {\n    ((Servlet) handler).service(request, response);\n    return null;\n}\n\n在本例中，controller是由@RequestMapping修饰的POJO，因此处理器会使用HandlerMethod来封装它的方法。Spring使用RequestMappingHandlerAdapter来适配这种处理器类型。\n\n处理参数，返回处理器函数的值\n\n注意，一般来说controller并不会接收HttpServletRequest和HttpServletResponse作为参数，但是它可以接收和返回很多中其他类型，例如：领域对象，路径参数等。\n同样，也不强求一个controller返回一个ModelAndView实例。可以选择返回一个视图名称，ResponseEntity，或者是一个可以被转换成JSON的POJO。\nRequestMappingHandlerAdapter可以保证从HttpServletRequest中解析方法需要的参数，同时创建ModelAndView对象返回。\n下面这段代码就是RequestMappingHandlerAdapter中保证这件事情的：\nJava\nServletInvocableHandlerMethod invocableMethod \n  = createInvocableHandlerMethod(handlerMethod);\nif (this.argumentResolvers != null) {\n    invocableMethod.setHandlerMethodArgumentResolvers(\n      this.argumentResolvers);\n}\nif (this.returnValueHandlers != null) {\n    invocableMethod.setHandlerMethodReturnValueHandlers(\n      this.returnValueHandlers);\n}\n\nargumentResolvers在HandlerMethodArgumentResolver实例中有不同实现。一共有30多种不同的参数解析器的实现。他们可以从请求参数将函数需要的参数解析出来。包括：url路径变量，请求体参数，请求头，cookies，session等。\nreturnValueHandlers在HandlerMethodArgumentResolver实例中有不同实现。同样也有很多不同的返回值处理器来处理方法返回的结果，创建ModelAndView对象。\n例如：当函数hello()返回一个string的时候，ViewNameMethodReturnValueHandler处理这个值。login()返回一个ModelAndView对象的时候，Sring使用ModelAndViewMethodReturnValueHandler处理这个值。\n\n渲染视图\n\n现在Spring已经处理了HTTP请求，获取了ModelAndView实例，现在它需要在用户浏览器渲染HTML页面了。它依赖于由Model和选择的模版组成的ModelAndView对象。\n同样的，Spring也可以渲染JSON ,XML或者其他HTTP协议接受的类型。这些将在接下来的REST相关了解更多。\n现在回去看一下DispatcherServlet。 render() 首先使用LocaleResolver实例设置返回的Local。首先假设浏览器已经正确设置Accetp头。默认使用AcceptHeaderLocaleResolver来处理。\n在渲染过程中，ModelAndView可以包含一个视图的名字或者是已经选择的视图，或者如果controller依赖于默认视图也可以没有。\n既然hello()和login()方法制定了字符串名字作为视图名称，所以需要使用viewResolvers来查找视图。\nJava\nfor (ViewResolver viewResolver : this.viewResolvers) {\n    View view = viewResolver.resolveViewName(viewName, locale);\n    if (view != null) {\n        return view;\n    }\n}\n\nViewResolver的实现由很多，这里使用了由thymeleaf-spring5提供的ThymeleafViewResolver实现。解析器知道去哪里查找视图，并且提供相应的视图实例。\n调用完render()之后，Spring就完成了将HTML页面渲染到用户浏览器的任务。\n\nREST 支持\n\n除了MVC的场景，我们可以使用狂减创建rest web service。\n一个简单的场景，可以使用由@RequestBody修饰的POJO作为参数。由@ResponseBody修饰方法，指定方法的返回结果直接写入到响应体中。  \n\n`Java\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@ResponseBody\n@PostMapping(&quot;/message&quot;)\npublic MyOutputResource sendMessage(\n  @RequestBody MyInputResource inputResource) {\n\nreturn new MyOutputResource(&quot;Received: &quot;\n  + inputResource.getRequestMessage());\n\n}\n`\n\n感谢SpringMVC的扩展性，这样做也是可以的。\n框架使用HttpMessageConverter将内部DTO转换成REST的表示。例如：MappingJackson2HttpMessageConverter的可以使用Jackson库将转换model和JSON。\n为了简化创建REST API，Srping 引入了@RestController注解。默认使用@ResonseBody这样就不需要在每个方法中使用了。\n`Java\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class RestfulWebServiceController {\n\n@GetMapping(&quot;/message&quot;)\npublic MyOutputResource getMessage() {\n    return new MyOutputResource(&quot;Hello!&quot;);\n}\n\n}\n`\n\n结论\n\n在这篇文章中，详细描述了Spring MVC处理HTTP请求的各个步骤。了解到Spring 框架是如何将各个组件组合在一起提供处理HTTP协议的。","readingtime":17,"url":"/cates/Backend/post/2018-04-07/deep-in-spring-mvc","dirs":["spring-mvc"],"relatives":[{"url":"/cates/Backend/post/2018-04-10/spring-mvc-controller","title":"SpringMVC 教程 - Controller"},{"url":"/cates/Backend/post/2018-04-09/spring-mvc-dispatcher-servlet","title":"SpringMVC 教程 - DispatcherServlet"},{"url":"/cates/Backend/post/2018-04-09/spring-mvc-filter","title":"SpringMVC 教程 - Filter"}]},{"author":"shjie047","title":"1kb的JS框架 - Hyperapp","cover":"https://p6jqy6mfr.bkt.clouddn.com/stock-photo-249278113.jpg","iso8601Date":"2018-04-08T08:00:00+08:00","basename":"hyperapp","tags":["前端","JS","Javascript","Frontend","Hyperapp","React","Web"],"date":"2018-04-08","cate":"Frontend","summary":"1. 概览\n\nHyperapp是最近开源的一个前端web开发框架，体积很小 -- 只有1.4kb，api很简单 -- 只有两个函数: h和app；借鉴了React、Redux和Elm的思想,\n\n它的主要要特点是：\n\n最小化 -- 用最少的代码实现了同类框架(React、Vue等)的核心功能重实效 -- 坚持函数式编程来管理状态(state)，同时提供有效的方法来处理边际效应(side effects)比如：异步action和DOM操作独立性 -- 自身集成状态管理和虚拟DOM引擎(虚拟DOM支持key更新 &amp;&amp; 生命周期事件)，没有第三方依赖\n\n下面用Hyperapp实现一个Counter的demo，实现了简单的加和减:\n\n`Javascript\n// 两个API\nimport { h, app } from &quot;hyperapp&quot;\n\n// 状态\nconst state = {\n  count: 0\n}\n\n// 用action来更新state\nconst actions = {\n  down: value =&gt; state =&gt; ({ count: state.count - value }),\n  up: value =&gt; state =&gt; ({ count: state.count + value })\n}\n\n// 用jsx来编写视图\nconst view = (state, actions) =&gt; (\n  &lt;div&gt;\n    &lt;h1&gt;{state.count}&lt;/h1&gt;\n    &lt;button onclick={() =&gt; actions.down(1)}&gt;-&lt;/button&gt;\n    &lt;button onclick={() =&gt; actions.up(1)}&gt;+&lt;/button&gt;\n  &lt;/div&gt;\n)\n\n// 把state，actions，view连接起来并渲染到页面的body元素上\napp(state, actions, view, document.body)\n`\n\n2. API\n\nHyperapp由两个函数API组成：h和app。\n\nh返回一个新的虚拟DOM节点树，app把一个新的app渲染到指定DOM元素上。\n\n以上的示例需要本地环境安装：编译器 -- Babel或者TypeScript，打包工具 -- Parcel或者Webpack，使用JSX来编写模板需要在.babelrc安装transform plugin来支持:\n\nJSON\n{\n  &quot;plugins&quot;: [[&quot;transform-react-jsx&quot;, { &quot;pragma&quot;: &quot;h&quot; }]]\n}\n\n\n2.1 JSX\n\nJSX是JS的语言扩展，可以写出和HTML类似的标签式组件，浏览器本身不支持JSX，需要配合编译器把JSX编译为hyperapp.h可以调用的代码。\n\n但是JSX并不是Hyperapp所必需的，可以直接使用hyperapp.h的api来直接编写组件，省去编译JSX的步骤：\n\n`Javascript\n\n// 直接用 h 来编写\nconst view = (state, actions) =&gt;\n  h(&quot;div&quot;, {}, [\n    h(&quot;h1&quot;, {}, state.count),\n    h(&quot;button&quot;, { onclick: () =&gt; actions.down(1) }, &quot;-&quot;),\n    h(&quot;button&quot;, { onclick: () =&gt; actions.up(1) }, &quot;+&quot;)\n  ])\n`\n\n3. 架构\n\nHyperapp编写的应用由三部分构成：state、action和view\n\n在程序初始化完成后，整个app会处于一个持续的循环执行里。通过用户或者外部事件产生的action来更新state，用virtual dom来展示view层的改动。可以把action当作一个通知Hyperapp更新状态重绘view的信号，当action处理完后，用户会看到新的状态(state)。\n\n3.1 State\n\nState是一个扁平对象，存储app的所有动态数据，用来描述app的状态。State在程序创建后不能直接修改，只能通过Action来更新。\n\nJavascript\nconst state = {\n  count: 0\n}\n\nState可以允许嵌套：\n\nJavascript\nconst state = {\n  top: {\n    count: 0\n  },\n  bottom: {\n    count: 0\n  }\n}\n\n\n3.2 Actions\n\n改变State的唯一方式是通过Action。Action是一个一元函数：接收一个参数，参数可以是任何类型；action通过返回部分state来更新当前state，新的state是action返回的部分state和当前state的组合。\n\nJavascript\nconst actions = {\n  setValue: value =&gt; ({ value })\n}\n\n\nAction还可以返回一个函数，函数接收当前state和action为参数，返回部分state:\n\nJavascript\nconst actions = {\n  setValue: value =&gt; (state, actions) =&gt; ({value: state.count - count})\n}\n\n\n3.2.1 异步Action\n\nAction用于处理边际效应（比如：写数据到数据库、发送一个请求到服务器，等等）并不是每次都需要返回一个值。你可以在一个action里或者回调函数里调用另外一个action。当Action返回Promise、undefined或者null时，不会触发视图重绘或状态更新。\n\nJavascript\nconst actions = {\n  upLater: value =&gt; (state, actions) =&gt; {\n    setTimeout(actions.up, 1000, value)\n  },\n  up: value =&gt; state =&gt; ({ count: state.count + value })\n}\n\n\nAction可以是一个async异步函数。因为async函数返回一个Promise而不是部分state，这时候需要调用另外一个action来更新state。\n\nJavascript\nconst actions = {\n  upLater: () =&gt; async (state, actions) =&gt; {\n    await new Promise(done =&gt; setTimeout(done, 1000))\n    actions.up(10)\n  },\n  up: value =&gt; state =&gt; ({ count: state.count + value })\n}\n\n\n3.2.2 嵌套的Action\n\nAction可以在命名空间里嵌套。更新深度嵌套的state就像在同样路径下声明一个action来更新部分state一样简单。\n\n`Javascript\nconst state = {\n  counter: {\n    count: 0\n  }\n}\n\nconst actions = {\n  counter: {\n    down: value =&gt; state =&gt; ({ count: state.count - value }),\n    up: value =&gt; state =&gt; ({ count: state.count + value })\n  }\n}\n`\n\n3.2.3 操作性\n\napp函数返回一个包含action的对象，可以用来更新state。暴露这个对象到外部可以方便的和其他程序或框架交互、订阅全局事件、监听鼠标或键盘输入，等等。\n\n`Javascript\nconst main = app(state, actions, view, document.body)\n\nsetInterval(main.up, 250, 1)\nsetInterval(main.down, 500, 1)\n`\n\n4. View\n\n当state改变时，view函数被执行；view函数返回一个js对象，被称作virtual dom，Hyperapp根据virtual dom来更新实际的DOM节点。\n\n`Javascript\nimport { h } from &quot;hyperapp&quot;\n\nexport const view = (state, actions) =&gt;\n  h(&quot;div&quot;, {}, [\n    h(&quot;h1&quot;, {}, state.count),\n    h(&quot;button&quot;, { onclick: () =&gt; actions.down(1) }, &quot;-&quot;),\n    h(&quot;button&quot;, { onclick: () =&gt; actions.up(1) }, &quot;+&quot;)\n  ])\n`\n\n4.1 Virtual DOM\n\nVirtual DOM使用一个树结构的js对象来描述真实DOM节点，具体形式如下：\n\nJavascript\n{\n  nodeName: &quot;div&quot;,\n  attributes: {},\n  children: [\n    {\n      nodeName: &quot;h1&quot;,\n      attributes: {},\n      children: [0]\n    },\n    {\n      nodeName: &quot;button&quot;,\n      attributes: { ... },\n      children: [&quot;-&quot;]\n    },\n    {\n      nodeName:   &quot;button&quot;,\n      attributes: { ... },\n      children: [&quot;+&quot;]\n    }\n  ]\n}\n\n\n以上便是Hyperapp的概要，在项目使用中，由于hyperapp代码短小精炼，更易于调试和扩展，推荐感兴趣的同学试用。","readingtime":11,"url":"/cates/Frontend/post/2018-04-08/hyperapp","dirs":["js"],"relatives":[{"url":"/cates/Frontend/post/2018-04-03/Here_are_examples_of_everything_new_in_ECMAScript_2016_2017_and_2018","title":"ES2016, 2017和2018到底有哪些新东西？"},{"url":"/cates/Frontend/post/2018-03-10/JavaScript_Modules_Worth_Using","title":"那些值得一用的JS库"}]}],"tag":"web"}}