{"path":"tags/architecture","templateID":4,"sharedPropsHashes":{"tags":"Zpc8p0"},"localProps":{"posts":[{"title":"Go Web 架构","cover":"https://p6jqy6mfr.bkt.clouddn.com/stock-photo-251622641.jpg","iso8601Date":"2015-11-11T03:01:21+08:00","basename":"Go-Web-architecture","tags":["Go","Architecture","Translate","Backend","Web"],"date":"2015-11-11","cate":"Backend","summary":"原文地址\n\n使用Golang来创建Web项目是一件很麻烦的事情。如果你使用Rails，那么你可能不会有这个感触。我在Refer Madness中使用了下面这个架构。\n\nbash\n-public/\n-views/\n-models/\n-utils/\n-controllers/\n-web/\n-main.go\n\n\n我将打破这个体系，介绍各个目录的作用。在每个目录下，文件只能访问其同级或者上一级。这就意味着utils只能访问他自己和models，web只能访问它自己，controllers，utils，models。models只能访问它自己。我这么做是为了让层次清晰，防止出现递归依赖。现在来分析每一个目录，文件的作用。\n\nmain.go\n\nmain.go是创建依赖，获取环境变量，启动服务的主要文件。下面是它的实例。\n\n`Go\npackage main\n\nimport (\n  &quot;github.com/larryprice/refermadness/utils&quot;\n  &quot;github.com/larryprice/refermadness/web&quot;\n  &quot;github.com/stretchr/graceful&quot;\n  &quot;os&quot;\n)\n\nfunc main() {\n  isDevelopment := os.Getenv(&quot;ENVIRONMENT&quot;) == &quot;development&quot;\n  dbURL := os.Getenv(&quot;MONGOLABURI&quot;)\n  if isDevelopment {\n    dbURL = os.Getenv(&quot;DBPORT27017TCP_ADDR&quot;)\n  }\n\n  dbAccessor := utils.NewDatabaseAccessor(dbURL, os.Getenv(&quot;DATABASE_NAME&quot;), 0)\n  cuAccessor := utils.NewCurrentUserAccessor(1)\n  s := web.NewServer(dbAccessor, cuAccessor, os.Getenv(&quot;GOOGLEOAUTH2CLIENTID&quot;),\n    os.Getenv(&quot;GOOGLEOAUTH2CLIENTSECRET&quot;), os.Getenv(&quot;SESSIONSECRET&quot;),\n    isDevelopment, os.Getenv(&quot;GOOGLEANALYTICS_KEY&quot;))\n\n  port := os.Getenv(&quot;PORT&quot;)\n  if port == &quot;&quot; {\n    port = &quot;3000&quot;\n  }\n\n  graceful.Run(&quot;:&quot;+port, 0, s)\n}\n\n`\n\n因为main.go实在最低的层级，所以它可以访问所有的目录：在这个例子里是web和utils。在这里获取了所有的环境变量并把它们注入到合适的地方。在main.go中创建了服务器，注入依赖，并且在配置的端口启动服务器。\n\nweb\n\nweb目录下是主要的服务代码，同时也包括了中间件代码。下面是web目录的内部结构：\n\nbash\n-web/\n|-middleware/\n|-server.go\n\n\nserver.go包含了web server的定义。这个web server 创建了所有的web controller并且给negroni添加了中间件。下面是他的例子：\n\n`Go\npackage web\n\nimport (\n  &quot;github.com/codegangsta/negroni&quot;\n  &quot;github.com/goincremental/negroni-sessions&quot;\n  &quot;github.com/goincremental/negroni-sessions/cookiestore&quot;\n  &quot;github.com/gorilla/mux&quot;\n  &quot;github.com/larryprice/refermadness/controllers&quot;\n  &quot;github.com/larryprice/refermadness/utils&quot;\n  &quot;github.com/larryprice/refermadness/web/middleware&quot;\n  &quot;github.com/unrolled/secure&quot;\n  &quot;gopkg.in/unrolled/render.v1&quot;\n  &quot;html/template&quot;\n  &quot;net/http&quot;\n)\n\ntype Server struct {\n  *negroni.Negroni\n}\n\nfunc NewServer(dba utils.DatabaseAccessor, cua utils.CurrentUserAccessor, clientID, clientSecret,\n  sessionSecret string, isDevelopment bool, gaKey string) *Server {\n  s := Server{negroni.Classic()}\n  session := utils.NewSessionManager()\n  basePage := utils.NewBasePageCreator(cua, gaKey)\n  renderer := render.New()\n\n  router := mux.NewRouter()\n\n  // ...\n\n  accountController := controllers.NewAccountController(clientID, clientSecret, isDevelopment, session, dba, cua, basePage, renderer)\n  accountController.Register(router)\n\n  // ...\n\n  s.Use(sessions.Sessions(&quot;refermadness&quot;, cookiestore.New([]byte(sessionSecret))))\n  s.Use(middleware.NewAuthenticator(dba, session, cua).Middleware())\n  s.UseHandler(router)\n  return &amp;s\n}\n`\n\nServer结构体是一个negroni.Negroni的web server，在这个文件里有对utils和其他第三方包的引用，创建了一个router，一些controller，并且将controller注册到当前router。同时也引入了必要的中间件。说到中间件，下面是它的代码：\n\n`Go\npackage middleware\n\nimport (\n  &quot;github.com/codegangsta/negroni&quot;\n  &quot;github.com/larryprice/refermadness/utils&quot;\n  &quot;net/http&quot;\n)\n\ntype Database struct {\n  da utils.DatabaseAccessor\n}\n\nfunc NewDatabase(da utils.DatabaseAccessor) *Database {\n  return &amp;Database{da}\n}\n\nfunc (d Database) Middleware() negroni.HandlerFunc {\n  return func(rw http.ResponseWriter, r http.Request, next http.HandlerFunc) {\n    reqSession := d.da.Clone()\n    defer reqSession.Close()\n    d.da.Set(r, reqSession)\n    next(rw, r)\n  }\n}\n`\n\n这个是通过HTTP router访问数据库session的标注中间件。基本文件是从Brian Gesiak’s blog post on RESTful Go中得到，将其修改为适合我的文件。\n\ncontrollers/\n\n这里的controller与Rails里的controller的概念很像。Controller注册自己的router，设置自己的函数调用。一个简短的例子如下：\n\n`Go\npackage controllers\n\nimport (\n  &quot;encoding/json&quot;\n  &quot;errors&quot;\n  &quot;github.com/gorilla/mux&quot;\n  &quot;github.com/larryprice/refermadness/models&quot;\n  &quot;github.com/larryprice/refermadness/utils&quot;\n  &quot;gopkg.in/mgo.v2/bson&quot;\n  &quot;gopkg.in/unrolled/render.v1&quot;\n  &quot;html/template&quot;\n  &quot;net/http&quot;\n  &quot;strings&quot;\n)\n\ntype ServiceControllerImpl struct {\n  currentUser utils.CurrentUserAccessor\n  basePage    utils.BasePageCreator\n  renderer    *render.Render\n  database    utils.DatabaseAccessor\n}\n\nfunc NewServiceController(currentUser utils.CurrentUserAccessor, basePage utils.BasePageCreator,\n  renderer render.Render, database utils.DatabaseAccessor) ServiceControllerImpl {\n  return &amp;ServiceControllerImpl{\n    currentUser: currentUser,\n    basePage:    basePage,\n    renderer:    renderer,\n    database:    database,\n  }\n}\n\nfunc (sc ServiceControllerImpl) Register(router mux.Router) {\n  router.HandleFunc(&quot;/service/{id}&quot;, sc.single)\n  // ...\n}\n\n// ...\n\ntype serviceResult struct {\n  models.Service\n  RandomCode models.ReferralCode\n  UserCode   *models.ReferralCode\n}\n\ntype servicePage struct {\n  utils.BasePage\n  ResultString string\n}\n\nfunc (sc ServiceControllerImpl) single(w http.ResponseWriter, r http.Request) {\n  data, err := sc.get(w, r)\n\n  if len(r.Header[&quot;Content-Type&quot;]) == 1 &amp;&amp; strings.Contains(r.Header[&quot;Content-Type&quot;][0], &quot;application/json&quot;) {\n    if err != nil {\n      sc.renderer.JSON(w, http.StatusBadRequest, map[string]string{\n        &quot;error&quot;: err.Error(),\n      })\n      return\n    }\n    sc.renderer.JSON(w, http.StatusOK, data)\n    return\n  } else if err != nil {\n    http.Error(w, err.Error(), http.StatusBadRequest)\n  }\n\n  resultString,  := json.Marshal(data)\n  t,  := template.ParseFiles(&quot;views/layout.html&quot;, &quot;views/service.html&quot;)\n  t.Execute(w, servicePage{sc.basePage.Get(r), string(resultString)})\n}\n`\n\nutils/\n\n在utils目录下的文件提供了一些底层功能用来支持其他的代码。在这个例子中，主要是定义一个结构体来访问请求的上下文，处理session，定义一个特别的页面来继承。下面是通过访问上下文设置用户的例子：\n\n`Go\npackage utils\n\nimport (\n  &quot;github.com/gorilla/context&quot;\n  &quot;github.com/larryprice/refermadness/models&quot;\n  &quot;net/http&quot;\n)\n\ntype CurrentUserAccessor struct {\n  key int\n}\n\nfunc NewCurrentUserAccessor(key int) *CurrentUserAccessor {\n  return &amp;CurrentUserAccessor{key}\n}\n\nfunc (cua CurrentUserAccessor) Set(r http.Request, user *models.User) {\n  context.Set(r, cua.key, user)\n}\n\nfunc (cua CurrentUserAccessor) Clear(r http.Request) {\n  context.Delete(r, cua.key)\n}\n\nfunc (cua CurrentUserAccessor) Get(r http.Request) models.User {\n  if rv := context.Get(r, cua.key); rv != nil {\n    return rv.(models.User)\n  }\n  return nil\n}\n`\n\nmodels/\n\nmodel 是为了描述数据库中的数据的数据结构。在这个例子中使用model来访问数据库，创建一个空的model，然后通过查询数据库为其赋值。下面是一个例子：\n\n`Go\npackage models\n\nimport (\n  &quot;gopkg.in/mgo.v2&quot;\n  &quot;gopkg.in/mgo.v2/bson&quot;\n  &quot;strings&quot;\n  &quot;time&quot;\n)\n\ntype Service struct {\n  // identification information\n  ID          bson.ObjectId bson:&quot;_id&quot;\n  Name        string        bson:&quot;name&quot;\n  Description string        bson:&quot;description&quot;\n  URL         string        bson:&quot;url&quot;\n  Search      string        bson:&quot;search&quot;\n}\n\nfunc NewService(name, description, url string, creatorID bson.ObjectId) *Service {\n  url = strings.TrimPrefix(strings.TrimPrefix(url, &quot;http://&quot;), &quot;https://&quot;)\n  return &amp;Service{\n    ID:            bson.NewObjectId(),\n    Name:          name,\n    URL:           url,\n    Description:   description,\n    Search:        strings.ToLower(name) + &quot;;&quot; + strings.ToLower(description) + &quot;;&quot; + strings.ToLower(url),\n  }\n}\n\nfunc (s Service) Save(db mgo.Database) error {\n  _, err := s.coll(db).UpsertId(s.ID, s)\n  return err\n}\n\nfunc (s Service) FindByID(id bson.ObjectId, db mgo.Database) error {\n  return s.coll(db).FindId(id).One(s)\n}\n\nfunc (Service) coll(db mgo.Database) *mgo.Collection {\n  return db.C(&quot;service&quot;)\n}\n\ntype Services []Service\n\nfunc (s Services) FindByIDs(ids []bson.ObjectId, db mgo.Database) error {\n  return s.coll(db).Find(bson.M{&quot;_id&quot;: bson.M{&quot;$in&quot;: ids}}).Sort(&quot;name&quot;).All(s)\n}\n\nfunc (Services) coll(db mgo.Database) *mgo.Collection {\n  return db.C(&quot;service&quot;)\n}\n\n`\n\nviews/\n\n将Golang的模板文件放到views目录下。这样，不管用什么样的模板引擎都可以直接放到views下。\n\npublic/\n\n跟以前一样，这个文件都是放公开的文件的，例如css,img,scripts。\n\n如何运行\n\n毫无疑问，我最喜欢的就是docker，因此我将使用他来运行这个应用。如果不使用docker，那么可以将文件放到$GOPATH/src/github.com/larryprice/refermadness,运行go get来获取所有的依赖，然后运行 go run main.go或者go build; ./refermadness运行程序。如果你也喜欢使用docker，那么可以直接通过Dockerfile来运行。\n\n`bash\nFROM golang:1.4\n\nRUN go get github.com/codegangsta/gin\n\nADD . /go/src/github.com/larryprice/refermadness\nWORKDIR /go/src/github.com/larryprice/refermadness\nRUN go get\n`\n\n同时我也很喜欢compose，所以我也通过compose 文件来运行所有的应用。我用了JSC ，SASS和mongodb，所以一下是我的docker-compose.yml文件。\n\nGo\nmain:\n  build: .\n  command: gin run\n  env_file: .env\n  volumes:\n    - ./:/go/src/github.com/larryprice/refermadness\n  working_dir: /go/src/github.com/larryprice/refermadness\n  ports:\n    - &quot;3000:3000&quot;\n  links:\n    - db\nsass:\n  image: larryprice/sass\n  volumes:\n    - ./public/css:/src\njsx:\n  image: larryprice/jsx\n  volumes:\n    - ./public/scripts:/src\ndb:\n  image: mongo:3.0\n  command: mongod --smallfiles --quiet --logpath=/dev/null\n  volumes_from:\n    - dbvolume\ndbvolume:\n  image: busybox:ubuntu-14.04\n  volumes:\n    - /data/db\n\n\n然后运行docker-compose up来运行所有的容器并启动服务器。","readingtime":19,"url":"/cates/Backend/post/2015-11-11/Go-Web-architecture","dirs":["go"],"relatives":[{"url":"/cates/Backend/post/2015-11-12/HTTP-2-And-GO","title":"HTTP/2 和GO"},{"url":"/cates/Backend/post/2015-11-15/create-a-homepage-for-Go-Web-App","title":"为Go Web App 创建一个主页面"},{"url":"/cates/Backend/post/2015-11-12/develop-HTTP-middleware-using-Go","title":"使用Go开发HTTP中间件"},{"url":"/cates/Backend/post/2015-11-13/http-Handler-And-Go-error-handle","title":"http.Handler 与Go的错误处理"}]}],"tag":"architecture"}}