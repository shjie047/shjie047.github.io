{"path":"tags/async","templateID":3,"sharedPropsHashes":{},"localProps":{"posts":[{"title":"ES2016, 2017和2018到底有哪些新东西？","author":"rajaraodv","tags":["js","JavaScript","前端","frontend","ECMAScript","ECMAScript 2016","ECMAScript 2017","ECMAScript 2018","es6","es7","async","await","async/await"],"iso8601Date":"2018-04-03T08:00:00+08:00","basename":"Here_are_examples_of_everything_new_in_ECMAScript_2016_2017_and_2018","body":"\n\n![](1_Z-9unq6Am3vekNOa5fD1xg.png)\n\nJS更新的速度非常快，配套的教程却很少，今天为大家带来18个新特性，并详细讲解使用方法。\n\n**下面依照JS版本的顺序开始介绍:**\n\n![](1_K09EWrqTcTwN9_dlhlzy6Q.png)\n\n## 1. Array.prototype.includes\n\n`includes`是数组的实例方法，这个方法的功能很简单：用于判断某一项是否存在数组里，和这个方法功能类似的有`indexOf`，两者的区别是`indexOf`无法判断`NaN`，\n如图：\n\n```Javascript\nconst arr = [1, 2, 3, 4, NaN];\n\n// es5\nif (arr.indexOf(3) >= 0) {\n  console.log(true)\n}\n\n// es2016\nif (arr.includes(1)) {\n  console.log(true)\n}\n\n// 注：indexOf不支持检查`NaN`\narr.indexOf(NaN) // -1\narr.includes(NaN) // true\n```\n\n## 2. 求幂运算符\n\n**求幂运算符**: `**`，用于取代以前的求幂方法`Math.pow`，\n\n使用方法如下：\n\n```Javascript\n// 之前\nMath.pow(3, 2) // 9\n\n// 现在\n3**2 // 9\n```\n\n![](1_fV_95TaY3ocgE8hlDhhv8w.png)\n\n## 1. Object.values()\n\n`Object.values`方法和`Object.keys`类似，返回类型都是数组，返回的值是对象的值的集合，需要注意一点：两个方法都是返回自身的属性，不包括任何原型链上的属性，如图：\n\n```Javascript\nconst cars = {BMW: 3, Tesla: 2, Toyota: 1}\n\n// es5\nconst vals = Object.keys(cars).map(key => cars[key]) \nconsole.log(vals) // [3, 2, 1]\n\n// es2016\nconst values = Object.values(cars)\nconsole.log(values) // [3, 2, 1]\n```\n\n\n## 2. Object.entries()\n\n`Object.entries()`方法有点像`Object.keys`和`Object.values`的结合体，返回类型是数组，同时数组的每一项也是数组 -- 包含两项：key和value，这个方法的好处在于你可以通过`for of`遍历一次取出key/value 和 `Object`可以直接转为`Map`：\n\n**例1**，遍历:\n\n```Javascript\nconst cars = { BMW: 3, Tesla: 2, Toyota: 1 }\n\n// es5的遍历方式\n// 需要把`key`取出来，再遍历\nObject.keys(cars).forEach(key => {\n  console.log(`key: ${key}, value: ${cars[key]}`)\n})\n\n// es2017\n// Object.entries(carts):\n// [\n//   ['BMW', 3],\n//   ['Tesla', 2],\n//   ['Toyota', 1]\n// ]\nfor (let [key, value] of Object.entries(cars)) {\n  console.log(`key: ${key}, value: ${cars[key]}`)\n}\n``` \n\n**例2**，把object直接转换为`Map`:\n\n```Javascript\nconst cars = { BMW: 3, Tesla: 2, Toyota: 1 }\n\n// es5\nconst map1 = new Map()\nObject.keys(cars).map(key => {\n  map1.set(key, cars[key])\n})\n\nconsole.log(map1) // Map { 'BMW': 3, 'Tesla': 2, 'Toyota': 1 }\n\n// es2016\nconst map2 = new Map(Object.entries(cars))\n\nconsole.log(map2) // Map { 'BMW': 3, 'Tesla': 2, 'Toyota': 1 }\n```\n\n## 3. String padding\n\nString增加了两个实例方法 -- `padStart`和`padEnd`，这两个方法可以在字符串的首/尾添加其他字符串:\n\n```Javascript\n// 'someStr'.padStart(字符数, [,添加的字符])\n\n'hello'.padStart('10', 'a') // 'aaaaahello', 添加了5个字符`a`后一共`10`个字符\n'hello'.padEnd('10', 'b') // 'hellobbbbb'\n'hello'.padStart('7') // '  hello', 在头部添加两个个空格\n```\n\n### 3.1 padStart示例\n\n```Javascript\nconst formatted = [0, 1, 12, 123, 1234, 12345].map(num =>\n  num.toString().padStart(10, '0')\n)\n\nconsole.log(formatted)\n// 输出:\n// [\n//   '0000000000',\n//   '0000000001',\n//   '0000000012,'\n//   '0000000234,'\n//   '0000001234,'\n//   '0009012345'\n// ]\n```\n\n### 3.2 padEnd示例\n\n```Javascript\nconst cars = {\n  '🚙BMW': '10',\n  '🚘Tesla': '5',\n  '🚖Lamborghini': '0'\n}\n\nObject.entries(cars).map(([name, count]) => {\n  console.log(`${name.padEnd(20, ' -')} Count: ${count.padStart(3, '0')}`)\n});\n\n//输出:\n// 🚙BMW - - - - - - -  Count: 010\n// 🚘Tesla - - - - - -  Count: 005\n// 🚖Lamborghini - - -  Count: 000\n```\n\n## 4.Object.getOwnPropertyDescriptors\n\n这个方法的作用是补充`Object.assign`的功能，在浅拷贝(shallow clone)对象的基础上，也会复制`getter`和`setter`方法：\n\n下面的例子用`Object.defineProperties`拷贝原对象`Car`到新对象`ElectricCar`来展示`Object.assign`和`Object.getOwnPropertyDescriptors`的不同。\n\n```Javascript\nconst Car = {\n  name: 'BMW',\n  price: 100000,\n  set discount(x) {\n    this.d = x\n  }\n  get discount() {\n    return this.d\n  }\n}\n\nconsole.log(Object.getOwnPropertyDescriptor(Car, 'discount')\n// 输出:\n// {\n//   get: [Function: get],\n//   set: [Function: set],\n//   enumerable: true,\n//   configurable: true\n// }\n\nconst ElectricCar = Object.assign({}, Car)\nconsole.log(Object.getOwnPropertyDescriptor(ElectricCar, 'discount'))\n// 输出:\n// {\n//   value: undefined,\n//   writable: true,\n//   enumerable: true,\n//   configurable: true\n// }\n\n// 使用`Object.assign`创建`ElectricCar`后，属性`getter`和`setter`丢失了\n```\n\n### 使用`Object.getOwnPropertyDescriptors`后:\n\n```Javascript\nconst Car = {\n  name: 'BMW',\n  price: 100000,\n  set discount(x) {\n    this.d = x\n  }\n  get discount() {\n    return this.d\n  }\n}\n\nconst ElectricCar2 = Object.defineProperties({}, Object.getOwnPropertyDescriptors(Car))\n// 输出:\n// {\n//   get: [Function: get],  <-----👈\n//   set: [Function: set],  <-----👈\n//   enumerable: true,\n//   configurable: true \n// }\n```\n\n## 5. 在函数最后一个参数的末尾添加逗号\n\n这是个很小的功能点，在函数形参最后一个参数末尾添加逗号，可以避免`git blame`提示上一个作者并不存在的改动，\n代码示例：\n\n```Javascript\n// 假设这个函数由 `程序员_1` 创建\n// 这个函数最后一个参数`age`后没有逗号\nfunction Person(\n  name,\n  age\n) {\n  this.name = name\n  this.age = age\n}\n\n// 如果 `程序员_2` 这时有了以下修改\nfunction Person(\n  name,\n  age, /* 那么这个`,`逗号也会引起`git blame`认为 `程序员_1` 修改了这一行*/\n  gender /* 添加了新参数 */\n) { // 新添加\n  this.name = name\n  this.age = age\n  this.gender = gender // 新添加\n}\n\n// es2017对这个混淆的处理办法是:\n// 通过 `程序员_1`在`age`末尾添加`,`逗号\n\n// 更新如下:\n\n// 假设这个函数由 `程序员_1` 创建\n// 在最后一个参数`age`后添加`,`逗号\nfunction Person(\n  name,\n  age, /* 添加逗号 */\n) {\n  this.name = name\n  this.age = age\n}\n```\n\n## 6. Async/Await\n\n这个特性是目前为止最重要的一个功能，`async`函数可以让我们避免频繁调用*恶心的*`callback`，使代码保持干净整洁。\n\n当编译器进入`async`函数后，遇到`await`关键字会暂停执行，可以把`await`后表达式当作一个`promise`，直到promise被`resolve`或`reject`后，函数才会恢复执行，\n\n具体看如下代码：\n\n```Javascript\n// es5的`Promise`\nfunction getAmount(userId) {\n  getUser(userId)\n    .then(getBankBalance)\n    .then(amount => {\n      console.log(amount)\n    })\n}\n\n// es2017的`async`\nasync function getAmount2(userId) {\n  var user = await getUser(userId)\n  var amount = await getBankBalance()\n  console.log(amount)\n}\n\ngetAmount('1') // $1,000\ngetAmount2('1') // $1,000\n\nfunction getUser(userId) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve('张三')\n    }, 1000)\n  })\n}\n\nfunction getBankBalance() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (user === '张三') {\n        resolve('$1,000')\n      } else {\n        resolve('Unknown User')\n      }\n    }, 1000)\n  })\n}\n```\n\n### 6.1 Async函数本身返回一个Promise\n\n因为async函数返回一个promise，所以想要得到async函数的返回值需要对返回的promise进行`then`求值。\n\n具体看如下代码：\n\n```Javascript\nasync function doubleAndAdd(a, b) {\n  a = await doubleAfter1Sec(a)\n  b = await doubleAfter1Sec(b)\n  return a + b\n}\n\ndoubleAndAdd(1, 2).then(console.log) // 5 \n\nasync function doubleAfter1Sec(param) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(param * 2)\n    }, 1000)\n  })\n}\n```\n\n### 6.2 并行调用async/await\n\n上一个函数`doubleAndAdd`里依次调用了两个`async`函数，但是每次调用都必须等待1秒，性能很差；因为参数`a`和参数`b`之间并无耦合，所以我们可以使用`Promise.all`来并行执行这两次调用:\n\n```Javascript\nasync function doubleAndAdd(a, b) {\n  // 使用`Promise.all`\n  // 这个地方使用数组`解构`\n  // 来得到两次调用的结果\n  const [a, b] = Promise.all([doubleAfter1Sec(a), doubleAfter1Sec(b)])\n  return a + b\n}\n\ndoubleAndAdd(1, 2).then(console.log) // 5 \n\nasync function doubleAfter1Sec(param) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(param * 2)\n    }, 1000)\n  })\n}\n```\n\n### 6.3 async/await的错误处理\n\n`async/await`对错误处理有很多方法：\n\n#### 1. 在函数内使用try/catch\n\n```Javascript\nasync function doubleAndAdd(a, b) {\n  try {\n    a = await doubleAfter1Sec(a)\n    b = await doubleAfter1Sec(b)\n  } catch (e) {\n    return NaN\n  }\n  return a + b\n}\n\ndoubleAndAdd('one', 2).then(console.log) // NaN\ndoubleAndAdd(1, 2).then(console.log) // 5 \n\nasync function doubleAfter1Sec(param) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      const val = param * 2\n      isNaN(val) ? reject(NaN) : resolve(val)\n    }, 1000)\n  })\n}\n```\n\n#### 2. catch 所有`await`表达式\n\n因为`await`表达式返回一个`promise`，所以我们可以在`await`表达式后直接执行`catch`来处理错误\n\n```Javascript\nasync function doubleAndAdd(a, b) {\n  a = await doubleAfter1Sec(a).catch(e => console.log(`'a' is NaN`)\n  b = await doubleAfter1Sec(b).catch(e => console.log(`'b' is NaN`))\n\n  if (!a || !b) return NaN\n  return a + b\n}\n\ndoubleAndAdd('one', 2).then(console.log) // NaN, \"a\" is NaN\ndoubleAndAdd(1, 2).then(console.log) // 5 \n\nasync function doubleAfter1Sec(param) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      const val = param * 2\n      isNaN(val) ? reject(NaN) : resolve(val)\n    }, 1000)\n  })\n}\n```\n\n#### 3. catch 整个async-await函数\n\n```Javascript\nasync function doubleAndAdd(a, b) {\n  a = await doubleAfter1Sec(a)\n  b = await doubleAfter1Sec(b)\n  return a + b\n}\n\ndoubleAndAdd('one', 2)\n  .then(console.log)\n  .catch(console.log) // 使用catch\n```\n\n![](1_X755b572fEcI0vK0fRKWkw.png)\n\n> ECMAScript目前在最终稿阶段，将会在2018年6月或7月正式推出。下面介绍的所有特性属于**stage-4**，即将成为ECMAScript 2018的一部分。\n\n## 1. 共享内存和原子性\n\n这是JS的一个高级特性，也是JS引擎的核心改进。\n\n**共享内存的主要思想是： 把多线程的特性带到JS，为了提高代码的性能和高并发，由之前的JS引擎管理内存变为自己管理内存。** \n\n这个特性由一个新的全局对象[SharedArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer)来实现，这个对象在一块**共享内存区**储存数据，JS的主线程和`web-worker`线程共享这部分数据。\n\n当前，如果我们想要在JS主线程和web-worker线程间共享数据时，必须使用`postMessage`在不同线程间传递数据，有了`SharedArrayBuffer`后，不同的线程可以直接访问这个对象来共享数据。\n\n但是多线程间的共享内存会产生竞态条件，为了避免这种情况，JS引入了`原子性`的全局对象。这个对象提供了多种方法来保证正在被某个线程访问的内存被锁住，以达到内存安全。\n\n## 2. Tagged Template literal(带标签的模板字面量?) 限制被移除\n\n首先弄懂一个概念：什么s是Tagged Template literal ?\n\n`tagged template literal`出现在es2015以后，允许开发者自定义字符串被嵌入的值。举一个例子，标准的字符串嵌入一个值的方式是：\n\n```JavaScript\nconst userName = '张三'\nconst greetings = `hello ${userName}!`\n\nconsole.log(greetings) // \"hello 张三!\"\n```\n\n在`tagged template literal`里，你可以用一个函数通过参数来接收字符串写死的各部分，比如: ['hello', '!']和之后被替换为值的变量['张三']，最后通过函数返回任何你想要的结果，这个函数被称作`Tagged`函数，下面`Tagged`函数`greet`来扩展上例中的greetings：\n\n```Javascript\nconst userName = '张三'\nconst greetings = `hello ${userName}!`\n\nconsole.log(greetings) // \"hello 张三!早上好!\"\n\n// hardCodedPartsArray: 字符串写死的各部分,  [ \"hello \", \"!\" ]\n// replacementPartsArray: 字符串里嵌入的变量, [ \"张三\" ]\nfunction greet(hardCodedPartsArray, ...replacementPartsArray) {\n  let str = ''\n  hardCodedPartsArray.forEach((part, i) => {\n    if (i < replacementPartsArray.length) {\n      str += `${part}${replacementPartsArray[i] || ''}`\n    } else {\n      str += `${part} ${timeGreet()}` // 在结尾添加问候语\n    }\n  })\n\n  return str\n}\n\nfunction timeGreet() {\n  const hr = new Date().getHours()\n  return hr < 12\n    ? '早上好!'\n    : hr < 18 ? '下午好!' : '晚上好!'\n}\n```\n\n上面例子解释了`Tagged`函数是什么，这个特性可以用在多种场景，比如：终端命令和URI地址的拼接。\n\n### 2.1 ⚠️Tagged Template literal使用中的问题\n\n","date":"2018-04-03"}]}}