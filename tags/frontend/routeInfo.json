{"path":"tags/frontend","templateID":4,"sharedPropsHashes":{"tags":"Zpc8p0"},"localProps":{"posts":[{"author":"Travis Fischer","title":"那些值得一用的JS库","cover":"https://p6jqy6mfr.bkt.clouddn.com/1_Ed4yEvBF4DmMJ1Es1p_hXw.jpeg","iso8601Date":"2018-03-10T08:00:00+08:00","basename":"JavaScript_Modules_Worth_Using","tags":["JS","Javascript","Frontend","前端","NodeJS","Node","NPM"],"date":"2018-03-10","cate":"Frontend","summary":"本文收集了前端JS开发和NodeJS开发中的一些优秀的库和工具。\n\n1. 命令行工具\n\nnp - 更好的npm publish\n\n如果你是一个npm作者，强烈推荐使用np模块，它能为你轻而易举地解决更新版本、添加git发布tag和发布代码到npm，特别是当你有很多npm模块要维护的时候。\n\n\n\nyarn - 更好的包管理工具，同时兼容npm\n\n虽然npm v5已经比上一个版本速度提升很多，但是个人感觉在本地开发中yarn仍然以速度和稳定性取胜。但是无论用哪个工具，你都在使用同一个npm包的数据，究竟两者孰优孰劣并没有定论，所以挑选哪个工具还是要看你的项目需求。\n\nprettier - 强烈推荐的一款代码格式化工具\n\nPrettier通过代码解析强制要求代码风格保持一致，然后用内置的规则来重新输出样式，并通过必要的代码封装来限制代码最大行数。\n\n\n\nnow\n\nNow毫无疑问是迄今为止最好的免费部署系统，以简单、稳定和功能多著称。它非常适合测试静态和动态部署，并且很方便扩充服务器。\n\n\n\nasciinema - 录制高质量的终端(terminal)信息\n\n一款录制终端 &amp; 代码的神器，从此分享代码告别截屏！\n\n2. Promise\n\n这一小节值得专门拿出来写一篇文章，尤其现在async/await已经成为JS的并发编程的标准。这里收集了一些Node端非常有用的Promise相关库：\n\npify - 转换callback为promise\n\n目前有很多方法都可以把过时的callback-style的代码转成promise-style，但是pify可能是其中最好的解决方案。它体积很小，同时有util.promisify(node本地接口)没有的一些细节：比如方法自动绑定等。\n\np-map - 给并行设置限制数\n\n并行虽然很好，但是大多时候出于带宽或者计算资源的考虑需要设置一个对并行的限制，这是p-map擅长的领域。它可以取代不支持限制并行的Promise.all()方法。\n\np-retry - 给promise请求添加重新请求机制\n\n通常在发送http请求或者外部服务调用的时候可以用p-retry在外部封装一层，提高请求的健壮性。\n\np-timeout - 为promise请求添加超时处理\n\n为promise请求指定一个超时时间，然后添加超时处理方案\n\n3. 数据抓取\n\n有很多很棒的抓取工具，有一些直接操作HTML，像cheerio，还有一个些可以模拟一个完整的浏览器环境像puppeteer。具体使用哪种工具还是要依赖使用场景。\n\ncheerio - 快速、灵活和实现核心jQuery Api，服务于服务端\n\n当你想操作HTML时，Cheerio非常适合快速 &amp; 肮脏的web数据抓取。它提供了健壮的类jQuery语法，用来遍历和处理HTML文档。在抓取远程HTML文档时，Cheerio和下面要介绍的require-promise-native非常适合搭配一起使用。\n\npuppeteer - Headless Chrome Node API\n\n和cheerio不同，puppeteer是在headless Chrome(没有UI的Chrome，供服务端自动化测试用)外包装的一层高级API，通过开发工具协议控制headless Chrome或者Chromium，它也可以通过配置来使用全部Chrome或者Chromius的功能。\n\n4. Node.js\n\ndotenv-safe - 从.env里加载环境变量\n\n这个模块扩展了非常流行的库dotenv，通过添加一个.env.example文件强制保证预期环境变量的存在。与原始版本一样，它为Node提供了快速的、安全的和健壮的环境变量。\n\nrequest和request-promise-native - 简单的HTTP请求客户端\n\n发送HTTP请求是一个极其常用的操作，常用的库是request-promise-native，它封装了request库，并提供了本地ES6的Promise支持。\n\nconsolidate - Node的模板引擎整合库\n\nConsolidate可以非常漂亮的处理任何后端模板（email, html等等）。它提供了简单、稳定的各种模板引擎接口。\n\nexeca - 更好的child_process\n\n在需要执行shell命令或者spawn一个子进程时极其有用\n\nfs-extra - 更好的fs，拥有更多方法和Promise支持\n\n5. 数学\n\nd3-random - 生成各种分布的随机数\n\nd3-ease - 产生流畅动画的Easing函数\n\n6. 测试\n\nava - 很棒的JS test runner\n\nAva是比较新的JS单元测试工具，它具有众多JS测试库(Mocha、tape、chai和其他库)的优点，默认情况下采用并行运行的方式。\n\n\n\nnock - HTTP模拟请求\n\nNock是一个很棒的测试HTTP请求的库。如果你的Node模块需要发送HTTP请求，并且你想要对这个请求做单元测试，那么nock是你的不二之选。","readingtime":5,"url":"/cates/Frontend/post/2018-03-10/JavaScript_Modules_Worth_Using","dirs":["js"],"relatives":[{"url":"/cates/Frontend/post/2018-04-03/Here_are_examples_of_everything_new_in_ECMAScript_2016_2017_and_2018","title":"ES2016, 2017和2018到底有哪些新东西？"},{"url":"/cates/Frontend/post/2018-04-08/hyperapp","title":"1kb的JS框架 - Hyperapp"}]},{"title":"ES2016, 2017和2018到底有哪些新东西？","author":"rajaraodv","cover":"https://p6jqy6mfr.bkt.clouddn.com/1_Z-9unq6Am3vekNOa5fD1xg.png","iso8601Date":"2018-04-03T08:00:00+08:00","basename":"Here_are_examples_of_everything_new_in_ECMAScript_2016_2017_and_2018","tags":["JS","Javascript","前端","Frontend","ECMAScript","ECMAScript2016","ECMAScript2017","ECMAScript2018","ES6","ES7","Async","Await","Async/Await"],"date":"2018-04-03","cate":"Frontend","summary":"JS更新的速度非常快，配套的教程却很少，今天为大家带来18个新特性，并详细讲解使用方法。\n\n下面依照JS版本的顺序开始介绍:\n\n\n\n1. Array.prototype.includes\n\nincludes是数组的实例方法，这个方法的功能很简单：用于判断某一项是否存在数组里，和这个方法功能类似的有indexOf，两者的区别是indexOf无法判断NaN，\n如图：\n\n`Javascript\nconst arr = [1, 2, 3, 4, NaN];\n\n// es5\nif (arr.indexOf(3) &gt;= 0) {\n  console.log(true)\n}\n\n// es2016\nif (arr.includes(1)) {\n  console.log(true)\n}\n\n// 注：indexOf不支持检查NaN\narr.indexOf(NaN) // -1\narr.includes(NaN) // true\n`\n\n2. 求幂运算符\n\n求幂运算符: **，用于取代以前的求幂方法Math.pow，\n\n使用方法如下：\n\n`Javascript\n// 之前\nMath.pow(3, 2) // 9\n\n// 现在\n3**2 // 9\n`\n\n\n\n1. Object.values()\n\nObject.values方法和Object.keys类似，返回类型都是数组，返回的值是对象的值的集合，需要注意一点：两个方法都是返回自身的属性，不包括任何原型链上的属性，如图：\n\n`Javascript\nconst cars = {BMW: 3, Tesla: 2, Toyota: 1}\n\n// es5\nconst vals = Object.keys(cars).map(key =&gt; cars[key]) \nconsole.log(vals) // [3, 2, 1]\n\n// es2016\nconst values = Object.values(cars)\nconsole.log(values) // [3, 2, 1]\n`\n\n2. Object.entries()\n\nObject.entries()方法有点像Object.keys和Object.values的结合体，返回类型是数组，同时数组的每一项也是数组 -- 包含两项：key和value，这个方法的好处在于你可以通过for of遍历一次取出key/value 和 Object可以直接转为Map：\n\n例1，遍历:\n\n`Javascript\nconst cars = { BMW: 3, Tesla: 2, Toyota: 1 }\n\n// es5的遍历方式\n// 需要把key取出来，再遍历\nObject.keys(cars).forEach(key =&gt; {\n  console.log(key: ${key}, value: ${cars[key]})\n})\n\n// es2017\n// Object.entries(carts):\n// [\n//   [&#39;BMW&#39;, 3],\n//   [&#39;Tesla&#39;, 2],\n//   [&#39;Toyota&#39;, 1]\n// ]\nfor (let [key, value] of Object.entries(cars)) {\n  console.log(key: ${key}, value: ${cars[key]})\n}\n` \n\n例2，把object直接转换为Map:\n\n`Javascript\nconst cars = { BMW: 3, Tesla: 2, Toyota: 1 }\n\n// es5\nconst map1 = new Map()\nObject.keys(cars).map(key =&gt; {\n  map1.set(key, cars[key])\n})\n\nconsole.log(map1) // Map { &#39;BMW&#39;: 3, &#39;Tesla&#39;: 2, &#39;Toyota&#39;: 1 }\n\n// es2016\nconst map2 = new Map(Object.entries(cars))\n\nconsole.log(map2) // Map { &#39;BMW&#39;: 3, &#39;Tesla&#39;: 2, &#39;Toyota&#39;: 1 }\n`\n\n3. String padding\n\nString增加了两个实例方法 -- padStart和padEnd，这两个方法可以在字符串的首/尾添加其他字符串:\n\n`Javascript\n// &#39;someStr&#39;.padStart(字符数, [,添加的字符])\n\n&#39;hello&#39;.padStart(&#39;10&#39;, &#39;a&#39;) // &#39;aaaaahello&#39;, 添加了5个字符a后一共10个字符\n&#39;hello&#39;.padEnd(&#39;10&#39;, &#39;b&#39;) // &#39;hellobbbbb&#39;\n&#39;hello&#39;.padStart(&#39;7&#39;) // &#39;  hello&#39;, 在头部添加两个个空格\n`\n\n3.1 padStart示例\n\n`Javascript\nconst formatted = [0, 1, 12, 123, 1234, 12345].map(num =&gt;\n  num.toString().padStart(10, &#39;0&#39;)\n)\n\nconsole.log(formatted)\n// 输出:\n// [\n//   &#39;0000000000&#39;,\n//   &#39;0000000001&#39;,\n//   &#39;0000000012,&#39;\n//   &#39;0000000234,&#39;\n//   &#39;0000001234,&#39;\n//   &#39;0009012345&#39;\n// ]\n`\n\n3.2 padEnd示例\n\n`Javascript\nconst cars = {\n  &#39;🚙BMW&#39;: &#39;10&#39;,\n  &#39;🚘Tesla&#39;: &#39;5&#39;,\n  &#39;🚖Lamborghini&#39;: &#39;0&#39;\n}\n\nObject.entries(cars).map(([name, count]) =&gt; {\n  console.log(${name.padEnd(20, &#39; -&#39;)} Count: ${count.padStart(3, &#39;0&#39;)})\n});\n\n//输出:\n// 🚙BMW - - - - - - -  Count: 010\n// 🚘Tesla - - - - - -  Count: 005\n// 🚖Lamborghini - - -  Count: 000\n`\n\n4.Object.getOwnPropertyDescriptors\n\n这个方法的作用是补充Object.assign的功能，在浅拷贝(shallow clone)对象的基础上，也会复制getter和setter方法：\n\n下面的例子用Object.defineProperties拷贝原对象Car到新对象ElectricCar来展示Object.assign和Object.getOwnPropertyDescriptors的不同。\n\n`Javascript\nconst Car = {\n  name: &#39;BMW&#39;,\n  price: 100000,\n  set discount(x) {\n    this.d = x\n  }\n  get discount() {\n    return this.d\n  }\n}\n\nconsole.log(Object.getOwnPropertyDescriptor(Car, &#39;discount&#39;)\n// 输出:\n// {\n//   get: [Function: get],\n//   set: [Function: set],\n//   enumerable: true,\n//   configurable: true\n// }\n\nconst ElectricCar = Object.assign({}, Car)\nconsole.log(Object.getOwnPropertyDescriptor(ElectricCar, &#39;discount&#39;))\n// 输出:\n// {\n//   value: undefined,\n//   writable: true,\n//   enumerable: true,\n//   configurable: true\n// }\n\n// 使用Object.assign创建ElectricCar后，属性getter和setter丢失了\n`\n\n使用Object.getOwnPropertyDescriptors后:\n\n`Javascript\nconst Car = {\n  name: &#39;BMW&#39;,\n  price: 100000,\n  set discount(x) {\n    this.d = x\n  }\n  get discount() {\n    return this.d\n  }\n}\n\nconst ElectricCar2 = Object.defineProperties({}, Object.getOwnPropertyDescriptors(Car))\n// 输出:\n// {\n//   get: [Function: get],  &lt;-----👈\n//   set: [Function: set],  &lt;-----👈\n//   enumerable: true,\n//   configurable: true \n// }\n`\n\n5. 在函数最后一个参数的末尾添加逗号\n\n这是个很小的功能点，在函数形参最后一个参数末尾添加逗号，可以避免git blame提示上一个作者并不存在的改动，\n代码示例：\n\nJavascript\n// 假设这个函数由 程序员_1 创建\n// 这个函数最后一个参数age`后没有逗号\nfunction Person(\n  name,\n  age\n) {\n  this.name = name\n  this.age = age\n}\n\n// 如果 程序员_2 这时有了以下修改\nfunction Person(\n  name,\n  age, / 那么这个,逗号也会引起git blame认为 程序员_1 修改了这一行/\n  gender / 添加了新参数 /\n) { // 新添加\n  this.name = name\n  this.age = age\n  this.gender = gender // 新添加\n}\n\n// es2017对这个混淆的处理办法是:\n// 通过 程序员_1在age末尾添加,逗号\n\n// 更新如下:\n\n// 假设这个函数由 程序员_1 创建\n// 在最后一个参数age后添加,逗号\nfunction Person(\n  name,\n  age, / 添加逗号 /\n) {\n  this.name = name\n  this.age = age\n}\n`\n\n6. Async/Await\n\n这个特性是目前为止最重要的一个功能，async函数可以让我们避免频繁调用恶心的callback，使代码保持干净整洁。\n\n当编译器进入async函数后，遇到await关键字会暂停执行，可以把await后表达式当作一个promise，直到promise被resolve或reject后，函数才会恢复执行，\n\n具体看如下代码：\n\nJavascript\n// es5的Promise`\nfunction getAmount(userId) {\n  getUser(userId)\n    .then(getBankBalance)\n    .then(amount =&gt; {\n      console.log(amount)\n    })\n}\n\n// es2017的async\nasync function getAmount2(userId) {\n  var user = await getUser(userId)\n  var amount = await getBankBalance()\n  console.log(amount)\n}\n\ngetAmount(&#39;1&#39;) // $1,000\ngetAmount2(&#39;1&#39;) // $1,000\n\nfunction getUser(userId) {\n  return new Promise(resolve =&gt; {\n    setTimeout(() =&gt; {\n      resolve(&#39;张三&#39;)\n    }, 1000)\n  })\n}\n\nfunction getBankBalance() {\n  return new Promise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n      if (user === &#39;张三&#39;) {\n        resolve(&#39;$1,000&#39;)\n      } else {\n        resolve(&#39;Unknown User&#39;)\n      }\n    }, 1000)\n  })\n}\n`\n\n6.1 Async函数本身返回一个Promise\n\n因为async函数返回一个promise，所以想要得到async函数的返回值需要对返回的promise进行then求值。\n\n具体看如下代码：\n\n`Javascript\nasync function doubleAndAdd(a, b) {\n  a = await doubleAfter1Sec(a)\n  b = await doubleAfter1Sec(b)\n  return a + b\n}\n\ndoubleAndAdd(1, 2).then(console.log) // 5 \n\nasync function doubleAfter1Sec(param) {\n  return new Promise(resolve =&gt; {\n    setTimeout(() =&gt; {\n      resolve(param * 2)\n    }, 1000)\n  })\n}\n`\n\n6.2 并行调用async/await\n\n上一个函数doubleAndAdd里依次调用了两个async函数，但是每次调用都必须等待1秒，性能很差；因为参数a和参数b之间并无耦合，所以我们可以使用Promise.all来并行执行这两次调用:\n\nJavascript\nasync function doubleAndAdd(a, b) {\n  // 使用Promise.all\n  // 这个地方使用数组解构`\n  // 来得到两次调用的结果\n  const [a, b] = Promise.all([doubleAfter1Sec(a), doubleAfter1Sec(b)])\n  return a + b\n}\n\ndoubleAndAdd(1, 2).then(console.log) // 5 \n\nasync function doubleAfter1Sec(param) {\n  return new Promise(resolve =&gt; {\n    setTimeout(() =&gt; {\n      resolve(param * 2)\n    }, 1000)\n  })\n}\n`\n\n6.3 async/await的错误处理\n\nasync/await对错误处理有很多方法：\n\n1. 在函数内使用try/catch\n\n`Javascript\nasync function doubleAndAdd(a, b) {\n  try {\n    a = await doubleAfter1Sec(a)\n    b = await doubleAfter1Sec(b)\n  } catch (e) {\n    return NaN\n  }\n  return a + b\n}\n\ndoubleAndAdd(&#39;one&#39;, 2).then(console.log) // NaN\ndoubleAndAdd(1, 2).then(console.log) // 5 \n\nasync function doubleAfter1Sec(param) {\n  return new Promise(resolve =&gt; {\n    setTimeout(() =&gt; {\n      const val = param * 2\n      isNaN(val) ? reject(NaN) : resolve(val)\n    }, 1000)\n  })\n}\n`\n\n2. catch 所有await表达式\n\n因为await表达式返回一个promise，所以我们可以在await表达式后直接执行catch来处理错误\n\nJavascript\nasync function doubleAndAdd(a, b) {\n  a = await doubleAfter1Sec(a).catch(e =&gt; console.log(&#39;a&#39; is NaN)\n  b = await doubleAfter1Sec(b).catch(e =&gt; console.log(&#39;b&#39; is NaN`))\n\n  if (!a || !b) return NaN\n  return a + b\n}\n\ndoubleAndAdd(&#39;one&#39;, 2).then(console.log) // NaN, &quot;a&quot; is NaN\ndoubleAndAdd(1, 2).then(console.log) // 5 \n\nasync function doubleAfter1Sec(param) {\n  return new Promise(resolve =&gt; {\n    setTimeout(() =&gt; {\n      const val = param * 2\n      isNaN(val) ? reject(NaN) : resolve(val)\n    }, 1000)\n  })\n}\n`\n\n3. catch 整个async-await函数\n\n`Javascript\nasync function doubleAndAdd(a, b) {\n  a = await doubleAfter1Sec(a)\n  b = await doubleAfter1Sec(b)\n  return a + b\n}\n\ndoubleAndAdd(&#39;one&#39;, 2)\n  .then(console.log)\n  .catch(console.log) // 使用catch\n`\n\n\n\nECMAScript目前在最终稿阶段，将会在2018年6月或7月正式推出。下面介绍的所有特性属于stage-4，即将成为ECMAScript 2018的一部分。\n\n1. 共享内存和原子性\n\n这是JS的一个高级特性，也是JS引擎的核心改进。\n\n共享内存的主要思想是： 把多线程的特性带到JS，为了提高代码的性能和高并发，由之前的JS引擎管理内存变为自己管理内存。 \n\n这个特性由一个新的全局对象SharedArrayBuffer来实现，这个对象在一块共享内存区储存数据，JS的主线程和web-worker线程共享这部分数据。\n\n当前，如果我们想要在JS主线程和web-worker线程间共享数据时，必须使用postMessage在不同线程间传递数据，有了SharedArrayBuffer后，不同的线程可以直接访问这个对象来共享数据。\n\n但是多线程间的共享内存会产生竞态条件，为了避免这种情况，JS引入了原子性的全局对象。这个对象提供了多种方法来保证正在被某个线程访问的内存被锁住，以达到内存安全。\n\n2. Tagged Template literal(带标签的模板字面量?) 限制被移除\n\n首先弄懂一个概念：什么s是Tagged Template literal ?\n\ntagged template literal出现在es2015以后，允许开发者自定义字符串被嵌入的值。举一个例子，标准的字符串嵌入一个值的方式是：\n\nJavaScript\nconst userName = &#39;张三&#39;\nconst greetings = hello ${userName}!`\n\nconsole.log(greetings) // &quot;hello 张三!&quot;\n`\n\n在tagged template literal里，你可以用一个函数通过参数来接收字符串写死的各部分，比如: [&#39;hello&#39;, &#39;!&#39;]和之后被替换为值的变量[&#39;张三&#39;]，最后通过函数返回任何你想要的结果，这个函数被称作Tagged函数，下面Tagged函数greet来扩展上例中的greetings：\n\nJavascript\nconst userName = &#39;张三&#39;\nconst greetings = hello ${userName}!`\n\nconsole.log(greetings) // &quot;hello 张三!早上好!&quot;\n\n// hardCodedPartsArray: 字符串写死的各部分,  [ &quot;hello &quot;, &quot;!&quot; ]\n// replacementPartsArray: 字符串里嵌入的变量, [ &quot;张三&quot; ]\nfunction greet(hardCodedPartsArray, ...replacementPartsArray) {\n  let str = &#39;&#39;\n  hardCodedPartsArray.forEach((part, i) =&gt; {\n    if (i &lt; replacementPartsArray.length) {\n      str += ${part}${replacementPartsArray[i] || &#39;&#39;}\n    } else {\n      str += ${part} ${timeGreet()} // 在结尾添加问候语\n    }\n  })\n\n  return str\n}\n\nfunction timeGreet() {\n  const hr = new Date().getHours()\n  return hr &lt; 12\n    ? &#39;早上好!&#39;\n    : hr &lt; 18 ? &#39;下午好!&#39; : &#39;晚上好!&#39;\n}\n`\n\n3. 正则表达式中的.匹配所有字符\n\n在目前的正则表达式中，虽然.点被认为代表所以字符，实际上它不会匹配像\\n、\\r和\\f等换行符。\n\n例如:\n\nJavascript\n// 之前\n/first.second/.test(&#39;first\\nsecond&#39;); // false\n\n\n这个改进使.点操作符匹配任意单个字符。为了保证下面这段代码在任何JS版本都正常工作，我们在结尾加上/s修饰符\n\nJavascript\n//ECMAScript 2018\n/first.second/s.test(&#39;first\\nsecond&#39;); // true   注意: /s 👈🏼\n\n\n4. 正则表达式捕获Named Group\n\n这个改进带来了在其他语言中比如:Java、Python等已经支持了的有用的正则特性。这个特性允许开发者在正则中为不同的组写格式为(&lt;?name&gt;)的名字标识符，之后可以在匹配的结果里通过名字标识的组来获取对应的值。\n\n4.1 基础示例\n\n`Javascript\n// 之前\nconst re1 = /(\\d{4})-(\\d{2})-(\\d{2})/\nconst result1 = re1.exec(&#39;2015-01-08&#39;)\nconsole.log(result1)\n// 输出：\n// [\n//   &quot;2015-01-08&quot;,\n//   &quot;2015&quot;,\n//   &quot;01&quot;,\n//   &quot;08&quot;,\n//   index: 0,\n//   input: &quot;2015-01-08&quot;,\n//   groups: undefined\n// ]\n\n// 现在 (es2018)\nconst re2 = /(?&lt;year&gt;\\d{4})-(?&lt;month&gt;\\d{2})-(?&lt;day&gt;\\d{2})/u\nconst result2 = re2.exec(&#39;2015-01-08&#39;)\nconsole.log(result2)\n\n// 输出：\n// [\n//   &quot;2015-01-08&quot;,\n//   &quot;2015&quot;,\n//   &quot;01&quot;,\n//   &quot;08&quot;,\n//   groups: {\n//     day: &quot;08&quot;,\n//     month: &quot;01&quot;,\n//     year: &quot;2015&quot;\n//   },\n//   index: 0,\n//   input: &quot;2015-01-08&quot;,\n// ]\n`\n\n4.2 在正则自身使用命名组\n\n我们可以使用格式\\k&lt;group name&gt;在正则自身来引用之前的组。下面的用例子展示：\n\nJavascript\n// 在这个例子里，我们有一个命名组fruit，\n// 它可以匹配apple或者orange，我们可以用\\k&lt;group name&gt;`(\\k&lt;fruit&gt;)\n// 来引用之前匹配的这个组\n// 所以等号两边的值是相等的\n\nconst sameWords = /(?&lt;fruit&gt;apple|orange)==\\k&lt;fruit&gt;/u\nsameWords.test(&#39;apple==apple&#39;) // true\nsameWords.test(&#39;orange==orange&#39;) // true\nsameWords.test(&#39;apple==orange&#39;) // false\n`\n\n4.3 在String.prototype.replace里使用命名组\n\n命名组特性已经被添加到replace方法里，所以我们可以轻松地替换字符串了。\n\n例如： 改变&quot;firstName, lastName&quot; 为 &quot;lastName, firstName&quot;:\n\nJavascript\nconst re = /(?&lt;firstName&gt;[A-Za-z]+) (?&lt;lastName&gt;[A-Za-z]+)/u\n&#39;John Lennon&#39;.replace(re, &#39;$&lt;lastName&gt;, $&lt;firstName&gt;&#39;) // Lennon John\n\n\n5. 对象的Rest properties\n\nRest操作符...（三个点）允许我们取出剩余的对象属性\n\n5.1 使用Rest properties来取出你想要使用的属性\n\n`Javascript\nlet { name, age, ...remaining} = {\n  name: &#39;张三&#39;,\n  age: 20,\n  gender: &#39;男&#39;,\n  address: &#39;xxxxx&#39;\n}\n\nname // &#39;张三&#39;\nage // 20\n`\n\n5.2 你甚至可以移除不想要的属性\n\n`Javascript\n// 如果我们想要删除address属性，\n// 但是我们又不想要遍历对象重新创建新对象\n// 我们只要简单的解构出这个要移除的属性\n// 剩下的没有解构的对象\n// 就是我们想要留下的对象\nlet {address, ...cleanObj} = {\n  name: &#39;john&#39;,\n  address: &#39;北京市海淀区&#39;,\n  gender: &#39;男&#39;\n}\n\ncleanObj // {name, gender}\n`\n\n6. 对象的Spread properties\n\nSpread属性看起来和Rest属性很像，也是三个点...操作符，不同的是Spread用于创建新对象。\n\n`Javascript\nconst person = {name: &#39;john&#39;, age: 20}\nconst address = {city: &#39;Beijing&#39;, country: &#39;china&#39;}\n\nconst personWithAddress = {\n  ...person,\n  ...address\n}\n\npersonWithAddress // {name, age, city, country}\n`\n\n7. 正则Lookbehind断言\n\n这个正则的改进允许我们保证在一些字符串之前存在某些字符串。\n\n你可以使用一组(?&lt;=...)(问号，小于等于)寻找后面肯定的断言。\n\n更进一步，你可以使用(?&lt;!...(问号，小于号叹号)寻找后面否定的断言。\n\n肯定断言: 比如我们想要确定在符号#出现在单词winning前，即#winning，只返回winning:\n\n`Javascript\n/(?&lt;=#)./.test(&#39;winning&#39;) // false\n/(?&lt;=#)./.test(&#39;#winning&#39;) // true\n\n// 之前\n&#39;#winning&#39;.match(/#.*/)[0] // &#39;#winning&#39;\n\n// es2018\n&#39;#winning&#39;.match(/(?&lt;=#).*/)[0] // &#39;winning&#39;, 没有 #, #只是为了验证\n`\n\n否定断言：比如我们想要取出数字前标志是#，而不是$的数字\n\nJavascript\n&#39;this is a test signal $1.23&#39;.match(/(?&lt;!\\$)\\d+\\.\\d+/) // null\n&#39;this is a test signal #2.43&#39;.match(/(?&lt;!\\$)\\d+\\.\\d+/)[0] // 2.43\n\n\n8. 正则Unicode属性转义符\n\n用正则匹配所有的unicode字符很困难。像\\w、\\W、\\d等只能匹配英文字符和数字，但是出现在其他语言比如希腊语里的数字我们要怎么处理呢？\n\nUnicode属性转义符就是为了解决这个问题。它使Unicode为每个字符添加描述性的metadata。","readingtime":34,"url":"/cates/Frontend/post/2018-04-03/Here_are_examples_of_everything_new_in_ECMAScript_2016_2017_and_2018","dirs":["js"],"relatives":[{"url":"/cates/Frontend/post/2018-03-10/JavaScript_Modules_Worth_Using","title":"那些值得一用的JS库"},{"url":"/cates/Frontend/post/2018-04-08/hyperapp","title":"1kb的JS框架 - Hyperapp"}]},{"author":"shjie047","title":"1kb的JS框架 - Hyperapp","cover":"https://p6jqy6mfr.bkt.clouddn.com/stock-photo-249278113.jpg","iso8601Date":"2018-04-08T08:00:00+08:00","basename":"hyperapp","tags":["前端","JS","Javascript","Frontend","Hyperapp","React","Web"],"date":"2018-04-08","cate":"Frontend","summary":"1. 概览\n\nHyperapp是最近开源的一个前端web开发框架，体积很小 -- 只有1.4kb，api很简单 -- 只有两个函数: h和app；借鉴了React、Redux和Elm的思想,\n\n它的主要要特点是：\n\n最小化 -- 用最少的代码实现了同类框架(React、Vue等)的核心功能重实效 -- 坚持函数式编程来管理状态(state)，同时提供有效的方法来处理边际效应(side effects)比如：异步action和DOM操作独立性 -- 自身集成状态管理和虚拟DOM引擎(虚拟DOM支持key更新 &amp;&amp; 生命周期事件)，没有第三方依赖\n\n下面用Hyperapp实现一个Counter的demo，实现了简单的加和减:\n\n`Javascript\n// 两个API\nimport { h, app } from &quot;hyperapp&quot;\n\n// 状态\nconst state = {\n  count: 0\n}\n\n// 用action来更新state\nconst actions = {\n  down: value =&gt; state =&gt; ({ count: state.count - value }),\n  up: value =&gt; state =&gt; ({ count: state.count + value })\n}\n\n// 用jsx来编写视图\nconst view = (state, actions) =&gt; (\n  &lt;div&gt;\n    &lt;h1&gt;{state.count}&lt;/h1&gt;\n    &lt;button onclick={() =&gt; actions.down(1)}&gt;-&lt;/button&gt;\n    &lt;button onclick={() =&gt; actions.up(1)}&gt;+&lt;/button&gt;\n  &lt;/div&gt;\n)\n\n// 把state，actions，view连接起来并渲染到页面的body元素上\napp(state, actions, view, document.body)\n`\n\n2. API\n\nHyperapp由两个函数API组成：h和app。\n\nh返回一个新的虚拟DOM节点树，app把一个新的app渲染到指定DOM元素上。\n\n以上的示例需要本地环境安装：编译器 -- Babel或者TypeScript，打包工具 -- Parcel或者Webpack，使用JSX来编写模板需要在.babelrc安装transform plugin来支持:\n\nJSON\n{\n  &quot;plugins&quot;: [[&quot;transform-react-jsx&quot;, { &quot;pragma&quot;: &quot;h&quot; }]]\n}\n\n\n2.1 JSX\n\nJSX是JS的语言扩展，可以写出和HTML类似的标签式组件，浏览器本身不支持JSX，需要配合编译器把JSX编译为hyperapp.h可以调用的代码。\n\n但是JSX并不是Hyperapp所必需的，可以直接使用hyperapp.h的api来直接编写组件，省去编译JSX的步骤：\n\n`Javascript\n\n// 直接用 h 来编写\nconst view = (state, actions) =&gt;\n  h(&quot;div&quot;, {}, [\n    h(&quot;h1&quot;, {}, state.count),\n    h(&quot;button&quot;, { onclick: () =&gt; actions.down(1) }, &quot;-&quot;),\n    h(&quot;button&quot;, { onclick: () =&gt; actions.up(1) }, &quot;+&quot;)\n  ])\n`\n\n3. 架构\n\nHyperapp编写的应用由三部分构成：state、action和view\n\n在程序初始化完成后，整个app会处于一个持续的循环执行里。通过用户或者外部事件产生的action来更新state，用virtual dom来展示view层的改动。可以把action当作一个通知Hyperapp更新状态重绘view的信号，当action处理完后，用户会看到新的状态(state)。\n\n3.1 State\n\nState是一个扁平对象，存储app的所有动态数据，用来描述app的状态。State在程序创建后不能直接修改，只能通过Action来更新。\n\nJavascript\nconst state = {\n  count: 0\n}\n\nState可以允许嵌套：\n\nJavascript\nconst state = {\n  top: {\n    count: 0\n  },\n  bottom: {\n    count: 0\n  }\n}\n\n\n3.2 Actions\n\n改变State的唯一方式是通过Action。Action是一个一元函数：接收一个参数，参数可以是任何类型；action通过返回部分state来更新当前state，新的state是action返回的部分state和当前state的组合。\n\nJavascript\nconst actions = {\n  setValue: value =&gt; ({ value })\n}\n\n\nAction还可以返回一个函数，函数接收当前state和action为参数，返回部分state:\n\nJavascript\nconst actions = {\n  setValue: value =&gt; (state, actions) =&gt; ({value: state.count - count})\n}\n\n\n3.2.1 异步Action\n\nAction用于处理边际效应（比如：写数据到数据库、发送一个请求到服务器，等等）并不是每次都需要返回一个值。你可以在一个action里或者回调函数里调用另外一个action。当Action返回Promise、undefined或者null时，不会触发视图重绘或状态更新。\n\nJavascript\nconst actions = {\n  upLater: value =&gt; (state, actions) =&gt; {\n    setTimeout(actions.up, 1000, value)\n  },\n  up: value =&gt; state =&gt; ({ count: state.count + value })\n}\n\n\nAction可以是一个async异步函数。因为async函数返回一个Promise而不是部分state，这时候需要调用另外一个action来更新state。\n\nJavascript\nconst actions = {\n  upLater: () =&gt; async (state, actions) =&gt; {\n    await new Promise(done =&gt; setTimeout(done, 1000))\n    actions.up(10)\n  },\n  up: value =&gt; state =&gt; ({ count: state.count + value })\n}\n\n\n3.2.2 嵌套的Action\n\nAction可以在命名空间里嵌套。更新深度嵌套的state就像在同样路径下声明一个action来更新部分state一样简单。\n\n`Javascript\nconst state = {\n  counter: {\n    count: 0\n  }\n}\n\nconst actions = {\n  counter: {\n    down: value =&gt; state =&gt; ({ count: state.count - value }),\n    up: value =&gt; state =&gt; ({ count: state.count + value })\n  }\n}\n`\n\n3.2.3 操作性\n\napp函数返回一个包含action的对象，可以用来更新state。暴露这个对象到外部可以方便的和其他程序或框架交互、订阅全局事件、监听鼠标或键盘输入，等等。\n\n`Javascript\nconst main = app(state, actions, view, document.body)\n\nsetInterval(main.up, 250, 1)\nsetInterval(main.down, 500, 1)\n`\n\n4. View\n\n当state改变时，view函数被执行；view函数返回一个js对象，被称作virtual dom，Hyperapp根据virtual dom来更新实际的DOM节点。\n\n`Javascript\nimport { h } from &quot;hyperapp&quot;\n\nexport const view = (state, actions) =&gt;\n  h(&quot;div&quot;, {}, [\n    h(&quot;h1&quot;, {}, state.count),\n    h(&quot;button&quot;, { onclick: () =&gt; actions.down(1) }, &quot;-&quot;),\n    h(&quot;button&quot;, { onclick: () =&gt; actions.up(1) }, &quot;+&quot;)\n  ])\n`\n\n4.1 Virtual DOM\n\nVirtual DOM使用一个树结构的js对象来描述真实DOM节点，具体形式如下：\n\nJavascript\n{\n  nodeName: &quot;div&quot;,\n  attributes: {},\n  children: [\n    {\n      nodeName: &quot;h1&quot;,\n      attributes: {},\n      children: [0]\n    },\n    {\n      nodeName: &quot;button&quot;,\n      attributes: { ... },\n      children: [&quot;-&quot;]\n    },\n    {\n      nodeName:   &quot;button&quot;,\n      attributes: { ... },\n      children: [&quot;+&quot;]\n    }\n  ]\n}\n\n\n以上便是Hyperapp的概要，在项目使用中，由于hyperapp代码短小精炼，更易于调试和扩展，推荐感兴趣的同学试用。","readingtime":11,"url":"/cates/Frontend/post/2018-04-08/hyperapp","dirs":["js"],"relatives":[{"url":"/cates/Frontend/post/2018-04-03/Here_are_examples_of_everything_new_in_ECMAScript_2016_2017_and_2018","title":"ES2016, 2017和2018到底有哪些新东西？"},{"url":"/cates/Frontend/post/2018-03-10/JavaScript_Modules_Worth_Using","title":"那些值得一用的JS库"}]}],"tag":"frontend"}}