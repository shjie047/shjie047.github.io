{"path":"cates/Backend/post/2018-04-06/java8-date-time-api","templateID":2,"sharedPropsHashes":{"tags":"Zpc8p0"},"localProps":{"post":{"title":"Java8 Date Time API","iso8601Date":"2018-04-06T08:39:10+08:00","basename":"java8-date-time-api","cover":"https://coding.net/u/shjie047/p/images/git/raw/master/stock-photo-189436803.jpg","tags":["Backend","Java","Java8","Translate"],"date":"2018-04-06","cate":"Backend","summary":"原文地址  \n\n简介\n\nJava8 带来了处理日期和时间需要的方式。几乎所有人都有使用Java Date 痛苦的经历。有很多人因此切换到了Joda Time，但是Java8现在有了更清晰，更可扩展的API。在我们学习API钱，先了解一下日期和时间的概念。Java日期遵循公历规则。表示时间和日期的类放在java.time包中。在这个包里比较重要的API有：  -  java.time.Period: 表示日期时期时间中的日期。表示日期部分的，年、月、日。例如：1年，两个月，5天。\n  -  java.time.Duration: 表示日期时间中的时间。 表示时间的，秒，纳秒。例如：5秒。\n  -  java.time.Instant: 表示时间线的一瞬间。保存的是UNIX时间戳的秒数，同时有另一个字段保存纳秒。\n  -  java.time.LocalDate: 保存日期时间中的日期，用年-月-日表示。不包含时区，是不可变类。\n  -  java.time.LocalTime: 保存日期时间中的时间，不包含时区。\n  -  java.time.LocalDateTime: 保存LocalDate和LocalTime，不包含时区。\n  -  java.time.ZoneDateTime: 保存LocalDateTIme，使用ZoneOffset保存时区信息。可以访问ZoneRule来转换本地时间。\n  -  java.time.ZoneOffset: 保存时区相对于UTC的位移，时区信息保存在ZoneId中。\n  -  java.time.OffsetDateTime: 通过位移来表示本地时间。这个类不包含时区规则。    \n\n创建本地日期\n\nJava\nInstant now = Instant.now();\n//2014-09-20T14:32:33.646Z\n\n\n这个语句创建了一个新的时间实例。这个实例没有时区信息，如果打印这个实例将会打印UTC时间。  \n\n打印Unix时间戳\n\nJava\nSystem.out.Println(now.getEpochSecond());\n// prints 1411137153\n\nUnix时间戳是从1970-01-01T00:00:00Z开始的。\n\nInstant 加时间\n\nJava\nInstant tomorrow = now.plus(1, ChronoUnit.DAYS);\n// prints 2014-09-20T14:32:33.646Z\n\n这个函数允许添加时间间隔。时间间隔可以是：NANOS, MICROS, MILLIS, SECONDS, MINUTES, HOURS, HALF_DAYS, DAYS。\n\nInstant 减时间\n\nJava\nInstant yesterday = now.minus(1,ChronoUnit.HALF_DAYS);\n// prints 2014-09-20T03:38:33.860Z\n\n这个minus函数允许从Instant中减时间，时间间隔同plus。\n\n对比两个Instant\n\nJava\nSystem.out.println(now.compareTo(tomorrow)); // prints -1\n\n对比函数可以比较两个日期，如果参数在比较的Instant之后则返回-1，之前则返回1。\n\n检查Instant是否在另一个Instant之后\n\nJava\nSystem.out.println(now.isAfter(yesterday));// prints true\n\n\n创建LocalDateTime\n\nJava\nLocalDateTime localDateTime = LocalDateTime.now();\nSystem.out.println(localDateTime); // prints 2014-09-28T13:01:40.556\n\n注意，这个得到的是本地时区的时间\n\n将LocalDateTime转换成其他时区时间\n\nJava\nSystem.out.println(localDateTime.atZone(ZoneId.of(&quot;America/New_York&quot;)));\n// prints 2014-09-28T13:07:31.207-04:00[America/New_York]\n\n这个将会创建一个新的ZonedDateTime\n\n从DateTime中获取星期\n\nJava\nSystem.out.println(DayOfWeek.from(localDateTime));\n// prints SUNDAY.\n// (yes, i am working on a sunday :-( ) ))\n\n\n从DateTime中获取一年中第几天\n\nJava\nSystem.out.println(localDateTime.get(ChronoField.DAY_OF_YEAR));\n// prints 271\n\n其他的可以是MINUTEOFHOUR, MINUTEOFDAY, HOUROFAMPM, HOUROFDAY, AMPMOFDAY, DAYOFWEEK, DAYOFMONTH, DAYOFYEAR, MONTHOFYEAR, YEAR, OFFSET_SECONDS（UTC时间的位移）\n\n从LocalDateTime中获取LocalDate\n\nJava\nSystem.out.println(localDateTime.toLocalDate());\n// prints 2014-09-29\n\n\n从LocalDateTIme中获取LocalTime\n\nJava\nSystem.out.println(localDateTime.toLocalTime());\n// prints 22:26:30.146\n\n\n通过年月日时分创建LocalDateTime\n\nJava\nSystem.out.println(LocalDateTime.of(2014, 10, 1, 10, 0));\n// prints 2014-10-01T10:00\n\n\n通过解析字符串创建LocalDateTime\n\nJava\nLocalDateTime parsedLocalDateTime = LocalDateTime.parse(&quot;2014-01-01T11:00&quot;);\n\n\n创建另一个时区的LocalDateTime\n\nJava\nSystem.out.println(LocalDateTime.now(ZoneId.of(&quot;UTC&quot;)));\n// prints 2014-09-29T17:07:26.653 (the local timezone in UTC)\n\n\n通过Instant和时区创建LocalDateTime\n\nJava\nInstant now = Instant.now();\nSystem.out.println(LocalDateTime.ofInstant(now, ZoneId.of(&quot;UTC&quot;)));\n//2014-09-29T17:09:19.644\n\n\n创建ZonedDateTime\n\nJava\nZonedDateTime zonedDateTime = ZonedDateTime.now();\n//2014-09-29T22:41:24.908+05:30[Asia/Calcutta]\n\n\n获取两个不同时间在不同单位之差\n\n\nSystem.out.println(zonedDateTime.until(ZonedDateTime.parse(&quot;2014-09-29T22:41:00-10:00&quot;), ChronoUnit.HOURS));\n// prints the difference between the current zonedDateTime and the zonedatetime parsed from the above string\n\n\n获取当前ZoneDateTime的位移\n\nJava\nSystem.out.println(zonedDateTime.getOffset());\n// prints the offset e.g. +10:00\n\n\n使用DateTimeFormatter解析或者格式化时间\n\nJava\nSystem.out.println(zonedDateTime.format(DateTimeFormatter.ofPattern(&quot;&#39;The&#39; dd &#39;day of&#39; MMM &#39;in year&#39; YYYY &#39;and zone is&#39; z&quot;)));\n// prints The 29 day of Sep in year 2014 and zone is IST\n\n\n将ZoneDateTime更改时区\n\n有两种方式可以完成这个任务，第一种不更改Instant更改时区，第二种更改时区不更改LocalTime\n`Java\n        System.out.println(zonedDateTime);\n        System.out.println(zonedDateTime.toInstant());\n        System.out.println(zonedDateTime.withZoneSameInstant(ZoneId.of(&quot;America/Chicago&quot;)));\n        System.out.println(zonedDateTime.withZoneSameLocal(ZoneId.of(&quot;America/Chicago&quot;)));\n\n    // prints \n    //System.out.println(zonedDateTime);\n    //System.out.println(zonedDateTime.toInstant());\n    //System.out.println(zonedDateTime.withZoneSameInstant(ZoneId.of(&quot;America/Chicago&quot;)));\n    //System.out.println(zonedDateTime.withZoneSameLocal(ZoneId.of(&quot;America/Chicago&quot;)));\n\n`","readingtime":9,"url":"/cates/Backend/post/2018-04-06/java8-date-time-api","dirs":["java"],"relatives":[{"url":"/cates/Backend/post/2017-03-25/cpu-load-high","title":"Linux 如何查找Java 程序CPU负载过高"}],"body":"\n\n[原文地址](http://www.studytrails.com/java/java8/java8_date_and_time/)  \n#### 简介\nJava8 带来了处理日期和时间需要的方式。几乎所有人都有使用Java Date 痛苦的经历。有很多人因此切换到了Joda Time，但是Java8现在有了更清晰，更可扩展的API。在我们学习API钱，先了解一下日期和时间的概念。Java日期遵循[公历](http://en.wikipedia.org/wiki/Gregorian_calendar)规则。表示时间和日期的类放在`java.time`包中。在这个包里比较重要的API有：  \n  -  **java.time.Period**: 表示日期时期时间中的日期。表示日期部分的，年、月、日。例如：1年，两个月，5天。\n  -  **java.time.Duration**: 表示日期时间中的时间。 表示时间的，秒，纳秒。例如：5秒。\n  -  **java.time.Instant**: 表示时间线的一瞬间。保存的是UNIX时间戳的秒数，同时有另一个字段保存纳秒。\n  -  **java.time.LocalDate**: 保存日期时间中的日期，用年-月-日表示。不包含时区，是不可变类。\n  -  **java.time.LocalTime**: 保存日期时间中的时间，不包含时区。\n  -  **java.time.LocalDateTime**: 保存LocalDate和LocalTime，不包含时区。\n  -  **java.time.ZoneDateTime**: 保存LocalDateTIme，使用`ZoneOffset`保存时区信息。可以访问ZoneRule来转换本地时间。\n  -  **java.time.ZoneOffset**: 保存时区相对于UTC的位移，时区信息保存在ZoneId中。\n  -  **java.time.OffsetDateTime**: 通过位移来表示本地时间。这个类不包含时区规则。    \n\n##### 创建本地日期\n\n```Java\nInstant now = Instant.now();\n//2014-09-20T14:32:33.646Z\n```\n\n这个语句创建了一个新的时间实例。这个实例没有时区信息，如果打印这个实例将会打印UTC时间。  \n##### 打印Unix时间戳\n```Java\nSystem.out.Println(now.getEpochSecond());\n// prints 1411137153\n```\nUnix时间戳是从1970-01-01T00:00:00Z开始的。\n#####  Instant 加时间\n```Java\nInstant tomorrow = now.plus(1, ChronoUnit.DAYS);\n// prints 2014-09-20T14:32:33.646Z\n```\n这个函数允许添加时间间隔。时间间隔可以是：NANOS, MICROS, MILLIS, SECONDS, MINUTES, HOURS, HALF_DAYS, DAYS。\n##### Instant 减时间\n```Java\nInstant yesterday = now.minus(1,ChronoUnit.HALF_DAYS);\n// prints 2014-09-20T03:38:33.860Z\n```\n这个minus函数允许从Instant中减时间，时间间隔同plus。\n##### 对比两个Instant\n```Java\nSystem.out.println(now.compareTo(tomorrow)); // prints -1\n```\n对比函数可以比较两个日期，如果参数在比较的Instant之后则返回-1，之前则返回1。\n##### 检查Instant是否在另一个Instant之后\n```Java\nSystem.out.println(now.isAfter(yesterday));// prints true\n```\n##### 创建LocalDateTime\n```Java\nLocalDateTime localDateTime = LocalDateTime.now();\nSystem.out.println(localDateTime); // prints 2014-09-28T13:01:40.556\n```\n注意，这个得到的是本地时区的时间\n##### 将LocalDateTime转换成其他时区时间\n```Java\nSystem.out.println(localDateTime.atZone(ZoneId.of(\"America/New_York\")));\n// prints 2014-09-28T13:07:31.207-04:00[America/New_York]\n```\n这个将会创建一个新的ZonedDateTime\n##### 从DateTime中获取星期\n```Java\nSystem.out.println(DayOfWeek.from(localDateTime));\n// prints SUNDAY.\n// (yes, i am working on a sunday :-( ) ))\n```\n##### 从DateTime中获取一年中第几天\n```Java\nSystem.out.println(localDateTime.get(ChronoField.DAY_OF_YEAR));\n// prints 271\n```\n其他的可以是MINUTE_OF_HOUR, MINUTE_OF_DAY, HOUR_OF_AMPM, HOUR_OF_DAY, AMPM_OF_DAY, DAY_OF_WEEK, DAY_OF_MONTH, DAY_OF_YEAR, MONTH_OF_YEAR, YEAR, OFFSET_SECONDS（UTC时间的位移）\n##### 从LocalDateTime中获取LocalDate\n```Java\nSystem.out.println(localDateTime.toLocalDate());\n// prints 2014-09-29\n```\n##### 从LocalDateTIme中获取LocalTime\n```Java\nSystem.out.println(localDateTime.toLocalTime());\n// prints 22:26:30.146\n```\n##### 通过年月日时分创建LocalDateTime\n```Java\nSystem.out.println(LocalDateTime.of(2014, 10, 1, 10, 0));\n// prints 2014-10-01T10:00\n```\n##### 通过解析字符串创建LocalDateTime\n```Java\nLocalDateTime parsedLocalDateTime = LocalDateTime.parse(\"2014-01-01T11:00\");\n```\n##### 创建另一个时区的LocalDateTime\n```Java\nSystem.out.println(LocalDateTime.now(ZoneId.of(\"UTC\")));\n// prints 2014-09-29T17:07:26.653 (the local timezone in UTC)\n```\n##### 通过Instant和时区创建LocalDateTime\n```Java\nInstant now = Instant.now();\nSystem.out.println(LocalDateTime.ofInstant(now, ZoneId.of(\"UTC\")));\n//2014-09-29T17:09:19.644\n```\n##### 创建ZonedDateTime\n```Java\nZonedDateTime zonedDateTime = ZonedDateTime.now();\n//2014-09-29T22:41:24.908+05:30[Asia/Calcutta]\n```\n##### 获取两个不同时间在不同单位之差\n```\nSystem.out.println(zonedDateTime.until(ZonedDateTime.parse(\"2014-09-29T22:41:00-10:00\"), ChronoUnit.HOURS));\n// prints the difference between the current zonedDateTime and the zonedatetime parsed from the above string\n```\n##### 获取当前ZoneDateTime的位移\n```Java\nSystem.out.println(zonedDateTime.getOffset());\n// prints the offset e.g. +10:00\n```\n##### 使用DateTimeFormatter解析或者格式化时间\n\n```Java\nSystem.out.println(zonedDateTime.format(DateTimeFormatter.ofPattern(\"'The' dd 'day of' MMM 'in year' YYYY 'and zone is' z\")));\n// prints The 29 day of Sep in year 2014 and zone is IST\n```\n##### 将ZoneDateTime更改时区\n有两种方式可以完成这个任务，第一种不更改Instant更改时区，第二种更改时区不更改LocalTime\n```Java\n        System.out.println(zonedDateTime);\n        System.out.println(zonedDateTime.toInstant());\n        System.out.println(zonedDateTime.withZoneSameInstant(ZoneId.of(\"America/Chicago\")));\n        System.out.println(zonedDateTime.withZoneSameLocal(ZoneId.of(\"America/Chicago\")));\n        \n        // prints \n        //System.out.println(zonedDateTime);\n        //System.out.println(zonedDateTime.toInstant());\n        //System.out.println(zonedDateTime.withZoneSameInstant(ZoneId.of(\"America/Chicago\")));\n        //System.out.println(zonedDateTime.withZoneSameLocal(ZoneId.of(\"America/Chicago\")));\n```\n\n\n"}}}