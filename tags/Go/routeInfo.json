{"path":"tags/Go","templateID":5,"sharedPropsHashes":{"tags":"1C8cqm"},"localProps":{"posts":[{"title":"Go Web 架构","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-251622641.jpg","iso8601Date":"2015-11-11T03:01:21+08:00","basename":"Go-Web-architecture","tags":["Go","Architecture","Translate","Backend","Web"],"date":"2015-11-11","cate":"backend","summary":"原文地址\n\n使用Golang来创建Web项目是一件很麻烦的事情。如果你使用Rails，那么你可能不会有这个感触。我在Refer Madness中使用了下面这个架构。\n\nbash\n-public/\n-views/\n-models/\n-utils/\n-controllers/\n-web/\n-main.go\n\n\n我将打破这个体系，介绍各个目录的作用。在每个目录下，文件只能访问其同级或者上一级。这就意味着utils只能访问他自己和models，web只能访问它自己，controllers，utils，models。models只能访问它自己。我这么做是为了让层次清晰，防止出现递归依赖。现在来分析每一个目录，文件的作用。\n\nmain.go\n\nmain.go是创建依赖，获取环境变量，启动服务的主要文件。下面是它的实例。\n\n`Go\npackage main\n\nimport (\n  &quot;github.com/larryprice/refermadness/utils&quot;\n  &quot;github.com/larryprice/refermadness/web&quot;\n  &quot;github.com/stretchr/graceful&quot;\n  &quot;os&quot;\n)\n\nfunc main() {\n  isDevelopment := os.Getenv(&quot;ENVIRONMENT&quot;) == &quot;development&quot;\n  dbURL := os.Getenv(&quot;MONGOLABURI&quot;)\n  if isDevelopment {\n    dbURL = os.Getenv(&quot;DBPORT27017TCP_ADDR&quot;)\n  }\n\n  dbAccessor := utils.NewDatabaseAccessor(dbURL, os.Getenv(&quot;DATABASE_NAME&quot;), 0)\n  cuAccessor := utils.NewCurrentUserAccessor(1)\n  s := web.NewServer(dbAccessor, cuAccessor, os.Getenv(&quot;GOOGLEOAUTH2CLIENTID&quot;),\n    os.Getenv(&quot;GOOGLEOAUTH2CLIENTSECRET&quot;), os.Getenv(&quot;SESSIONSECRET&quot;),\n    isDevelopment, os.Getenv(&quot;GOOGLEANALYTICS_KEY&quot;))\n\n  port := os.Getenv(&quot;PORT&quot;)\n  if port == &quot;&quot; {\n    port = &quot;3000&quot;\n  }\n\n  graceful.Run(&quot;:&quot;+port, 0, s)\n}\n\n`\n\n因为main.go实在最低的层级，所以它可以访问所有的目录：在这个例子里是web和utils。在这里获取了所有的环境变量并把它们注入到合适的地方。在main.go中创建了服务器，注入依赖，并且在配置的端口启动服务器。\n\nweb\n\nweb目录下是主要的服务代码，同时也包括了中间件代码。下面是web目录的内部结构：\n\nbash\n-web/\n|-middleware/\n|-server.go\n\n\nserver.go包含了web server的定义。这个web server 创建了所有的web controller并且给negroni添加了中间件。下面是他的例子：\n\n`Go\npackage web\n\nimport (\n  &quot;github.com/codegangsta/negroni&quot;\n  &quot;github.com/goincremental/negroni-sessions&quot;\n  &quot;github.com/goincremental/negroni-sessions/cookiestore&quot;\n  &quot;github.com/gorilla/mux&quot;\n  &quot;github.com/larryprice/refermadness/controllers&quot;\n  &quot;github.com/larryprice/refermadness/utils&quot;\n  &quot;github.com/larryprice/refermadness/web/middleware&quot;\n  &quot;github.com/unrolled/secure&quot;\n  &quot;gopkg.in/unrolled/render.v1&quot;\n  &quot;html/template&quot;\n  &quot;net/http&quot;\n)\n\ntype Server struct {\n  *negroni.Negroni\n}\n\nfunc NewServer(dba utils.DatabaseAccessor, cua utils.CurrentUserAccessor, clientID, clientSecret,\n  sessionSecret string, isDevelopment bool, gaKey string) *Server {\n  s := Server{negroni.Classic()}\n  session := utils.NewSessionManager()\n  basePage := utils.NewBasePageCreator(cua, gaKey)\n  renderer := render.New()\n\n  router := mux.NewRouter()\n\n  // ...\n\n  accountController := controllers.NewAccountController(clientID, clientSecret, isDevelopment, session, dba, cua, basePage, renderer)\n  accountController.Register(router)\n\n  // ...\n\n  s.Use(sessions.Sessions(&quot;refermadness&quot;, cookiestore.New([]byte(sessionSecret))))\n  s.Use(middleware.NewAuthenticator(dba, session, cua).Middleware())\n  s.UseHandler(router)\n  return &amp;s\n}\n`\n\nServer结构体是一个negroni.Negroni的web server，在这个文件里有对utils和其他第三方包的引用，创建了一个router，一些controller，并且将controller注册到当前router。同时也引入了必要的中间件。说到中间件，下面是它的代码：\n\n`Go\npackage middleware\n\nimport (\n  &quot;github.com/codegangsta/negroni&quot;\n  &quot;github.com/larryprice/refermadness/utils&quot;\n  &quot;net/http&quot;\n)\n\ntype Database struct {\n  da utils.DatabaseAccessor\n}\n\nfunc NewDatabase(da utils.DatabaseAccessor) *Database {\n  return &amp;Database{da}\n}\n\nfunc (d Database) Middleware() negroni.HandlerFunc {\n  return func(rw http.ResponseWriter, r http.Request, next http.HandlerFunc) {\n    reqSession := d.da.Clone()\n    defer reqSession.Close()\n    d.da.Set(r, reqSession)\n    next(rw, r)\n  }\n}\n`\n\n这个是通过HTTP router访问数据库session的标注中间件。基本文件是从Brian Gesiak’s blog post on RESTful Go中得到，将其修改为适合我的文件。\n\ncontrollers/\n\n这里的controller与Rails里的controller的概念很像。Controller注册自己的router，设置自己的函数调用。一个简短的例子如下：\n\n`Go\npackage controllers\n\nimport (\n  &quot;encoding/json&quot;\n  &quot;errors&quot;\n  &quot;github.com/gorilla/mux&quot;\n  &quot;github.com/larryprice/refermadness/models&quot;\n  &quot;github.com/larryprice/refermadness/utils&quot;\n  &quot;gopkg.in/mgo.v2/bson&quot;\n  &quot;gopkg.in/unrolled/render.v1&quot;\n  &quot;html/template&quot;\n  &quot;net/http&quot;\n  &quot;strings&quot;\n)\n\ntype ServiceControllerImpl struct {\n  currentUser utils.CurrentUserAccessor\n  basePage    utils.BasePageCreator\n  renderer    *render.Render\n  database    utils.DatabaseAccessor\n}\n\nfunc NewServiceController(currentUser utils.CurrentUserAccessor, basePage utils.BasePageCreator,\n  renderer render.Render, database utils.DatabaseAccessor) ServiceControllerImpl {\n  return &amp;ServiceControllerImpl{\n    currentUser: currentUser,\n    basePage:    basePage,\n    renderer:    renderer,\n    database:    database,\n  }\n}\n\nfunc (sc ServiceControllerImpl) Register(router mux.Router) {\n  router.HandleFunc(&quot;/service/{id}&quot;, sc.single)\n  // ...\n}\n\n// ...\n\ntype serviceResult struct {\n  models.Service\n  RandomCode models.ReferralCode\n  UserCode   *models.ReferralCode\n}\n\ntype servicePage struct {\n  utils.BasePage\n  ResultString string\n}\n\nfunc (sc ServiceControllerImpl) single(w http.ResponseWriter, r http.Request) {\n  data, err := sc.get(w, r)\n\n  if len(r.Header[&quot;Content-Type&quot;]) == 1 &amp;&amp; strings.Contains(r.Header[&quot;Content-Type&quot;][0], &quot;application/json&quot;) {\n    if err != nil {\n      sc.renderer.JSON(w, http.StatusBadRequest, map[string]string{\n        &quot;error&quot;: err.Error(),\n      })\n      return\n    }\n    sc.renderer.JSON(w, http.StatusOK, data)\n    return\n  } else if err != nil {\n    http.Error(w, err.Error(), http.StatusBadRequest)\n  }\n\n  resultString,  := json.Marshal(data)\n  t,  := template.ParseFiles(&quot;views/layout.html&quot;, &quot;views/service.html&quot;)\n  t.Execute(w, servicePage{sc.basePage.Get(r), string(resultString)})\n}\n`\n\nutils/\n\n在utils目录下的文件提供了一些底层功能用来支持其他的代码。在这个例子中，主要是定义一个结构体来访问请求的上下文，处理session，定义一个特别的页面来继承。下面是通过访问上下文设置用户的例子：\n\n`Go\npackage utils\n\nimport (\n  &quot;github.com/gorilla/context&quot;\n  &quot;github.com/larryprice/refermadness/models&quot;\n  &quot;net/http&quot;\n)\n\ntype CurrentUserAccessor struct {\n  key int\n}\n\nfunc NewCurrentUserAccessor(key int) *CurrentUserAccessor {\n  return &amp;CurrentUserAccessor{key}\n}\n\nfunc (cua CurrentUserAccessor) Set(r http.Request, user *models.User) {\n  context.Set(r, cua.key, user)\n}\n\nfunc (cua CurrentUserAccessor) Clear(r http.Request) {\n  context.Delete(r, cua.key)\n}\n\nfunc (cua CurrentUserAccessor) Get(r http.Request) models.User {\n  if rv := context.Get(r, cua.key); rv != nil {\n    return rv.(models.User)\n  }\n  return nil\n}\n`\n\nmodels/\n\nmodel 是为了描述数据库中的数据的数据结构。在这个例子中使用model来访问数据库，创建一个空的model，然后通过查询数据库为其赋值。下面是一个例子：\n\n`Go\npackage models\n\nimport (\n  &quot;gopkg.in/mgo.v2&quot;\n  &quot;gopkg.in/mgo.v2/bson&quot;\n  &quot;strings&quot;\n  &quot;time&quot;\n)\n\ntype Service struct {\n  // identification information\n  ID          bson.ObjectId bson:&quot;_id&quot;\n  Name        string        bson:&quot;name&quot;\n  Description string        bson:&quot;description&quot;\n  URL         string        bson:&quot;url&quot;\n  Search      string        bson:&quot;search&quot;\n}\n\nfunc NewService(name, description, url string, creatorID bson.ObjectId) *Service {\n  url = strings.TrimPrefix(strings.TrimPrefix(url, &quot;http://&quot;), &quot;https://&quot;)\n  return &amp;Service{\n    ID:            bson.NewObjectId(),\n    Name:          name,\n    URL:           url,\n    Description:   description,\n    Search:        strings.ToLower(name) + &quot;;&quot; + strings.ToLower(description) + &quot;;&quot; + strings.ToLower(url),\n  }\n}\n\nfunc (s Service) Save(db mgo.Database) error {\n  _, err := s.coll(db).UpsertId(s.ID, s)\n  return err\n}\n\nfunc (s Service) FindByID(id bson.ObjectId, db mgo.Database) error {\n  return s.coll(db).FindId(id).One(s)\n}\n\nfunc (Service) coll(db mgo.Database) *mgo.Collection {\n  return db.C(&quot;service&quot;)\n}\n\ntype Services []Service\n\nfunc (s Services) FindByIDs(ids []bson.ObjectId, db mgo.Database) error {\n  return s.coll(db).Find(bson.M{&quot;_id&quot;: bson.M{&quot;$in&quot;: ids}}).Sort(&quot;name&quot;).All(s)\n}\n\nfunc (Services) coll(db mgo.Database) *mgo.Collection {\n  return db.C(&quot;service&quot;)\n}\n\n`\n\nviews/\n\n将Golang的模板文件放到views目录下。这样，不管用什么样的模板引擎都可以直接放到views下。\n\npublic/\n\n跟以前一样，这个文件都是放公开的文件的，例如css,img,scripts。\n\n如何运行\n\n毫无疑问，我最喜欢的就是docker，因此我将使用他来运行这个应用。如果不使用docker，那么可以将文件放到$GOPATH/src/github.com/larryprice/refermadness,运行go get来获取所有的依赖，然后运行 go run main.go或者go build; ./refermadness运行程序。如果你也喜欢使用docker，那么可以直接通过Dockerfile来运行。\n\n`bash\nFROM golang:1.4\n\nRUN go get github.com/codegangsta/gin\n\nADD . /go/src/github.com/larryprice/refermadness\nWORKDIR /go/src/github.com/larryprice/refermadness\nRUN go get\n`\n\n同时我也很喜欢compose，所以我也通过compose 文件来运行所有的应用。我用了JSC ，SASS和mongodb，所以一下是我的docker-compose.yml文件。\n\nGo\nmain:\n  build: .\n  command: gin run\n  env_file: .env\n  volumes:\n    - ./:/go/src/github.com/larryprice/refermadness\n  working_dir: /go/src/github.com/larryprice/refermadness\n  ports:\n    - &quot;3000:3000&quot;\n  links:\n    - db\nsass:\n  image: larryprice/sass\n  volumes:\n    - ./public/css:/src\njsx:\n  image: larryprice/jsx\n  volumes:\n    - ./public/scripts:/src\ndb:\n  image: mongo:3.0\n  command: mongod --smallfiles --quiet --logpath=/dev/null\n  volumes_from:\n    - dbvolume\ndbvolume:\n  image: busybox:ubuntu-14.04\n  volumes:\n    - /data/db\n\n\n然后运行docker-compose up来运行所有的容器并启动服务器。","readingtime":19,"url":"/cates/backend/post/2015-11-11/Go-Web-architecture","dirs":["go"],"relatives":[{"url":"/cates/backend/post/2015-11-12/HTTP-2-And-GO","title":"HTTP/2 和GO"},{"url":"/cates/backend/post/2015-11-15/create-a-homepage-for-Go-Web-App","title":"为Go Web App 创建一个主页面"},{"url":"/cates/backend/post/2015-11-12/develop-HTTP-middleware-using-Go","title":"使用Go开发HTTP中间件"},{"url":"/cates/backend/post/2015-11-13/http-Handler-And-Go-error-handle","title":"http.Handler 与Go的错误处理"}]},{"title":"HTTP/2 和GO","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-252006883.jpg","iso8601Date":"2015-11-12T19:39:21+08:00","basename":"HTTP-2-And-GO","tags":["Http","HTTP/2","Translate","Go","Backend"],"date":"2015-11-12","cate":"backend","summary":"原文地址\n\nHTTP/2是一个添加了一些新功能的HTTP的新版本，这些功能包括连接复用，首部压缩。再Go的标准库中暂时还没有HTTP/2的实现，但是现在有很多正在开发的库可以用来在Go中实现HTTP/2的server和client。\n\nBrad Fitzpatrick实现了一个golang.org/x/net/http2的库，这个库甚至最终会加入到标准库中，不过他现在正在开发，所以在其他的库中。因为他现在的开发很活跃，所有情况因人而异，但是如果你想实现HTTP/2的服务器，仍然可以使用这个库。\n\n创建HTTP/2服务器\n\n使用http2的库写一个服务器是很简单的。http2库和标准库的http包集成在一起，需要调用http2.ConfigureServer()来配置一个普通http使用HTTP/2协议。如果需要通过浏览器访问或者降级到HTTP 1.x 协议，那么你需要设置TLS 加密。虽然加密不是必须的，但是现在还没有浏览器支持非加密的HTTP/2协议。\n\n`Go\npackage main\n\nimport (\n    &quot;log&quot;\n    &quot;net/http&quot;\n    &quot;os&quot;\n\n&quot;golang.org/x/net/http2&quot;\n\n)\n\nfunc main() {\n    cwd, err := os.Getwd()\n    if err != nil {\n        log.Fatal(err)\n    }\n\nsrv := &amp;http.Server{\n    Addr:    &quot;:8000&quot;, // Normally &quot;:443&quot;\n    Handler: http.FileServer(http.Dir(cwd)),\n}\nhttp2.ConfigureServer(srv, &amp;http2.Server{})\nlog.Fatal(srv.ListenAndServeTLS(&quot;server.crt&quot;, &quot;server.key&quot;))\n\n}\n`\n\n创建HTTP/2 客户端\n\n现在使用http2的库创建客户端很hacky。虽然它会输出很多调试日志，但是对于大多数情况下运行的很好。可以使用http2.Transport对象，将他传给http包的client。\n\n`Go\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;io/ioutil&quot;\n    &quot;log&quot;\n    &quot;net/http&quot;\n\n&quot;golang.org/x/net/http2&quot;\n\n)\n\nfunc main() {\n    client := http.Client{\n        // InsecureTLSDial is temporary and will likely be\n        // replaced by a different API later.\n        Transport: &amp;http2.Transport{InsecureTLSDial: true},\n    }\n\nresp, err := client.Get(&quot;https://localhost:8000/&quot;)\nif err != nil {\n    log.Fatal(err)\n}\n\nbody, err := ioutil.ReadAll(resp.Body)\nif err != nil {\n    log.Fatal(err)\n}\n\nfmt.Println(string(body))\n\n}\n`\n\n更多阅读\n\n如果你对HTTP/2协议感兴趣，那么可以参考HTTP/2 主页，这个页面有很多其他资料的连接还有其他语言的实现。\n\n如果你想知道HTTP/2的服务端和客户端是如何实现的，那么Jxck&#39;s http2 implementation的实现就很值得一读。Jxck通过对标准的HTTP库的TLSNextProto设置一个钩子来实现的。你可以再这里阅读一些示例。\n\ngrpc-go 库同样也有自己的服务端和客户端的实现。","readingtime":5,"url":"/cates/backend/post/2015-11-12/HTTP-2-And-GO","dirs":["go"],"relatives":[{"url":"/cates/backend/post/2015-11-11/Go-Web-architecture","title":"Go Web 架构"},{"url":"/cates/backend/post/2015-11-15/create-a-homepage-for-Go-Web-App","title":"为Go Web App 创建一个主页面"},{"url":"/cates/backend/post/2015-11-12/develop-HTTP-middleware-using-Go","title":"使用Go开发HTTP中间件"},{"url":"/cates/backend/post/2015-11-13/http-Handler-And-Go-error-handle","title":"http.Handler 与Go的错误处理"}]},{"title":"使用Go开发HTTP中间件","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-228204533.jpg","iso8601Date":"2015-11-12T20:07:49+08:00","basename":"develop-HTTP-middleware-using-Go","tags":["HTTP","Go","Middleware","Backend"],"date":"2015-11-12","cate":"backend","summary":"原文地址\n\n 再web开发的背景下，“中间件”通常意思是“包装原始应用并添加一些额外的功能的应用的一部分”。这个概念似乎总是不被人理解，但是我认为中间件非常棒。\n 首先，一个好的中间件有一个责任就是可插拔并且自足。这就意味着你可以在接口级别嵌入你的中间件他就能直接运行。它不会影响你编码方式，不是框架，仅仅是你请求处理里面的一层而已。完全没必要重写你的代码，如果你想使用中间件的一个功能，你就帮他插入到那里，如果不想使用了，就可以直接移除。\n 纵观Go语言，中间件是非常普遍的，即使在标准库中。虽然开始的时候不会那么明显，在标准库net/http中的函数StripText或者TimeoutHandler就是我们要定义和的中间件的样子，处理请求和相应的时候他们包装你的handler，并处理一些额外的步骤。\n 我最近写的Go包nosurf同样也是个中间件。我特意将他从头开始设计。在大多数情况下，你不需要在应用层担心CSRF攻击，nosurf像其他的中间件一样可以自足，并且和net/http的接口无缝衔接。\n 同样你还可以使用中间件做：\n 隐藏长度防止缓冲攻击\n 速度限制\n 屏蔽爬虫\n 提供调试信息\n 添加HSTS，X-Frame-Options头\n 从错误中恢复\n* 等等\n\n编写一个简单的中间件\n\n 我们的第一个例子是写一个只允许一个域名下的用户访问的中间件，通过HTTP的HOSTheader实现。这样的中间件可以防止主机欺骗攻击。\n\n类型的机构\n\n 首先我们定义一个结构体，叫做SingleHost\n\nGo\ntype SingleHost struct {\n    handler     http.Handler\n    allowedHost string\n}\n\n\n 它只包含两个field。\n 如果是一个可用的Host，那么我们会调用嵌入的handler。\n allowedHost 就是允许的Host。\n 因为我们将其首字母小写，因此他们只对本包可见。我们需要给它定义已给构造函数。\n\nGo\nfunc NewSingleHost(handler http.Handler, allowedHost string) *SingleHost {\n    return &amp;SingleHost{handler: handler, allowedHost: allowedHost}\n}\n\n\n请求处理\n\n 现在需要实现真正的逻辑功能了。想要实现http.Handler，我们只需要实现他的一个方法。\n\nGo\ntype Handler interface {\n        ServeHTTP(ResponseWriter, *Request)\n}\n\n\n 实现如下：\n\nGo\nfunc (s *SingleHost) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    host := r.Host\n    if host == s.allowedHost {\n        s.handler.ServeHTTP(w, r)\n    } else {\n        w.WriteHeader(403)\n    }\n}\n\n\nServeHTTP只是检查请求的Host：\n 如果Host和配置的allowed一直，那么调用handler的ServeHTTP。\n 如果不一直返回403\n对于后一种情况，不仅不会得到应答，设置不知道有这个请求。\n现在我们已经开发哈了中间件，只需要将其插入到需要的地方。\n\nGo\nsingleHosted = NewSingleHost(myHandler, &quot;example.com&quot;)\nhttp.ListenAndServe(&quot;:8080&quot;, singleHosted)\n\n\n另一种方式\n\n 我们刚刚写的那个中间件很简单，它只有15行代码。写这样的中间件，可以使用样板方法。由于Go支持函数为一等公民和闭包，并且有http.HandlerFunc包装函数，我们可以通过他创建一个中间件，而不是将其放入到一个结构体中。下面是这个中间件的写法。\n\nGo\nfunc SingleHost(handler http.Handler, allowedHost string) http.Handler {\n    ourFunc := func(w http.ResponseWriter, r *http.Request) {\n        host := r.Host\n        if host == allowedHost {\n            handler.ServeHTTP(w, r)\n        } else {\n            w.WriteHeader(403)\n        }\n    }\n    return http.HandlerFunc(ourFunc)\n}\n\n 我们定义了一个简单的函数SingleHost，它包装了Handler和允许的Host，在其内部我们实现了一个跟上面中间件类似的功能。我们内部的函数就是一个闭包，因此他可以访问外部函数的变量。最终HandlerFunc让我们可以将其变为Handler。\n 觉得是使用HandlerFunc还是自己实现一个http.Handler完全取决于你自己。对于简单的情况，一个简单的函数就完全够了。如果你的中间件越来越多，那么就可以考虑实现自己的结构并把它们分开。\n 同时标准库同时使用了两种功能。StripPrefix使用的是HandlerFunc，TimeoutHandler使用的是自定义的结构体。\n\n一个更复杂的例子\n\n 我们的SingleHost并不重要，我们只检测一个属性，要么将他传递给其他的handler，要么直接返回。然而存在这种情况，我们的程序需要对处理完进行后续处理。\n\n添加数据是简单的\n\n 如果只是想简单的添加数据，那么使用Write就可以了。\n\n`Go\ntype AppendMiddleware struct {\n    handler http.Handler\n}\n\nfunc (a AppendMiddleware) ServeHTTP(w http.ResponseWriter, r http.Request) {\n    a.handler.ServeHTTP(w, r)\n    w.Write([]byte(&quot;Middleware says hello.&quot;))\n}\n`\n\n 返回的结构肯定会包含Middleware says hello.\n\n问题\n\n 但是操作其他的数据有点困难。例如我们想要在它前面添加数据而不是后面追加。如果我们在原Handler之前调用Write，那么将会失去控制，因为第一个Write已经将他写入了。\n 通过其他方法修改原始输出，例如替换字符串，改变响应header，或者设置状态码都不会起作用，因为当handler返回的时候数据已经返回到客户端了。\n 为了实现这个功能，我们需要一个特殊的ResponseWriter，他可以想buffer一样工作，收集数据，存储以备使用和修改。然后我们将这个ResponseWriter传递给handler，而不是传递真是的RW，这样在其之前我们已经修改了它了。\n 幸运的是在标准库中有这样的一个工具。在net/http/httptest包里的ResponseRecorder能做所有我们需要的：保存状态码，一个响应header的map，将body放入byte 缓冲中。虽然它是再测试中中使用的，但是很服务我们的情况。\n\n`Go\ntype ModifierMiddleware struct {\n    handler http.Handler\n}\n\nfunc (m ModifierMiddleware) ServeHTTP(w http.ResponseWriter, r http.Request) {\n    rec := httptest.NewRecorder()\n    // passing a ResponseRecorder instead of the original RW\n    m.handler.ServeHTTP(rec, r)\n    // after this finishes, we have the response recorded\n    // and can modify it before copying it to the original RW\n\n// we copy the original headers first\nfor k, v := range rec.Header() {\n    w.Header()[k] = v\n}\n// and set an additional one\nw.Header().Set(&quot;X-We-Modified-This&quot;, &quot;Yup&quot;)\n// only then the status code, as this call writes out the headers \nw.WriteHeader(418)\n\n// The body hasn&#39;t been written (to the real RW) yet,\n// so we can prepend some data.\ndata := []byte(&quot;Middleware says hello again. &quot;)\n\n// But the Content-Length might have been set already,\n// we should modify it by adding the length\n// of our own data.\n// Ignoring the error is fine here:\n// if Content-Length is empty or otherwise invalid,\n// Atoi() will return zero,\n// which is just what we&#39;d want in that case.\nclen, _ := strconv.Atoi(r.Header.Get(&quot;Content-Length&quot;))\nclen += len(data)\nr.Header.Set(&quot;Content-Length&quot;, strconv.Itoa(clen))\n\n// finally, write out our data\nw.Write(data)\n// then write out the original body\nw.Write(rec.Body.Bytes())\n\n}\n`\n最后僵尸我们中间件的输出：\n\n`\nHTTP/1.1 418 I&#39;m a teapot\nX-We-Modified-This: Yup\nContent-Type: text/plain; charset=utf-8\nContent-Length: 37\nDate: Tue, 03 Sep 2013 18:41:39 GMT\n\nMiddleware says hello again. Success!\n`\n这样就开启了一种新的可能，包装的handler完全手控制。\n\n和其他handler分享数据\n\n 在其他例子中，中间件可能需要暴露一些信息给其他中间件或者应用本身。例如nosurf需要给其他用户访问CSRF token的权限。\n 最简单是是使用一个map，但是通常不希望这样。它将http.Request 的指针作为key，其他数据作为value。下面是nosurf的例子，Go的map非线程安全，所以要自己是实现。\n\n`Go\ntype csrfContext struct {\n    token string\n    reason error\n}\n\nvar (\n    contextMap = make(map[http.Request]csrfContext)\n    cmMutex    = new(sync.RWMutex)\n)\n`\n 数据由Token设置：\n\n`Go\nfunc Token(req *http.Request) string {\n    cmMutex.RLock()\n    defer cmMutex.RUnlock()\n\nctx, ok := contextMap[req]\nif !ok {\n        return &quot;&quot;\n}\n\nreturn ctx.token\n\n}\n`\n源码可以再nosurf的项目的context.go中找到。","readingtime":11,"url":"/cates/backend/post/2015-11-12/develop-HTTP-middleware-using-Go","dirs":["go"],"relatives":[{"url":"/cates/backend/post/2015-11-11/Go-Web-architecture","title":"Go Web 架构"},{"url":"/cates/backend/post/2015-11-12/HTTP-2-And-GO","title":"HTTP/2 和GO"},{"url":"/cates/backend/post/2015-11-15/create-a-homepage-for-Go-Web-App","title":"为Go Web App 创建一个主页面"},{"url":"/cates/backend/post/2015-11-13/http-Handler-And-Go-error-handle","title":"http.Handler 与Go的错误处理"}]},{"title":"http.Handler 与Go的错误处理","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-186674453.jpg","iso8601Date":"2015-11-13T05:24:57+08:00","basename":"http-Handler-And-Go-error-handle","tags":["Go","Translate","Backend"],"date":"2015-11-13","cate":"backend","summary":"原文地址\n\n 在之前我写过一篇关于通过使用http.HandlerFunc来实现一个定制handler类型用来避免一些平常的错误的文章。func MyHandler(w http.ResponseWriter, r *http.Request)的签名经常可以看到。这是一个有用的通用的包含一些基本功能的handler类型，但是和其他事情一样，也有一些不足：\n 当你想要在一个handler中停止处理的时候，必须记得显示的调用一个return。这个在当你想要跑出一个从定向（301、302），未找到（404）或者服务器端错误（500）的状态的时候是很平常的。如果不这么做可能会引起一些微妙的错误（函数会继续执行），因为函数不需要一个返回值，编译器也不会警告你。\n 不容易传递额外的参数（例如，数据库连接池，配置）。你最后不得不实用一系列的全局变量（不算太坏，但是跟踪他们会导致难以扩展）或者将他们存到请求上下文中，然后每次都从其取出。这样做很笨重。\n* 一直在不断的重复同样的语句。想要记录数据库包返回的错误？既可以再每个查询方法中调用log.Printf，也可以再每个handler中返回错误。如果你的handler可以返回给一个集中记录错误的函数，并且跑出一个500的错误就更好了。\n\n 我以前的方法中使用了func(http.ResponseWriter, *http.Request)签名。这已经被证明是一个简介的方式，但是有个奇怪的地方是，返回一个无错误的状态，例如，200,302,303往往是多余的，因为要么你已经在其他地方设置了，要么就是没用的。例如：\n\n`Go\nfunc SomeHandler(w http.ResponseWriter, r *http.Request) (int, error) {\n    db, err := someDBcall()\n    if err != nil {\n        // This makes sense.\n        return 500, err\n    }\n\nif user.LoggedIn {\n    http.Redirect(w, r, &quot;/dashboard&quot;, 302)\n    // Superfluous! Our http.Redirect function handles the 302, not \n    // our return value (which is effectively ignored).\n    return 302, nil\n}\n\n}\n`\n\n看起来还行，但是我们可以做的更好\n\n一些区别\n\n 那么我们应该如何改进它？我们先列出代码：\n\n`Go\npackage handler\n\n// Error represents a handler error. It provides methods for a HTTP status \n// code and embeds the built-in error interface.\ntype Error interface {\n    error\n    Status() int\n}\n\n// StatusError represents an error with an associated HTTP status code.\ntype StatusError struct {\n    Code int\n    Err  error\n}\n\n// Allows StatusError to satisfy the error interface.\nfunc (se StatusError) Error() string {\n    return se.Err.Error()\n}\n\n// Returns our HTTP status code.\nfunc (se StatusError) Status() int {\n    return se.Code\n}\n\n// A (simple) example of our application-wide configuration.\ntype Env struct {\n    DB   *sql.DB\n    Port string\n    Host string\n}\n\n// The Handler struct that takes a configured Env and a function matching\n// our useful signature.\ntype Handler struct {\n    Env\n    H func(e Env, w http.ResponseWriter, r *http.Request) error\n}\n\n// ServeHTTP allows our Handler type to satisfy http.Handler.\nfunc (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    err := h.H(h.Env, w, r)\n    if err != nil {\n        switch e := err.(type) {\n        case Error:\n            // We can retrieve the status here and write out a specific\n            // HTTP status code.\n            log.Printf(&quot;HTTP %d - %s&quot;, e.Status(), e)\n            http.Error(w, e.Error(), e.Status())\n        default:\n            // Any error types we don&#39;t specifically look out for default\n            // to serving a HTTP 500\n            http.Error(w, http.StatusText(http.StatusInternalServerError),\n                http.StatusInternalServerError)\n        }\n    }\n}\n`\n\n 上面的代码不言自明，但是要说明一下一些突出的观点：\n\n我们自定义了一个Error类型（接口），他内嵌了Go的内建的error接口，同时提供了一个Status() int方法。我们提供了一个简单的StatusError类型（结构体），它满足handler.Error的接口。StatusError接受一个HTTP的状态码（int类型），一个可以让我们包装错误用来记录或者查询的error类型。我们的ServeHTTP方法包好了一个&quot;e := err.(type)&quot;的类型断言，它可以测试我们需要处理的错误，允许我们处理那些特别的错误。在这个例子中，他是只是一个handler.Error类型。其他的错误，例如其他包中的错误想net.Error，或者其他我们定义的额外的错误，如果想要检查，同样也可以检查。如果我们不想捕捉那些错误，那么default将会默认捕捉到。记住一点，ServeHTTP可以使我们的Handler类型满足http.Handler接口，这样他就可以在任何使用http.Handler的地方使用了，例如Go的net/http包或者所有的其他的第三方框架。这样使得定制的handler更有用，他们用起来很灵活。\n注意 net 包处理事情很简单。它又一个net.Error的接口，内嵌了内建的error接口。一些具体的类型实现了它。函数返回的具体类型跟错误的类型相同（DNS错误，解析错误等）。再datastore 包中定义的DBError有一个Query() string 方法，可以很好的解释。\n\n所有示例\n\n 它最后是什么样子的？我们是否可以将其分到不同的包中？\n\n`Go\npackage handler\n\nimport (\n    &quot;net/http&quot;\n)\n\n// Error represents a handler error. It provides methods for a HTTP status \n// code and embeds the built-in error interface.\ntype Error interface {\n    error\n    Status() int\n}\n\n// StatusError represents an error with an associated HTTP status code.\ntype StatusError struct {\n    Code int\n    Err  error\n}\n\n// Allows StatusError to satisfy the error interface.\nfunc (se StatusError) Error() string {\n    return se.Err.Error()\n}\n\n// Returns our HTTP status code.\nfunc (se StatusError) Status() int {\n    return se.Code\n}\n\n// A (simple) example of our application-wide configuration.\ntype Env struct {\n    DB   *sql.DB\n    Port string\n    Host string\n}\n\n// The Handler struct that takes a configured Env and a function matching\n// our useful signature.\ntype Handler struct {\n    Env\n    H func(e Env, w http.ResponseWriter, r *http.Request) error\n}\n\n// ServeHTTP allows our Handler type to satisfy http.Handler.\nfunc (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    err := h.H(h.Env, w, r)\n    if err != nil {\n        switch e := err.(type) {\n        case Error:\n            // We can retrieve the status here and write out a specific\n            // HTTP status code.\n            log.Printf(&quot;HTTP %d - %s&quot;, e.Status(), e)\n            http.Error(w, e.Error(), e.Status())\n        default:\n            // Any error types we don&#39;t specifically look out for default\n            // to serving a HTTP 500\n            http.Error(w, http.StatusText(http.StatusInternalServerError),\n                http.StatusInternalServerError)\n        }\n    }\n}\n\nfunc GetIndex(env Env, w http.ResponseWriter, r http.Request) error {\n    users, err := env.DB.GetAllUsers()\n    if err != nil {\n        // We return a status error here, which conveniently wraps the error\n        // returned from our DB queries. We can clearly define which errors \n        // are worth raising a HTTP 500 over vs. which might just be a HTTP \n        // 404, 403 or 401 (as appropriate). It&#39;s also clear where our \n        // handler should stop processing by returning early.\n        return StatusError{500, err}\n    }\n\nfmt.Fprintf(w, &quot;%+v&quot;, users)\nreturn nil\n\n}\n`\n\n main包：\n\n`Go\npackage main\n\nimport (\n    &quot;net/http&quot;\n    &quot;github.com/you/somepkg/handler&quot;\n)\n\nfunc main() {\n    db, err := sql.Open(&quot;connectionstringhere&quot;)\n    if err != nil {\n          log.Fatal(err)\n    }\n\n// Initialise our app-wide environment with the services/info we need.\nenv := &amp;handler.Env{\n    DB: db,\n    Port: os.Getenv(&quot;PORT&quot;),\n    Host: os.Getenv(&quot;HOST&quot;),\n    // We might also have a custom log.Logger, our \n    // template instance, and a config struct as fields \n    // in our Env struct.\n}\n\n// Note that we&#39;re using http.Handle, not http.HandleFunc. The \n// latter only accepts the http.HandlerFunc type, which is not \n// what we have here.\nhttp.Handle(&quot;/&quot;, handler.Handler{env, handler.GetIndex})\n\n// Logs the error if ListenAndServe fails.\nlog.Fatal(http.ListenAndServe(&quot;:8000&quot;, nil))\n\n}\n`\n\n 在实际使用时，会将handler和Env放入不同的包中，这里只是为了简单放在了同一个包中。","readingtime":11,"url":"/cates/backend/post/2015-11-13/http-Handler-And-Go-error-handle","dirs":["go"],"relatives":[{"url":"/cates/backend/post/2015-11-11/Go-Web-architecture","title":"Go Web 架构"},{"url":"/cates/backend/post/2015-11-12/HTTP-2-And-GO","title":"HTTP/2 和GO"},{"url":"/cates/backend/post/2015-11-15/create-a-homepage-for-Go-Web-App","title":"为Go Web App 创建一个主页面"},{"url":"/cates/backend/post/2015-11-12/develop-HTTP-middleware-using-Go","title":"使用Go开发HTTP中间件"}]},{"title":"为Go Web App 创建一个主页面","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-252035635.jpg","iso8601Date":"2015-11-15T01:59:00+08:00","basename":"create-a-homepage-for-Go-Web-App","tags":["Go","Translate","Backend"],"date":"2015-11-15","cate":"backend","summary":"原文地址\n\n 大多数web app都有一个相同的布局。这个布局可能包含一个header或者footer，甚至可能包含一个导航菜单。Go的标准库提供一个简单的方式来创建这些基本元素，通过被不同的页面重用，创建出模板页的效果。\n 这个简单的例子来解释如何实现的：\n 让我们来创建一个简单的包含两个view的web app，一个是 main 一个是about。这两个view都有相同的header和footer。\n header模板的代码如下：\n\nhtml\n{ { define &quot;header&quot; }}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;{ {.Title}}&lt;/title&gt;\n        &lt;link rel=&quot;stylesheet&quot; href=&quot;//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css&quot;&gt;\n        &lt;link rel=&quot;stylesheet&quot; href=&quot;//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-theme.min.css&quot;&gt;\n        &lt;style type=&quot;text/css&quot;&gt;\n            body {padding-bottom: 70px;}\n            .content {margin:10px;}\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;nav class=&quot;navbar navbar-default&quot; role=&quot;navigation&quot;&gt;\n          &lt;div class=&quot;navbar-header&quot;&gt;\n            &lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&gt;Go App&lt;/a&gt;\n          &lt;/div&gt;\n          &lt;div class=&quot;collapse navbar-collapse navbar-ex1-collapse&quot;&gt;  \n            &lt;ul class=&quot;nav navbar-nav&quot;&gt;\n                &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Main&lt;/a&gt;&lt;/li&gt;\n                &lt;li&gt;&lt;a href=&quot;/about&quot;&gt;About&lt;/a&gt;&lt;/li&gt;\n            &lt;/ul&gt;\n          &lt;/div&gt;\n        &lt;/nav&gt;\n{ { end }}\n\n\n footer模板的代码如下：\n\n`html\n{ { define &quot;footer&quot; }}\n        &lt;p class=&quot;navbar-text navbar-fixed-bottom&quot;&gt;Go Rocks!&lt;/p&gt;          &lt;script src=&quot;//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n{ { end }}\n\n`\n\n main 模板的代码如下：\n\nhtml\n{ {define &quot;main&quot;}}\n{ { template &quot;header&quot; .}}\n&lt;div class=&quot;content&quot;&gt;\n    &lt;h2&gt;Main&lt;/h2&gt;\n    &lt;div&gt;This is the Main page&lt;/div&gt;\n&lt;/div&gt;\n{ {template &quot;footer&quot; .}}\n{ { end}}\n\n\n about 模板的代码如下：\n\nhtml\n{ {define &quot;about&quot;}}\n{ { template &quot;header&quot; .}}\n&lt;div class=&quot;content&quot;&gt;\n    &lt;h2&gt;About&lt;/h2&gt;\n    &lt;div&gt;This is the About page&lt;/div&gt;\n&lt;/div&gt;\n{ {template &quot;footer&quot; .}}\n{ { end}}\n\n\n 服务器代码如下：\n\n`Go\npackage main\n\nimport (\n    &quot;html/template&quot;\n    &quot;net/http&quot;\n)\n\n//Compile templates on start\nvar templates = template.Must(template.ParseFiles(&quot;header.html&quot;, &quot;footer.html&quot;, &quot;main.html&quot;, &quot;about.html&quot;))\n\n//A Page structure\ntype Page struct {\n    Title string\n}\n\n//Display the named template\nfunc display(w http.ResponseWriter, tmpl string, data interface{}) {\n    templates.ExecuteTemplate(w, tmpl, data)\n}\n\n//The handlers.\nfunc mainHandler(w http.ResponseWriter, r *http.Request) {\n    display(w, &quot;main&quot;, &amp;Page{Title: &quot;Home&quot;})\n}\n\nfunc aboutHandler(w http.ResponseWriter, r *http.Request) {\n    display(w, &quot;about&quot;, &amp;Page{Title: &quot;About&quot;})\n}\n\nfunc main() {\n    http.HandleFunc(&quot;/&quot;, mainHandler)\n    http.HandleFunc(&quot;/about&quot;, aboutHandler)\n\n//Listen on port 8080\nhttp.ListenAndServe(&quot;:8080&quot;, nil)\n\n}\n`\n\n 每一个模板页都有一个 { { define &quot;name&quot; }}的命令来定义模板的名字。main和about页面通过{ { template &quot;name&quot; }}来包含header和footer。. 出入上下文来命名模板。现在，不管main和about页面如何执行，他们的页面都会包含header和footer。\n 两个页面的结果如下：\n\n  ","readingtime":6,"url":"/cates/backend/post/2015-11-15/create-a-homepage-for-Go-Web-App","dirs":["go"],"relatives":[{"url":"/cates/backend/post/2015-11-11/Go-Web-architecture","title":"Go Web 架构"},{"url":"/cates/backend/post/2015-11-12/HTTP-2-And-GO","title":"HTTP/2 和GO"},{"url":"/cates/backend/post/2015-11-12/develop-HTTP-middleware-using-Go","title":"使用Go开发HTTP中间件"},{"url":"/cates/backend/post/2015-11-13/http-Handler-And-Go-error-handle","title":"http.Handler 与Go的错误处理"}]}],"tag":"Go"}}