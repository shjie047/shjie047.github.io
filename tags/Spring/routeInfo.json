{"path":"tags/Spring","templateID":5,"sharedPropsHashes":{"tags":"1C8cqm"},"localProps":{"posts":[{"title":"深入理解Spring MVC","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-249089429.jpg","iso8601Date":"2018-04-07T08:39:10+08:00","basename":"deep-in-spring-mvc","tags":["Backend","Java","Spring","SpringMVC","Web"],"date":"2018-04-07","cate":"backend","summary":"原文地址  \n\n初始工程\n\n这篇文章中将使用最新的Spring Framework 5框架。主要关注的是Spring的经典Web技术栈，这套技术从最开始的Spring版本就开始支持，并且知道现在仍然是构建Spring Web应用的主要方式。使用Spring Boot和其他starter来设置初始工程。xml配置如下：\n`xml\n&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n    &lt;version&gt;2.0.1&lt;/version&gt;\n    &lt;relativePath/&gt;\n&lt;/parent&gt;\n\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n`\n\n测试项目\n\n为了理解Spring Web MVC是如何工作的，可以先实现一个简单的Login功能的。创建一个由@Controller来修饰的类InternalController，这个类包含一个Get的映射。hello()函数没有参数。返回一个由Spring解释的视图名字的字符串。（在本例中是login.html）  \n\n`Java\nimport org.springframework.web.bind.annotation.GetMapping;\n\n@GetMapping(&quot;/&quot;)\npublic String hello() {\n    return &quot;login&quot;;\n}\n`\n\n为了处理用户登陆逻辑，创建另一个接受POST请求的带有Login数据的方法。然后根据处理结果返回成功或者失败页面。\n注意，login()函数接受一个领域对象作为参数，返回的是ModelAndView对象。  \n\nJava\n@PostMapping(&quot;/login&quot;)\npublic ModelAndView login(LoginData loginData) {\n    if (LOGIN.equals(loginData.getLogin()) \n      &amp;&amp; PASSWORD.equals(loginData.getPassword())) {\n        return new ModelAndView(&quot;success&quot;, \n          Collections.singletonMap(&quot;login&quot;, loginData.getLogin()));\n    } else {\n        return new ModelAndView(&quot;failure&quot;, \n          Collections.singletonMap(&quot;login&quot;, loginData.getLogin()));\n    }\n}\n\n\nModelAndView保存了两个不同的对象：\n  - Model： 用来渲染页面用的键值对的map\n  - View： 填充Model数据的模版页面。  \n\n将它们合并起来是为了方便，这样controller的方法就可以同时返回这两个了。\n使用Thymeleaf作为模版引擎来渲染页面。  \n\nJava Web应用的基础-Servlet\n\n当你在浏览器里键入http://localhost:8080/ ，然后按回车键，请求到达服务器的时候到底发生了什么？是如何在浏览器中看到这个web请求的数据的？\n因为这个项目是一个简单的Spring Boot应用，所以可以通过Spring5Application来运行。\nSpring Boot默认使用Apache Tomcat运行程序，运行成功后可能会看到如下的日志：\n\n`bash\n2017-10-16 20:36:11.626  INFO 57414 --- [main] \n  o.s.b.w.embedded.tomcat.TomcatWebServer  : \n  Tomcat initialized with port(s): 8080 (http)\n\n2017-10-16 20:36:11.634  INFO 57414 --- [main] \n  o.apache.catalina.core.StandardService   : \n  Starting service [Tomcat]\n\n2017-10-16 20:36:11.635  INFO 57414 --- [main] \n  org.apache.catalina.core.StandardEngine  : \n  Starting Servlet Engine: Apache Tomcat/8.5.23\n`\n\n因为Tomcat是一个Servlet容器，所以几乎所有的HTTP请求都是由Java Servlet处理的。自然的Spring Web的入口就是一个Servlet。\nServlet是所有Java Web应用的核心组件；它非常的低成，并且没有暴露任何具体的编程模式，例如MVC。\n一个HTTP的Servelt只能接受HTTP请求，处理请求后返回响应。\n现在使用Servlet 3.0的API，可以不再使用XML配置，直接可以使用Java配置。\n\nSpring MVC的核心-DispatcherServlet\n\n作为Web开发者，我们希望抽象出以下枯燥和样板的任务，而关注于有用的业务逻辑  - 将HTTP请求映射到响应处理函数\n  - 将HTTP请求数据和header解析成数据传输对象（DTOs）或者领域对象\n  - model-view-controller 互相交互\n  - 从DTO，领域对象等生成响应  \n\nSpring的DispatcherServlet提供了以上的功能，是Spring WEB MVC框架的核心，是应用接受所有请求的核心组件。\n稍后就会了解到DispatcherServlet可扩展性非常强。例如：它允许你加入现有或者新的适配器来适应不同的任务：\n  - 将请求映射到处理它的类或者函数(由HandlerMapping实现）\n  - 使用特定模式来处理请求，例如一个普通的Servlet，一个复杂的MVC 工作流，或者只是一个方法。(由HandlerAdapter实现）\n  - 通过名字解析试图对象，允许你使用不同的模版引擎，例如：XML，XSLT或者其他视图技术(由ViewResolver实现）\n  - 默认使用Apache Comons 的文件上传组件解析文件上传，或者也可以自己实现。\n  - 由LocalResolver实现本地化，包括cookie，session，HTTP的Accept Header，或者其他由用户定义的本地化。    \n\n处理HTTP请求\n\n首先让我们重新审视一下在刚刚建立的应用中是如何处理HTTP请求的。\nDispatcherServlet有一个很长的继承层级。自顶向下理解每个单独的概念是非常有必要的。处理请求的函数将会更加有趣。\n\n理解HTTP请求在本地开发模式处理和远程处理是理解MVC架构非常重要的一步。\n\nGenericServlet\n\nGenericServlet时Servlet规范中的一部分，不直接处理HTTP。它定义了service()方法，来接受请求和返回响应。\n注意，ServletRequest和ServletResponse并不是绑定到HTTP协议的。\nJava\npublic abstract void service(ServletRequest req, ServletResponse res) \n  throws ServletException, IOException;\n\n服务器所有的请求，包括简单的GET请求都会调用这个方法。\n\nHttpServlet\n\n正如其名，HttpServelt是Servlet 规范中关于HTTP请求的实现。\n更确切的说，HttpServlet是一个实现了service()的抽象类。通过将不同的HTTP请求类型分开，由不同的函数处理，实现大约如下所示：\n`Java\nprotected void service(HttpServletRequest req, HttpServletResponse resp)\n    throws ServletException, IOException {\n\nString method = req.getMethod();\nif (method.equals(METHOD_GET)) {\n    // ...\n    doGet(req, resp);\n} else if (method.equals(METHOD_HEAD)) {\n    // ...\n    doHead(req, resp);\n} else if (method.equals(METHOD_POST)) {\n    doPost(req, resp);\n    // ...\n}\n\n`\n\nHttpServletBean\n\n在这个继承关系中HttpServletBean是第一个Spring的类。从web.xml或者WebApplicationInitialzer获取的初始参数来注入bean。\n在应用中的请求分别调用doGet,doPost等方法来处理不同的HTTP请求。\n\nFrameworkServlet\n\nFrameworkServlet实现了ApplicationContextAware,集成Web的Application Context。不过它也可以创建自己的Application Context。\n正如上述所言，父类HttpServletBean通过将初始参数作为bean的属性注入。因此如果contex的类名在contextClass这个初始参数中，那么就有这个参数创建application context的实例，否则默认使用XmlWebApplicationContext。\n由于XML配置现在已经过时了。Spring Boot默认使用AnnotationConfigWebApplicationContext来配置DispatcherServlet。不过这个是很容易修改的。\n例如，想要在Spring MVC中使用Groovy的application context，可以将下列配置在web.xml中\nbash\n  dispatcherServlet\n        org.springframework.web.servlet.DispatcherServlet\n        contextClass\n        org.springframework.web.context.support.GroovyWebApplicationContext\n\n相同的配置也可以在WebApplicationInitializer中配置。\n\nDispatcherServlet: 统一处理请求\n\nHttpServlet.service() 通过HTTP的动词类型来处理路由不同的请求到不同的方法，这个在底层的servlet实现的很好。但是，在SpringMVC的抽象层次中，不能仅靠方法类型来路由请求。\n同样的，FrameworkServlet的另一个主要功能就是将不同的处理使用processRequest()组合在一起。\n`Java\n@Override\nprotected final void doGet(HttpServletRequest request, \n  HttpServletResponse response) throws ServletException, IOException {\n    processRequest(request, response);\n}\n\n@Override\nprotected final void doPost(HttpServletRequest request, \n  HttpServletResponse response) throws ServletException, IOException {\n    processRequest(request, response);\n}\n`\n\nDispatcherServlet: 丰富请求\n\n最后,DispatcherServlet实现doService() 方法。它向请求中加入了一些有用的对象，继续在web 的管道中传递下去，例如：web application context, locale resolver, theme resolver, theme source等\nJava\nrequest.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, \n  getWebApplicationContext());\nrequest.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\nrequest.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\nrequest.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());\n\n同时，doService()加入了输入输出的Flash Map，Flash Map是将参数从一个请求传递到另一个请求的基本模式。在重定向中很有用。(例如在重定向之后向用户展示一段简单的信息）\nJava\nFlashMap inputFlashMap = this.flashMapManager\n  .retrieveAndUpdate(request, response);\nif (inputFlashMap != null) {\n    request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, \n      Collections.unmodifiableMap(inputFlashMap));\n}\nrequest.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());\n\n接着doService() 将会调用doDispatch()方法来分发请求。\n\nDispatcherServlet: 分发请求\n\ndispatch() 的主要目的就是知道一个合适的处理请求的处理器并且传递request/response参数。处理器可以是任何对象，并不局限于一个特定的接口。同样也意味着Spring需要找到如何使用这个处理器的适配器。\n为了给请求找到合适的处理器，Spring会遍历实现HandlerMapping接口的注册的实现。有很多不同的实现可以满足我们各种需求。\nSimpleUrlHandlerMapping使用URL将请求映射到处理bean中。例如：它可以通过Java.util.Properties 注入它的映射信息：\nbash\n/welcome.html=ticketController\n/show.html=ticketController\n\nRequestMappingHandlerMapping可能是最广泛使用的映射处理器。它将请求映射到@Controller类下的@RequestMapping修饰的方法上。这个就是上面那个例子中的hello()和login()。\n注意，上面两个方法分别是@GetMapping和@PostMapping修饰的。这两个注解来源于@RequestMapping。\ndispatch() 同时也可以处理一些其他的HTTP的任务：\n  - 如果资源不存在，对GET请求进行短路处理。\n  - 对相应的请求使用multipart 解析。\n  - 如果处理器选择异步处理请求，对请求进行短路处理。  \n\n处理请求\n\n现在Spring确定了处理请求的处理器和处理器的适配器，是时候处理请求了。下面是HandlerAdapter.handle() 的签名。比较重要的一点是处理器可以选择如何处理请求：\n  - 直接将相应写入到response body 和 返回null\n  - 返回一个ModelAndView对象由DispatcherServlet渲染。  \n\nJava\n@Nullable\nModelAndView handle(HttpServletRequest request, \n                    HttpServletResponse response, \n                    Object handler) throws Exception;\n\nSpring提供了很多类型的处理器，下面是SimpleControllerHandlerAdapter如何处理Spring MVC的controller实例的(不要和@Controller搞混)。\n注意，controller处理器返回ModelAndView对象并不是由起渲染的。\nJava\npublic ModelAndView handle(HttpServletRequest request, \n  HttpServletResponse response, Object handler) throws Exception {\n    return ((Controller) handler).handleRequest(request, response);\n}\n\n第二个是SimpleServletHandlerAdapter它对一个普通的servlet适配。\nservlet并不知道ModelAndView，完全自己处理请求，将返回写入到相应的body中。因此它的适配器就直接返回null。\nJava\npublic ModelAndView handle(HttpServletRequest request, \n  HttpServletResponse response, Object handler) throws Exception {\n    ((Servlet) handler).service(request, response);\n    return null;\n}\n\n在本例中，controller是由@RequestMapping修饰的POJO，因此处理器会使用HandlerMethod来封装它的方法。Spring使用RequestMappingHandlerAdapter来适配这种处理器类型。\n\n处理参数，返回处理器函数的值\n\n注意，一般来说controller并不会接收HttpServletRequest和HttpServletResponse作为参数，但是它可以接收和返回很多中其他类型，例如：领域对象，路径参数等。\n同样，也不强求一个controller返回一个ModelAndView实例。可以选择返回一个视图名称，ResponseEntity，或者是一个可以被转换成JSON的POJO。\nRequestMappingHandlerAdapter可以保证从HttpServletRequest中解析方法需要的参数，同时创建ModelAndView对象返回。\n下面这段代码就是RequestMappingHandlerAdapter中保证这件事情的：\nJava\nServletInvocableHandlerMethod invocableMethod \n  = createInvocableHandlerMethod(handlerMethod);\nif (this.argumentResolvers != null) {\n    invocableMethod.setHandlerMethodArgumentResolvers(\n      this.argumentResolvers);\n}\nif (this.returnValueHandlers != null) {\n    invocableMethod.setHandlerMethodReturnValueHandlers(\n      this.returnValueHandlers);\n}\n\nargumentResolvers在HandlerMethodArgumentResolver实例中有不同实现。一共有30多种不同的参数解析器的实现。他们可以从请求参数将函数需要的参数解析出来。包括：url路径变量，请求体参数，请求头，cookies，session等。\nreturnValueHandlers在HandlerMethodArgumentResolver实例中有不同实现。同样也有很多不同的返回值处理器来处理方法返回的结果，创建ModelAndView对象。\n例如：当函数hello()返回一个string的时候，ViewNameMethodReturnValueHandler处理这个值。login()返回一个ModelAndView对象的时候，Sring使用ModelAndViewMethodReturnValueHandler处理这个值。\n\n渲染视图\n\n现在Spring已经处理了HTTP请求，获取了ModelAndView实例，现在它需要在用户浏览器渲染HTML页面了。它依赖于由Model和选择的模版组成的ModelAndView对象。\n同样的，Spring也可以渲染JSON ,XML或者其他HTTP协议接受的类型。这些将在接下来的REST相关了解更多。\n现在回去看一下DispatcherServlet。 render() 首先使用LocaleResolver实例设置返回的Local。首先假设浏览器已经正确设置Accetp头。默认使用AcceptHeaderLocaleResolver来处理。\n在渲染过程中，ModelAndView可以包含一个视图的名字或者是已经选择的视图，或者如果controller依赖于默认视图也可以没有。\n既然hello()和login()方法制定了字符串名字作为视图名称，所以需要使用viewResolvers来查找视图。\nJava\nfor (ViewResolver viewResolver : this.viewResolvers) {\n    View view = viewResolver.resolveViewName(viewName, locale);\n    if (view != null) {\n        return view;\n    }\n}\n\nViewResolver的实现由很多，这里使用了由thymeleaf-spring5提供的ThymeleafViewResolver实现。解析器知道去哪里查找视图，并且提供相应的视图实例。\n调用完render()之后，Spring就完成了将HTML页面渲染到用户浏览器的任务。\n\nREST 支持\n\n除了MVC的场景，我们可以使用狂减创建rest web service。\n一个简单的场景，可以使用由@RequestBody修饰的POJO作为参数。由@ResponseBody修饰方法，指定方法的返回结果直接写入到响应体中。  \n\n`Java\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@ResponseBody\n@PostMapping(&quot;/message&quot;)\npublic MyOutputResource sendMessage(\n  @RequestBody MyInputResource inputResource) {\n\nreturn new MyOutputResource(&quot;Received: &quot;\n  + inputResource.getRequestMessage());\n\n}\n`\n\n感谢SpringMVC的扩展性，这样做也是可以的。\n框架使用HttpMessageConverter将内部DTO转换成REST的表示。例如：MappingJackson2HttpMessageConverter的可以使用Jackson库将转换model和JSON。\n为了简化创建REST API，Srping 引入了@RestController注解。默认使用@ResonseBody这样就不需要在每个方法中使用了。\n`Java\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class RestfulWebServiceController {\n\n@GetMapping(&quot;/message&quot;)\npublic MyOutputResource getMessage() {\n    return new MyOutputResource(&quot;Hello!&quot;);\n}\n\n}\n`\n\n结论\n\n在这篇文章中，详细描述了Spring MVC处理HTTP请求的各个步骤。了解到Spring 框架是如何将各个组件组合在一起提供处理HTTP协议的。","readingtime":17,"url":"/cates/backend/post/2018-04-07/deep-in-spring-mvc","dirs":["spring-mvc"],"relatives":[{"url":"/cates/backend/post/2018-04-10/spring-mvc-controller","title":"SpringMVC 教程 - Controller"},{"url":"/cates/backend/post/2018-04-09/spring-mvc-dispatcher-servlet","title":"SpringMVC 教程 - DispatcherServlet"},{"url":"/cates/backend/post/2018-04-09/spring-mvc-filter","title":"SpringMVC 教程 - Filter"}]},{"title":"SpringMVC 教程 - DispatcherServlet","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-239935763.jpg","iso8601Date":"2018-04-09T08:39:10+08:00","basename":"spring-mvc-dispatcher-servlet","tags":["Backend","Java","SpringMVC","Spring"],"date":"2018-04-09","cate":"backend","summary":"简介\n\n同许多其他的web框架一样，SpringMVC使用了前端控制器的设计模式，即一个以DispatcherServlet为核心的Servlet为处理请求提供了一个共享的算法，而实际的工作是由可配置的委托组件执行的。这个模式即灵活又支持多样的工作流。\n同其他的Servlet,依照Servlet 规范DispatcherServlet需要在web.xml或者Java配置中声明并映射URL。接着DispatcherServlet使用Spring的配置来查找委托组件，用来映射URL，解析视图，异常处理等。\n下面这个示例是使用Java配置来注册并初始化DispatcherServlet，这个类由Servlet容器自动发现。\n`Java\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n\n@Override\npublic void onStartup(ServletContext servletCxt) {\n\n    // Load Spring web application configuration\n    AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();\n    ac.register(AppConfig.class);\n    ac.refresh();\n\n    // Create and register the DispatcherServlet\n    DispatcherServlet servlet = new DispatcherServlet(ac);\n    ServletRegistration.Dynamic registration = servletCxt.addServlet(&quot;app&quot;, servlet);\n    registration.setLoadOnStartup(1);\n    registration.addMapping(&quot;/app/*&quot;);\n}\n\n}\n`\n\n下面这个示例是使用web.xml来注册并初始化的\n`xml\n&lt;web-app&gt;\n\n&lt;listener&gt;\n    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;\n&lt;/listener&gt;\n\n&lt;context-param&gt;\n    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n    &lt;param-value&gt;/WEB-INF/app-context.xml&lt;/param-value&gt;\n&lt;/context-param&gt;\n\n&lt;servlet&gt;\n    &lt;servlet-name&gt;app&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n&lt;/servlet&gt;\n\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;app&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n\n&lt;/web-app&gt;\n`\n\n层次结构\n\nDispatcherServlet需要一个扩展了的ApplicationContext的WebApplicationContext来配置自己的信息。WebApplicationContext包含了Servlet的ServletContext的引用，可以使用RequestContextUtils中的静态方法从WebApplicationContext中查找ServletContext。\n对于大多数应用来说一个WebApplicationContext就足够了。当然WebApplicatioContext也可以是有层次结构的，例如由多个Servlet共享的一个根WebApplicationContext，每个Servlet又有自己的子WebApplicationContext。\n根WebApplicationContext一般包括需要在多个Servlet中共享的基础bean，例如数据仓库，业务逻辑等。在Servlet规范中，这些bean可以被有效的继承和改写，子WebApplicationContext仅包含在其属于的Servlet中。\n\n下面这个例子就是WebApplicationContext的层级配置\n`Java\npublic class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n@Override\nprotected Class&lt;?&gt;[] getRootConfigClasses() {\n    return new Class&lt;?&gt;[] { RootConfig.class };\n}\n\n@Override\nprotected Class&lt;?&gt;[] getServletConfigClasses() {\n    return new Class&lt;?&gt;[] { App1Config.class };\n}\n\n@Override\nprotected String[] getServletMappings() {\n    return new String[] { &quot;/app1/*&quot; };\n}\n\n} \n`\n\n同样的，在web.xml中的配置\n`xml\n&lt;web-app&gt;\n\n&lt;listener&gt;\n    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;\n&lt;/listener&gt;\n\n&lt;context-param&gt;\n    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n    &lt;param-value&gt;/WEB-INF/root-context.xml&lt;/param-value&gt;\n&lt;/context-param&gt;\n\n&lt;servlet&gt;\n    &lt;servlet-name&gt;app1&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;/WEB-INF/app1-context.xml&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n&lt;/servlet&gt;\n\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;app1&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/app1/*&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n\n&lt;/web-app&gt;\n`\n\n特殊的bean类型\n\nDispatcherServlet委托专用的bean来处理请求，渲染响应。专用的bean指的是Spring管理的，实现WebFlux框架约定的实例。这些bean一般都是内建的约定，但是可以定制他们的属性，扩展或者代替这些bean。\n\nbean 类型 | 解释\n:---------- | :---------\nHandlerMapping | 处理器映射，具体由其子类实现。两个重要的子类，RequestMappingHandlerMapping,SimpleUrlHandlerMapping\nHandlerAdapter | 辅助DispatcherServlet执行特定的处理器。\nHandlerExceptionResolver | 将异常重定向到其他处理器或者是显示HTML的错误界面。\nViewResolver | 通过处理器返回的视图字符串查找具体的视图并渲染。 \nLocaleResolver, LocaleContextResolver | 支持国际化页面，使用例如时区等来解析本地化问题。 \nThemeResolver | 解析应用可用的主题，例如提供个性化框架 \nMultipartResolver | 处理上传文件 \nFlashMapManager | 保存和检索输入输出的FlashMap，它可以将属性从一个请求传递到另一个请求的输入输出，一般应用在重定向中。 \n\nWeb MVC 配置\n\n应用可以声明在特殊的bean类型中列出的bean来处理请求。DispatcherServlet会检查每一个bean的WebApplicationContext。如果没有指定的bean，那么就会使用DispatcherServlet.properties中定义的bean。\nMVC配置将会在以后详细的列出。\n\nServlet 配置\n\n在Servlet 3.0+中，可以使用编程的方式来代替web.xml配置。下面这个例子就是通过编程注册DispatcherServlet\n`Java\nimport org.springframework.web.WebApplicationInitializer;\n\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n\n@Override\npublic void onStartup(ServletContext container) {\n    XmlWebApplicationContext appContext = new XmlWebApplicationContext();\n    appContext.setConfigLocation(&quot;/WEB-INF/spring/dispatcher-config.xml&quot;);\n\n    ServletRegistration.Dynamic registration = container.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(appContext));\n    registration.setLoadOnStartup(1);\n    registration.addMapping(&quot;/&quot;);\n}\n\n}\n`\n\nWebApplicationInitializer是由SpringMVC提供的接口，用来保证上述实现可以由支持Servlet 3.0的容器自动检测并初始化。抽象类AbstractDispatcherServletInitializerl实现了WebApplicationInitializer 可以更加容易的注册DispathcerServlet。\n下面是使用Java配置的Spring\n`Java\npublic class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n@Override\nprotected Class&lt;?&gt;[] getRootConfigClasses() {\n    return null;\n}\n\n@Override\nprotected Class&lt;?&gt;[] getServletConfigClasses() {\n    return new Class&lt;?&gt;[] { MyWebConfig.class };\n}\n\n@Override\nprotected String[] getServletMappings() {\n    return new String[] { &quot;/&quot; };\n}\n\n}\n`\n\n如果使用的是xml配置，需要直接继承AbstractDispatcherServletInitializer\n`Java\npublic class MyWebAppInitializer extends AbstractDispatcherServletInitializer {\n\n@Override\nprotected WebApplicationContext createRootApplicationContext() {\n    return null;\n}\n\n@Override\nprotected WebApplicationContext createServletApplicationContext() {\n    XmlWebApplicationContext cxt = new XmlWebApplicationContext();\n    cxt.setConfigLocation(&quot;/WEB-INF/spring/dispatcher-config.xml&quot;);\n    return cxt;\n}\n\n@Override\nprotected String[] getServletMappings() {\n    return new String[] { &quot;/&quot; };\n}\n\n}\n`\n\nAbstractDispatcherServletInitializer同样提供了一个方便的函数来添加过滤器。\n`Java\npublic class MyWebAppInitializer extends AbstractDispatcherServletInitializer {\n\n// ...\n\n@Override\nprotected Filter[] getServletFilters() {\n    return new Filter[] {\n        new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };\n}\n\n}\n`\n\n每个过滤器根据他具体的类型添加一个默认的名字，并且自动映射到DispatcherServlet。\nisAsyncSupported方法是AbstractDispatcherServletInitializer的protect的方法，可以启动DispatcherServlet支持异步处理\n如果要定义自己的DispatcherServlet，那么可以重写createDispatcherServlet方法。\n\n处理请求\n\nDispatcherServlet处理请求的流程如下：  - 查找WebApplicationContext并将其作为request的一个属性保存起来，以便其他控制器或者处理链中的组件可以使用。默认保存键为DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE \n  - 本地化解析器保存在request中，以便处理链中的其他组件使用他来处理请求做本地化处理。如果不需要本地化，那么就不需要使用他。\n  - 主题解析器保存在request中，以便其他组件，例如视图查找器使用，如果不需要要主题定制，直接忽略。\n  - 如果指定了文件上传解析器，那么就会检查请求是否有文件上传，如果有请求有MultipartHttpServletRequest封装，以便其他组件处理。\n  - 查找合适的处理器处理请求。如果找到了处理器，那么就依次执行处理链上的组件，返回一个model或者视图。如果是注解的controller也可以直接渲染而不需要返回视图。\n  - 如果返回一个model，会渲染一个视图，如果没有返回model，那么就无需渲染视图了，因为视图可能已经被渲染了。\n\n在请求处理过程中如果出现了一场那么就可以使用WebApplicatioContext中的HandlerExceptionResolver来定制异常处理。\nSpringMVC 同样支持返回last-modification-date，对指定请求处理如何判断是否有last-modification-date非常直接：DispatcherServlet查找适合的处理器，并且检查其是否实现了LastModified接口，如果实现了，调用long getLastModified(request)返回给客户端。\n通过web.xml中Servlet的初始化参数可以定制DispatcherServlet.\n\n参数 | 解释 |\n:---------- | :---------\ncontextClass | 实现WebApplicationContext的类，默认使用XmlWebApplicationContext \ncontextConfigLocation | 传递给Context 实例的字符串，包括了bean的定义 \nnamespace | WebApplicationContext 的命名空间，默认[servlet-name]-servlet \n\n拦截器\n\nHandlerMapping支持拦截器，在对某些请求添加处理的时候非常有用，比如，权限检查。拦截器必须实现org.springframework.web.servlet包中的HandlerInterceptor，这个接口有三个处理函数分别对应请求处理前，请求处理后，完成请求处理。\n  - preHandle(..) 在请求处理前执行\n  - postHandle(..) 请求处理后执行\n  - afterCompletion(..) 整个请求处理结束后执行\npreHandle(..) 返回一个boolean值。可以使用这个值来中断处理请求链。当返回true的时候，处理将会继续执行，如果返回false，DispatcherServelt假定拦截器已经对请求正确处理了，例如渲染了一个页面等。将会中断请求处理链。\n注意，postHandle方法很少使用@ResponseBody和ResponseEntity。因为响应已经在postHandle执行之前有HandlerAdapter返回了。意味着在postHandle的时候再修改响应已经晚了。对应这种场景可以继承ResponseBodyAdvice或者实现ControllerAdvice或者直接配置RequestMappingHandlerAdapter来实现。\n\n异常处理\n\n如果在请求映射或者处理请求的时候抛出异常，DispatcherServelt会委托HandlerExceptionResolver来解析异常并提供可选择的处理，即返一个错误响应。\n下表是HandlerExceptionResolver的实现\n\n HandlerExceptionResolver | 描述 \n:---------- | :---------\nSimpleMappingExceptionResolver | 异常类名和错误页面名的映射。浏览器渲染错误页面的时候非常实用 \nDefaultHandlerExceptionResolver | 解析SpringMVC抛出的异常，同时将其映射到HTTP的错误码上ResponseStatusExceptionResolver | 解析@ResponseStatus注解，同时根据其注解值将其映射到HTTP的错误码上ExceptionHandlerExceptionResolver | 调用@Controller 或者@ControllerAdvice 类中使用@ExceptionHandler注解的方法 \n\n解析链\n\n可以通过在Spring的配置中声明多个HandlerExceptionResolverbean，来构成一个异常处理解析链，如果需要的话，同时可以设置他们解析的顺序。序号越大，处理越靠后。\nHandlerExceptionResolver可以返回：\n  - 指向错误页面的 ModelAndView\n  - 如果异常在解析链中被处理返回空ModelAndView\n  - 如果异常为被处理返回null，后续的解析起继续处理异常，如果异常一直未被处理，那么将会冒泡到Servlet容器处理\nSpring MVC的异常是有MVC配置自动声明的，@ResponseStatus注解异常，支持@ExceptionHandler方法的异常。这些处理器都是可以定制和替换的\n\nServlet容器异常\n\n如果HandlerExceptionResolver无法处理异常，那么异常将会继续传播，或者是返回了错误的HTTP状态码，例如4xx，5xx。Servlet容器可能会渲染一个错误的页面。这个页面也是可以定制的：\nxml\n&lt;error-page&gt;\n    &lt;location&gt;/error&lt;/location&gt;\n&lt;/error-page&gt;\n\n\n根据上述代码，当出现了无法处理的异常，或者返回错误码，容器会根据配置返回一个错误的URL。这个请求将会继续被DispatcherServlet处理，比如映射到一个@Controller的错误处理控制器上：\n`Java\n@RestController\npublic class ErrorController {\n\n@RequestMapping(path = &quot;/error&quot;)\npublic Map&lt;String, Object&gt; handle(HttpServletRequest request) {\n    Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();\n    map.put(&quot;status&quot;, request.getAttribute(&quot;javax.servlet.error.status_code&quot;));\n    map.put(&quot;reason&quot;, request.getAttribute(&quot;javax.servlet.error.message&quot;));\n    return map;\n}\n\n}\n`\n\n视图解析\n\nSpring MVC通过定义了ViewResolver和View两个接口可以让我们直接通过返回model来渲染视图，而不需要指定某一个特定的视图技术。ViewResolver提供了视图名和视图之间的映射关系。在提交给特定视图技术之前由View来准备数据。\n下列表格展示了ViewResolver的层级：\n\n ViewResolver | 描述 \n:---------- | :---------\nAbstractCachingViewResolver | 缓存解析过的视图。可设置cache属性为false来关闭缓存。在需要刷新缓存的场景可调用removeFromCache(String viewName, Locale loc)刷新。\nXmlViewResolver | 实现ViewResolver，可以接收一个同Spring XML bean同DTD的xml配置文件。默认在/WEB-INF/views.xml\nResourceBundleViewResolver | 解析定义在ResourceBundle中的视图，使用viewname.class作为视图类，viewname.url作为视图名\nUrlBasedViewResolver | 无需明确指定映射，直接通过解析url来查找视图名。\nInternalResourceViewResolver | 实现UrlBasedViewResolver,JstlView,TilesView，支持InternalResourceView例如：jsp，servlet class等。\nFreeMarkerViewResolver | UrlBasedViewResolver的子类，用来支持FreeMarker\nContentNegotiatingViewResolver | 根据请求的文件名或者Accept来确定视图\n\n视图处理\n\n如果需要的话，可以声明多个视图处理器，通过设置order属性来确定他们的顺序。order越大，处理越靠后。\n默认情况下ViewResolver可以返回null代表找不到视图。当然在JSP中，使用InternalResourceViewResolver来检查JSP是否存在的唯一方式就是通过RequestDispatcher执行一次调度。因此InternalResourceViewResolver必须是最后一个视图解析器。\n\n视图redirect\n\n视图前缀redirect: 表示视图需要执行一次redirect。UrlBasedViewResolver和其子类会识别出这是要给重定向，剩下的部分就是视图名。\n这个效果和Controller返回一个RedirectView一样，但是使用这个指令，controller就可以简单的返回一个视图名就可以了。视图名redirect:/myapp/some/resource将会返回相对于当前Servlet Context的视图，redirect:http://myhost.com/some/arbitrary/path 这种则会返回绝对URL。\n注意，如果一个controller被@ResponseStatus修饰，那么注解值优先级高于RedirectView\n\n视图Forwarding\n\n视图前缀forward: 表示视图执行forwarding。同样由UrlBasedViewResolver和其子类解析。通过创建InternalResourceView执行RequestDispatcher.forward()实现。因此这个指令对于InternalResourceViewResolver和InternalResourceViewResolver没啥用，但是对于使用了其他的视图技术但是仍然想用强制使用JSP或者Servlet的时候就很有用了。\n\n视图内容协商\n\nContentNegotiatingViewResolver并不会解析视图，而是将其委托给其他视图解析器，并且选择客户端请求描述选择视图。描述可以是Accept头或者参数，例如/path?format=pdf\nContentNegotiatingViewResolver通过对比请求的媒体类型和ViewResolvers支持的媒体类型来选择合适的View。被选中的列表中的第一个View将会被返回给客户端。\n\n本地化\n\n同Spring MVC，大多数Spring架构支持国际化。DispatcherServlet通过LocaleResolver根据客户端的区域自动解析消息。\n当请求到来时DispatcherServlet查找本地化解析器，如果找到则会设置本地化。通过RequestContext.getLocale()方法可以获取由本地化解析器解析的本地化语言。\n为了自动化解析，可以通过拦截器对具体的场景进行本地化解析，例如根据请求参数来解析。\n本地化解析器和拦截器定义在org.springframework.web.servlet.i18n包中，可以在应用中配置。下面是一些Spring使用的配置\n\nTimeZone\n\n通过获取客户端的时区来做本地化。LocaleContextResolver接口扩展了LocalResolver，提供了一个可能包含时区信息的LocaleContext。\n如果可以，用户的时区可以通过RequestContext.getTimeZone()方法获取。时区信息可以自动的被注册到Spring中的ConversionService 日期时间的Converter和Formatter使用。\n\nHeader resolver\n\n这个解析器检查accept-language头，一般来说包含的是客户端操作系统的区域。注意这个不支持时区。\n\nCookie resolver\n\n这个解析器检查cookie中可能包含的TimeZone和Locale。通过如下定义来使用：\n`xml\n&lt;bean id=&quot;localeResolver&quot; class=&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;&gt;\n\n&lt;property name=&quot;cookieName&quot; value=&quot;clientlanguage&quot;/&gt;\n\n&lt;!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --&gt;\n&lt;property name=&quot;cookieMaxAge&quot; value=&quot;100000&quot;/&gt;\n\n&lt;/bean&gt;\n`\n\nCookieLocaleResolver的属性：\n\n 名字 | 默认值 | 描述 \n:---------- | :--------- | :----------\ncookieName | classname + LOCALE | cookie名\ncookieMaxAge | Servlet容器默认值 | cookie生效时间\ncookiePath | / | cookie 保存位置\n\nSession resolver\n\nSessionLocaleResolver通过从session中检查可能包含的TimeZone和Locale。相对于CookieLocaleResolver，他将信息保存在HttpSession中。\n\nLocale interceptor\n\n可以通过拦截器启动针对某些映射的本地化策略，例如如下：\n`xml\n&lt;bean id=&quot;localeChangeInterceptor&quot;\n        class=&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;&gt;\n    &lt;property name=&quot;paramName&quot; value=&quot;siteLanguage&quot;/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;localeResolver&quot;\n        class=&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;/&gt;\n\n&lt;bean id=&quot;urlMapping&quot;\n        class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;\n    &lt;property name=&quot;interceptors&quot;&gt;\n        &lt;list&gt;\n            &lt;ref bean=&quot;localeChangeInterceptor&quot;/&gt;\n        &lt;/list&gt;\n    &lt;/property&gt;\n    &lt;property name=&quot;mappings&quot;&gt;\n        &lt;value&gt;/**/*.view=someController&lt;/value&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n`\n\n主题\n\n可以通过设置Spring MVC的主题来整体设置应用的外观，从而提高用户体验。主题是一些静态资源的集合，主要是可以影响外观的样式表和图片。\n为了应用主题，首先要设置一个org.springframework.ui.context.ThemeSource的接口。WebApplicationContext继承了ThemeSource，但是将其实现委托给了子类。默认使用的是org.springframework.ui.context.support.ResourceBundleThemeSource来从classpath的根目录下加载配置文件。配置文件格式如下：\n\nstyleSheet=/themes/cool/style.css\nbackground=/themes/cool/img/coolBg.jpg\n\n配置文件的名字是视图代码中的变量名。对于JSP而言可以如下显示：\nJSP\n&lt;%@ taglib prefix=&quot;spring&quot; uri=&quot;http://www.springframework.org/tags&quot;%&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;spring:theme code=&#39;styleSheet&#39;/&gt;&quot; type=&quot;text/css&quot;/&gt;\n    &lt;/head&gt;\n    &lt;body style=&quot;background=&lt;spring:theme code=&#39;background&#39;/&gt;&quot;&gt;\n        ...\n    &lt;/body&gt;\n&lt;/html&gt;\n\n\n默认情况下ResourceBundleThemeSource使用空的前缀名，这样配置文件直接从classpath根目录下加载。这样就可以将cool.properties定义放到classpath根目录下，ResourceBundleThemeSource默认使用标准的Java资源加载工具，同时也完全支持国际化，所以通过命名来支持cool_nl.properties。\n\n解析主题\n\nDispatcherServlet通过bean的名字themeResolver来查找ThemeResolver的实现。\nThemeResolver 的实现如下：\n\nClass | 描述 \n:---------- | :---------\nFixedThemeResolver | 选中一个固定的主题，设置defaultThemeName属性\nSessionThemeResolver | 主题由用户session维护。每个session只需要设置一次\nCookieThemeResolver | 通过cookie选择主题\n\nMultipart resolver\n\norg.springframework.web.multipart中的MultipartResolver是用来处理multipart请求的。共有给予Common Fileupload和Servlet 3.0 两种实现。\n为了使用multipart，需要在DispatcherServlet的Spring配置中声明一个名字为multipartResolver的bean。当POST请求的content-type是multipart/form-data的时候，解析器解析这个请求并且将HttpServletRequest封装成MultipartHttpServletRequest来处理请求。\n\nApache FileUpload\n\n使用Apache Commons FileUpload 只需要简单的配置一个类型为CommonsMultipartResolver，名字为multipartResolver的bean即可。当然也需要将commons-fileupload加入到依赖中。\n\nServlet 3.0\n\n使用Servlet 3.0则需要Servlet 容器的配置\n  - 使用Java配置，在Servlet注册中设置MultipartConfigElement。\n  - 使用web.xml 添加要给&lt;multipart-config&gt;的配置\n如下是使用Java的配置：\n\n`Java\npublic class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n// ...\n\n@Override\nprotected void customizeRegistration(ServletRegistration.Dynamic registration) {\n\n    // Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold\n    registration.setMultipartConfig(new MultipartConfigElement(&quot;/tmp&quot;));\n}\n\n}\n`\n\nServlet 3.0配置好之后，只需要添加类型为StandardServletMultipartResolver，名字为multipartResolver的配置即可。","readingtime":24,"url":"/cates/backend/post/2018-04-09/spring-mvc-dispatcher-servlet","dirs":["spring-mvc"],"relatives":[{"url":"/cates/backend/post/2018-04-07/deep-in-spring-mvc","title":"深入理解Spring MVC"},{"url":"/cates/backend/post/2018-04-10/spring-mvc-controller","title":"SpringMVC 教程 - Controller"},{"url":"/cates/backend/post/2018-04-09/spring-mvc-filter","title":"SpringMVC 教程 - Filter"}]},{"title":"SpringMVC 教程 - Filter","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-247383127.jpg","iso8601Date":"2018-04-09T08:39:10+08:00","basename":"spring-mvc-filter","tags":["Backend","Java","SpringMVC","Spring"],"date":"2018-04-09","cate":"backend","summary":"简介\n\nspring-web模块提供了许多非常实用的Filter\n\nHTTP PUT FORM\n\n浏览器只能通过GET或者POST提交FORM数据，但是非浏览器的客户端可以使用PUT或者PATCH。Servlet API仅为POST方法提供了ServletRequest.getParameter*()方法获取FORM信息。\nspring-web模块提供了HttpPutFormContentFilter检查PUT或者PATCH方法的content-type是否是application/x-www-form-urlencoded,如果是，则从请求体重读取属性并封装到ServletRequest中，以便日后通过ServletRequest.getParameter*()获取FORM数据。\n\n重定向头\n\n由于请求会经过像负载均衡器这样的代理，那么host，port，scheme在创建一些资源文件的链接的时候返回给客户端可能是有所不同的。\nRFC 7239 为代理定义了Forwarded 的HTTP头来提供原始请求的信息。同样也有一些其他非标准的HTTP头，例如：X-Forwarded-Host,X-Forwarded-Port,X-Forwarded-Proto。\nForwardedHeaderFilter会从Forwarded,X-Forwarded-Host,X-Forwarded-Port或者X-Forwarded-Proto中获取跳转信息。他分装了请求以覆盖host，port，scheme，同样为日后的处理隐藏跳转信息。\n注意，根据RFC 7239第八节的解释，使用重定向头的时候会有安全问题。在应用层是无法判断一个挑战是否是可信的。所以要正确配置网络上游代理，以便过滤掉不合法的跳转。\n如果应用没有使用代理，那么就无需使用ForwardedHeaderFilter过滤器。\n\nShallow ETag\n\nShallowEtagHeaderFilter为ETG提供了过滤器，关于ETAG将在视图技术中详细解释。\n\nCORS\n\n通过controller的注解Spring MVC对CORS提供了详细的支持。在和Spring Sercurity一同使用的时候CorsFilter必须排在Spring Sercurity的过滤器之前。\n\n关于CORS\n\n由于安全原因，浏览器禁止AJAX跳出当前域去访问资源。例如你的银行帐号在一个tab页打卡了，另一个evil.com在其他tab打开。evil.com的脚本不能使用你的银行账号信息去访问银行的API。\nCross-Origin Resource Sharing (CORS) 是由众多浏览器实现的W3C的规范。他规定了允许哪些请求可以跨域，而不是通过弱安全的和功能受限的IFRAME和JSONP。\nHandlerMapping对CORS提供了内置支持。成功将请求映射到处理器后，HandlerMapping对当前请求检查CORS配置，预检请求直接处理，简单和实际请求则检查CORS请求，验证，设置返回header。\n为了开启跨域请求（例如Origin头和请求的host不一致），需要对CORS进行明确的配置。如果没有找到CORS的配置，那么直接拒绝预检请求，简单请求和实际请求不会添加响应头，因此浏览器不会获取到信息。\n每一个HandlerMapping都可以根据URL不同配置单独的 CorsConfiguration。一般来说应用会通过Java Config或者Xml 命名空间来配置单一，全局的CORS。\nHandlerMapping级别的全局CORS配置可以和handler级别的CORS合并。例如有注解的controller可以使用类或者方法级别的注解@CrossOrigin配置跨域。\n@CrossOrigin注解可以在controller层启动对请求的跨域检查，例如：\n`Java\n@RestController\n@RequestMapping(&quot;/account&quot;)\npublic class AccountController {\n\n@CrossOrigin\n@GetMapping(&quot;/{id}&quot;)\npublic Account retrieve(@PathVariable Long id) {\n    // ...\n}\n\n@DeleteMapping(&quot;/{id}&quot;)\npublic void remove(@PathVariable Long id) {\n    // ...\n}\n\n}\n\n默认情况下`@CrossOrigin`的作用如下：\n  - 允许所有的域\n  - 允许所有header\n  - 允许controller映射的方法\n  - `allowedCredentials` 默认关闭\n  - `max-age`默认30分钟\n`@CrossOrigin`同样支持类级别：\nJava\n@CrossOrigin(origins = &quot;http://domain2.com&quot;, maxAge = 3600)\n@RestController\n@RequestMapping(&quot;/account&quot;)\npublic class AccountController {\n\n@GetMapping(&quot;/{id}&quot;)\npublic Account retrieve(@PathVariable Long id) {\n    // ...\n}\n\n@DeleteMapping(&quot;/{id}&quot;)\npublic void remove(@PathVariable Long id) {\n    // ...\n}\n\n}\n\n`@CrossOrigin`同时可以在类和方法中使用：\nJava\n@CrossOrigin(maxAge = 3600)\n@RestController\n@RequestMapping(&quot;/account&quot;)\npublic class AccountController {\n\n@CrossOrigin(&quot;http://domain2.com&quot;)\n@GetMapping(&quot;/{id}&quot;)\npublic Account retrieve(@PathVariable Long id) {\n    // ...\n}\n\n@DeleteMapping(&quot;/{id}&quot;)\npublic void remove(@PathVariable Long id) {\n    // ...\n}\n\n}\n\n通过定义全局的CORS配置，来配合使用。全局的CORS配置可以通过Java Config或者XML的XNM命名空间来配置。\n默认情况下全局的CORS配置：\n  - 允许所有的域\n  - 允许所有的header\n  - 允许GET,HEAD，POST方法\n  - `allowedCredentials` 默认关闭\n  - `max-age`默认30分钟\n使用Java配置CORS\nJava\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n@Override\npublic void addCorsMappings(CorsRegistry registry) {\n\n    registry.addMapping(&quot;/api/**&quot;)\n        .allowedOrigins(&quot;http://domain2.com&quot;)\n        .allowedMethods(&quot;PUT&quot;, &quot;DELETE&quot;)\n        .allowedHeaders(&quot;header1&quot;, &quot;header2&quot;, &quot;header3&quot;)\n        .exposedHeaders(&quot;header1&quot;, &quot;header2&quot;)\n        .allowCredentials(true).maxAge(3600);\n\n    // Add more mappings...\n}\n\n}\n\n使用XML配置CORS\nXml\n&lt;mvc:cors&gt;\n\n&lt;mvc:mapping path=&quot;/api/**&quot;\n    allowed-origins=&quot;http://domain1.com, http://domain2.com&quot;\n    allowed-methods=&quot;GET, PUT&quot;\n    allowed-headers=&quot;header1, header2, header3&quot;\n    exposed-headers=&quot;header1, header2&quot; allow-credentials=&quot;true&quot;\n    max-age=&quot;123&quot; /&gt;\n\n&lt;mvc:mapping path=&quot;/resources/**&quot;\n    allowed-origins=&quot;http://domain1.com&quot; /&gt;\n\n&lt;/mvc:cors&gt;\n\n另外，也可以通过`CorsFilter`配置CORS。\nJava\nCorsConfiguration config = new CorsConfiguration();\n\n// Possibly...\n// config.applyPermitDefaultValues()\n\nconfig.setAllowCredentials(true);\nconfig.addAllowedOrigin(&quot;http://domain1.com&quot;);\nconfig.addAllowedHeader(&quot;&quot;);\nconfig.addAllowedMethod(&quot;&quot;);\n\nUrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\nsource.registerCorsConfiguration(&quot;/**&quot;, config);\n\nCorsFilter filter = new CorsFilter(source);\n`","readingtime":8,"url":"/cates/backend/post/2018-04-09/spring-mvc-filter","dirs":["spring-mvc"],"relatives":[{"url":"/cates/backend/post/2018-04-07/deep-in-spring-mvc","title":"深入理解Spring MVC"},{"url":"/cates/backend/post/2018-04-10/spring-mvc-controller","title":"SpringMVC 教程 - Controller"},{"url":"/cates/backend/post/2018-04-09/spring-mvc-dispatcher-servlet","title":"SpringMVC 教程 - DispatcherServlet"}]},{"title":"SpringMVC 教程 - Controller","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-244371365.jpg","iso8601Date":"2018-04-10T08:39:10+08:00","basename":"spring-mvc-controller","tags":["Backend","Java","SpringMVC","Spring"],"date":"2018-04-10","cate":"backend","summary":"声明Controller\n\nController也是一个标准的Spring bean，可以在Servlet的WebApplicationContext中定义。也可以使用@Controller注解，Spring会扫描注解自动注册为Spring的bean。\n开启自动注册@Controller注解的bean可以使用如下Java Config的配置：\n`Java\n@Configuration\n@ComponentScan(&quot;org.example.web&quot;)\npublic class WebConfig {\n\n// ...\n\n}\n\n如果使用xml配置，如下：\nxml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\n    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n    xsi:schemaLocation=&quot;\n        http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n\n&lt;context:component-scan base-package=&quot;org.example.web&quot;/&gt;\n\n&lt;!-- ... --&gt;\n\n&lt;/beans&gt;\n`\n\n请求映射\n\n@RequestMapping可以将请求映射到具体的Controller方法上。通过找到匹配的url，http 方法，请求参数，header，媒体类型来映射请求。这个注解既可以用在类级别，也可以用在方法级别上。\n为了方便@RequestMapping根据HTTP方法不同提供了如下快捷注解：\n  - @GetMapping\n  - @PostMapping\n  - @DeleteMapping\n  - @PutMapping\n  - @PatchMapping\n\n示例如下所示：\n`Java\n@RestController\n@RequestMapping(&quot;/persons&quot;)\nclass PersonController {\n\n@GetMapping(&quot;/{id}&quot;)\npublic Person getPerson(@PathVariable Long id) {\n    // ...\n}\n\n@PostMapping\n@ResponseStatus(HttpStatus.CREATED)\npublic void add(@RequestBody Person person) {\n    // ...\n}\n\n}\n`\n\nURI 模式\n\n请求映射支持glob模式和通配符\n  - ? 匹配一个字符\n  - * 匹配0个或多个字符\n  - ** 匹配0个或多个路径\n可以通过@PathVariable 访问在URI中定义的变量：\nJava\n@GetMapping(&quot;/owners/{ownerId}/pets/{petId}&quot;)\npublic Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {\n    // ...\n}\n \nURI的变量可以在类和方法中定义：\n`Java\n@Controller\n@RequestMapping(&quot;/owners/{ownerId}&quot;)\npublic class OwnerController {\n\n@GetMapping(&quot;/pets/{petId}&quot;)\npublic Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {\n    // ...\n}\n\n}\n`","readingtime":5,"url":"/cates/backend/post/2018-04-10/spring-mvc-controller","dirs":["spring-mvc"],"relatives":[{"url":"/cates/backend/post/2018-04-07/deep-in-spring-mvc","title":"深入理解Spring MVC"},{"url":"/cates/backend/post/2018-04-09/spring-mvc-dispatcher-servlet","title":"SpringMVC 教程 - DispatcherServlet"},{"url":"/cates/backend/post/2018-04-09/spring-mvc-filter","title":"SpringMVC 教程 - Filter"}]}],"tag":"Spring"}}