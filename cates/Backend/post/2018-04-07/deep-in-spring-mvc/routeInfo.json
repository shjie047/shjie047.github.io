{"path":"cates/Backend/post/2018-04-07/deep-in-spring-mvc","templateID":2,"sharedPropsHashes":{"tags":"Zpc8p0"},"localProps":{"post":{"title":"深入理解Spring MVC","iso8601Date":"2018-04-07T08:39:10+08:00","basename":"deep-in-spring-mvc","cover":"https://coding.net/u/shjie047/p/images/git/raw/master/stock-photo-249089429.jpg","tags":["Backend","Java","Spring","SpringMVC","Web"],"date":"2018-04-07","cate":"Backend","summary":"原文地址  \n\n初始工程\n\n这篇文章中将使用最新的Spring Framework 5框架。主要关注的是Spring的经典Web技术栈，这套技术从最开始的Spring版本就开始支持，并且知道现在仍然是构建Spring Web应用的主要方式。使用Spring Boot和其他starter来设置初始工程。xml配置如下：\n`xml\n&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n    &lt;version&gt;2.0.1&lt;/version&gt;\n    &lt;relativePath/&gt;\n&lt;/parent&gt;\n\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n`\n\n测试项目\n\n为了理解Spring Web MVC是如何工作的，可以先实现一个简单的Login功能的。创建一个由@Controller来修饰的类InternalController，这个类包含一个Get的映射。hello()函数没有参数。返回一个由Spring解释的视图名字的字符串。（在本例中是login.html）  \n\n`Java\nimport org.springframework.web.bind.annotation.GetMapping;\n\n@GetMapping(&quot;/&quot;)\npublic String hello() {\n    return &quot;login&quot;;\n}\n`\n\n为了处理用户登陆逻辑，创建另一个接受POST请求的带有Login数据的方法。然后根据处理结果返回成功或者失败页面。\n注意，login()函数接受一个领域对象作为参数，返回的是ModelAndView对象。  \n\nJava\n@PostMapping(&quot;/login&quot;)\npublic ModelAndView login(LoginData loginData) {\n    if (LOGIN.equals(loginData.getLogin()) \n      &amp;&amp; PASSWORD.equals(loginData.getPassword())) {\n        return new ModelAndView(&quot;success&quot;, \n          Collections.singletonMap(&quot;login&quot;, loginData.getLogin()));\n    } else {\n        return new ModelAndView(&quot;failure&quot;, \n          Collections.singletonMap(&quot;login&quot;, loginData.getLogin()));\n    }\n}\n\n\nModelAndView保存了两个不同的对象：\n  - Model： 用来渲染页面用的键值对的map\n  - View： 填充Model数据的模版页面。  \n\n将它们合并起来是为了方便，这样controller的方法就可以同时返回这两个了。\n使用Thymeleaf作为模版引擎来渲染页面。  \n\nJava Web应用的基础-Servlet\n\n当你在浏览器里键入http://localhost:8080/ ，然后按回车键，请求到达服务器的时候到底发生了什么？是如何在浏览器中看到这个web请求的数据的？\n因为这个项目是一个简单的Spring Boot应用，所以可以通过Spring5Application来运行。\nSpring Boot默认使用Apache Tomcat运行程序，运行成功后可能会看到如下的日志：\n\n`bash\n2017-10-16 20:36:11.626  INFO 57414 --- [main] \n  o.s.b.w.embedded.tomcat.TomcatWebServer  : \n  Tomcat initialized with port(s): 8080 (http)\n\n2017-10-16 20:36:11.634  INFO 57414 --- [main] \n  o.apache.catalina.core.StandardService   : \n  Starting service [Tomcat]\n\n2017-10-16 20:36:11.635  INFO 57414 --- [main] \n  org.apache.catalina.core.StandardEngine  : \n  Starting Servlet Engine: Apache Tomcat/8.5.23\n`\n\n因为Tomcat是一个Servlet容器，所以几乎所有的HTTP请求都是由Java Servlet处理的。自然的Spring Web的入口就是一个Servlet。\nServlet是所有Java Web应用的核心组件；它非常的低成，并且没有暴露任何具体的编程模式，例如MVC。\n一个HTTP的Servelt只能接受HTTP请求，处理请求后返回响应。\n现在使用Servlet 3.0的API，可以不再使用XML配置，直接可以使用Java配置。\n\nSpring MVC的核心-DispatcherServlet\n\n作为Web开发者，我们希望抽象出以下枯燥和样板的任务，而关注于有用的业务逻辑  - 将HTTP请求映射到响应处理函数\n  - 将HTTP请求数据和header解析成数据传输对象（DTOs）或者领域对象\n  - model-view-controller 互相交互\n  - 从DTO，领域对象等生成响应  \n\nSpring的DispatcherServlet提供了以上的功能，是Spring WEB MVC框架的核心，是应用接受所有请求的核心组件。\n稍后就会了解到DispatcherServlet可扩展性非常强。例如：它允许你加入现有或者新的适配器来适应不同的任务：\n  - 将请求映射到处理它的类或者函数(由HandlerMapping实现）\n  - 使用特定模式来处理请求，例如一个普通的Servlet，一个复杂的MVC 工作流，或者只是一个方法。(由HandlerAdapter实现）\n  - 通过名字解析试图对象，允许你使用不同的模版引擎，例如：XML，XSLT或者其他视图技术(由ViewResolver实现）\n  - 默认使用Apache Comons 的文件上传组件解析文件上传，或者也可以自己实现。\n  - 由LocalResolver实现本地化，包括cookie，session，HTTP的Accept Header，或者其他由用户定义的本地化。    \n\n处理HTTP请求\n\n首先让我们重新审视一下在刚刚建立的应用中是如何处理HTTP请求的。\nDispatcherServlet有一个很长的继承层级。自顶向下理解每个单独的概念是非常有必要的。处理请求的函数将会更加有趣。\n\n理解HTTP请求在本地开发模式处理和远程处理是理解MVC架构非常重要的一步。\n\nGenericServlet\n\nGenericServlet时Servlet规范中的一部分，不直接处理HTTP。它定义了service()方法，来接受请求和返回响应。\n注意，ServletRequest和ServletResponse并不是绑定到HTTP协议的。\nJava\npublic abstract void service(ServletRequest req, ServletResponse res) \n  throws ServletException, IOException;\n\n服务器所有的请求，包括简单的GET请求都会调用这个方法。\n\nHttpServlet\n\n正如其名，HttpServelt是Servlet 规范中关于HTTP请求的实现。\n更确切的说，HttpServlet是一个实现了service()的抽象类。通过将不同的HTTP请求类型分开，由不同的函数处理，实现大约如下所示：\n`Java\nprotected void service(HttpServletRequest req, HttpServletResponse resp)\n    throws ServletException, IOException {\n\nString method = req.getMethod();\nif (method.equals(METHOD_GET)) {\n    // ...\n    doGet(req, resp);\n} else if (method.equals(METHOD_HEAD)) {\n    // ...\n    doHead(req, resp);\n} else if (method.equals(METHOD_POST)) {\n    doPost(req, resp);\n    // ...\n}\n\n`\n\nHttpServletBean\n\n在这个继承关系中HttpServletBean是第一个Spring的类。从web.xml或者WebApplicationInitialzer获取的初始参数来注入bean。\n在应用中的请求分别调用doGet,doPost等方法来处理不同的HTTP请求。\n\nFrameworkServlet\n\nFrameworkServlet实现了ApplicationContextAware,集成Web的Application Context。不过它也可以创建自己的Application Context。\n正如上述所言，父类HttpServletBean通过将初始参数作为bean的属性注入。因此如果contex的类名在contextClass这个初始参数中，那么就有这个参数创建application context的实例，否则默认使用XmlWebApplicationContext。\n由于XML配置现在已经过时了。Spring Boot默认使用AnnotationConfigWebApplicationContext来配置DispatcherServlet。不过这个是很容易修改的。\n例如，想要在Spring MVC中使用Groovy的application context，可以将下列配置在web.xml中\nbash\n  dispatcherServlet\n        org.springframework.web.servlet.DispatcherServlet\n        contextClass\n        org.springframework.web.context.support.GroovyWebApplicationContext\n\n相同的配置也可以在WebApplicationInitializer中配置。\n\nDispatcherServlet: 统一处理请求\n\nHttpServlet.service() 通过HTTP的动词类型来处理路由不同的请求到不同的方法，这个在底层的servlet实现的很好。但是，在SpringMVC的抽象层次中，不能仅靠方法类型来路由请求。\n同样的，FrameworkServlet的另一个主要功能就是将不同的处理使用processRequest()组合在一起。\n`Java\n@Override\nprotected final void doGet(HttpServletRequest request, \n  HttpServletResponse response) throws ServletException, IOException {\n    processRequest(request, response);\n}\n\n@Override\nprotected final void doPost(HttpServletRequest request, \n  HttpServletResponse response) throws ServletException, IOException {\n    processRequest(request, response);\n}\n`\n\nDispatcherServlet: 丰富请求\n\n最后,DispatcherServlet实现doService() 方法。它向请求中加入了一些有用的对象，继续在web 的管道中传递下去，例如：web application context, locale resolver, theme resolver, theme source等\nJava\nrequest.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, \n  getWebApplicationContext());\nrequest.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\nrequest.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\nrequest.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());\n\n同时，doService()加入了输入输出的Flash Map，Flash Map是将参数从一个请求传递到另一个请求的基本模式。在重定向中很有用。(例如在重定向之后向用户展示一段简单的信息）\nJava\nFlashMap inputFlashMap = this.flashMapManager\n  .retrieveAndUpdate(request, response);\nif (inputFlashMap != null) {\n    request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, \n      Collections.unmodifiableMap(inputFlashMap));\n}\nrequest.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());\n\n接着doService() 将会调用doDispatch()方法来分发请求。\n\nDispatcherServlet: 分发请求\n\ndispatch() 的主要目的就是知道一个合适的处理请求的处理器并且传递request/response参数。处理器可以是任何对象，并不局限于一个特定的接口。同样也意味着Spring需要找到如何使用这个处理器的适配器。\n为了给请求找到合适的处理器，Spring会遍历实现HandlerMapping接口的注册的实现。有很多不同的实现可以满足我们各种需求。\nSimpleUrlHandlerMapping使用URL将请求映射到处理bean中。例如：它可以通过Java.util.Properties 注入它的映射信息：\nbash\n/welcome.html=ticketController\n/show.html=ticketController\n\nRequestMappingHandlerMapping可能是最广泛使用的映射处理器。它将请求映射到@Controller类下的@RequestMapping修饰的方法上。这个就是上面那个例子中的hello()和login()。\n注意，上面两个方法分别是@GetMapping和@PostMapping修饰的。这两个注解来源于@RequestMapping。\ndispatch() 同时也可以处理一些其他的HTTP的任务：\n  - 如果资源不存在，对GET请求进行短路处理。\n  - 对相应的请求使用multipart 解析。\n  - 如果处理器选择异步处理请求，对请求进行短路处理。  \n\n处理请求\n\n现在Spring确定了处理请求的处理器和处理器的适配器，是时候处理请求了。下面是HandlerAdapter.handle() 的签名。比较重要的一点是处理器可以选择如何处理请求：\n  - 直接将相应写入到response body 和 返回null\n  - 返回一个ModelAndView对象由DispatcherServlet渲染。  \n\nJava\n@Nullable\nModelAndView handle(HttpServletRequest request, \n                    HttpServletResponse response, \n                    Object handler) throws Exception;\n\nSpring提供了很多类型的处理器，下面是SimpleControllerHandlerAdapter如何处理Spring MVC的controller实例的(不要和@Controller搞混)。\n注意，controller处理器返回ModelAndView对象并不是由起渲染的。\nJava\npublic ModelAndView handle(HttpServletRequest request, \n  HttpServletResponse response, Object handler) throws Exception {\n    return ((Controller) handler).handleRequest(request, response);\n}\n\n第二个是SimpleServletHandlerAdapter它对一个普通的servlet适配。\nservlet并不知道ModelAndView，完全自己处理请求，将返回写入到相应的body中。因此它的适配器就直接返回null。\nJava\npublic ModelAndView handle(HttpServletRequest request, \n  HttpServletResponse response, Object handler) throws Exception {\n    ((Servlet) handler).service(request, response);\n    return null;\n}\n\n在本例中，controller是由@RequestMapping修饰的POJO，因此处理器会使用HandlerMethod来封装它的方法。Spring使用RequestMappingHandlerAdapter来适配这种处理器类型。\n\n处理参数，返回处理器函数的值\n\n注意，一般来说controller并不会接收HttpServletRequest和HttpServletResponse作为参数，但是它可以接收和返回很多中其他类型，例如：领域对象，路径参数等。\n同样，也不强求一个controller返回一个ModelAndView实例。可以选择返回一个视图名称，ResponseEntity，或者是一个可以被转换成JSON的POJO。\nRequestMappingHandlerAdapter可以保证从HttpServletRequest中解析方法需要的参数，同时创建ModelAndView对象返回。\n下面这段代码就是RequestMappingHandlerAdapter中保证这件事情的：\nJava\nServletInvocableHandlerMethod invocableMethod \n  = createInvocableHandlerMethod(handlerMethod);\nif (this.argumentResolvers != null) {\n    invocableMethod.setHandlerMethodArgumentResolvers(\n      this.argumentResolvers);\n}\nif (this.returnValueHandlers != null) {\n    invocableMethod.setHandlerMethodReturnValueHandlers(\n      this.returnValueHandlers);\n}\n\nargumentResolvers在HandlerMethodArgumentResolver实例中有不同实现。一共有30多种不同的参数解析器的实现。他们可以从请求参数将函数需要的参数解析出来。包括：url路径变量，请求体参数，请求头，cookies，session等。\nreturnValueHandlers在HandlerMethodArgumentResolver实例中有不同实现。同样也有很多不同的返回值处理器来处理方法返回的结果，创建ModelAndView对象。\n例如：当函数hello()返回一个string的时候，ViewNameMethodReturnValueHandler处理这个值。login()返回一个ModelAndView对象的时候，Sring使用ModelAndViewMethodReturnValueHandler处理这个值。\n\n渲染视图\n\n现在Spring已经处理了HTTP请求，获取了ModelAndView实例，现在它需要在用户浏览器渲染HTML页面了。它依赖于由Model和选择的模版组成的ModelAndView对象。\n同样的，Spring也可以渲染JSON ,XML或者其他HTTP协议接受的类型。这些将在接下来的REST相关了解更多。\n现在回去看一下DispatcherServlet。 render() 首先使用LocaleResolver实例设置返回的Local。首先假设浏览器已经正确设置Accetp头。默认使用AcceptHeaderLocaleResolver来处理。\n在渲染过程中，ModelAndView可以包含一个视图的名字或者是已经选择的视图，或者如果controller依赖于默认视图也可以没有。\n既然hello()和login()方法制定了字符串名字作为视图名称，所以需要使用viewResolvers来查找视图。\nJava\nfor (ViewResolver viewResolver : this.viewResolvers) {\n    View view = viewResolver.resolveViewName(viewName, locale);\n    if (view != null) {\n        return view;\n    }\n}\n\nViewResolver的实现由很多，这里使用了由thymeleaf-spring5提供的ThymeleafViewResolver实现。解析器知道去哪里查找视图，并且提供相应的视图实例。\n调用完render()之后，Spring就完成了将HTML页面渲染到用户浏览器的任务。\n\nREST 支持\n\n除了MVC的场景，我们可以使用狂减创建rest web service。\n一个简单的场景，可以使用由@RequestBody修饰的POJO作为参数。由@ResponseBody修饰方法，指定方法的返回结果直接写入到响应体中。  \n\n`Java\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@ResponseBody\n@PostMapping(&quot;/message&quot;)\npublic MyOutputResource sendMessage(\n  @RequestBody MyInputResource inputResource) {\n\nreturn new MyOutputResource(&quot;Received: &quot;\n  + inputResource.getRequestMessage());\n\n}\n`\n\n感谢SpringMVC的扩展性，这样做也是可以的。\n框架使用HttpMessageConverter将内部DTO转换成REST的表示。例如：MappingJackson2HttpMessageConverter的可以使用Jackson库将转换model和JSON。\n为了简化创建REST API，Srping 引入了@RestController注解。默认使用@ResonseBody这样就不需要在每个方法中使用了。\n`Java\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class RestfulWebServiceController {\n\n@GetMapping(&quot;/message&quot;)\npublic MyOutputResource getMessage() {\n    return new MyOutputResource(&quot;Hello!&quot;);\n}\n\n}\n`\n\n结论\n\n在这篇文章中，详细描述了Spring MVC处理HTTP请求的各个步骤。了解到Spring 框架是如何将各个组件组合在一起提供处理HTTP协议的。","readingtime":17,"url":"/cates/Backend/post/2018-04-07/deep-in-spring-mvc","dirs":["spring-mvc"],"relatives":[{"url":"/cates/Backend/post/2018-04-10/spring-mvc-controller","title":"SpringMVC 教程 - Controller"},{"url":"/cates/Backend/post/2018-04-09/spring-mvc-dispatcher-servlet","title":"SpringMVC 教程 - DispatcherServlet"},{"url":"/cates/Backend/post/2018-04-09/spring-mvc-filter","title":"SpringMVC 教程 - Filter"}],"body":"\n\n[原文地址](https://stackify.com/spring-mvc/)  \n##### 初始工程\n这篇文章中将使用最新的Spring Framework 5框架。主要关注的是Spring的经典Web技术栈，这套技术从最开始的Spring版本就开始支持，并且知道现在仍然是构建Spring Web应用的主要方式。  \n使用Spring Boot和其他starter来设置初始工程。xml配置如下：\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.0.1</version>\n    <relativePath/>\n</parent>\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-thymeleaf</artifactId>\n    </dependency>\n</dependencies>\n```\n##### 测试项目\n为了理解Spring Web MVC是如何工作的，可以先实现一个简单的Login功能的。创建一个由`@Controller`来修饰的类`InternalController`，这个类包含一个Get的映射。  \n`hello()`函数没有参数。返回一个由Spring解释的视图名字的字符串。（在本例中是`login.html`）  \n\n```Java\nimport org.springframework.web.bind.annotation.GetMapping;\n\n@GetMapping(\"/\")\npublic String hello() {\n    return \"login\";\n}\n```\n\n为了处理用户登陆逻辑，创建另一个接受POST请求的带有Login数据的方法。然后根据处理结果返回成功或者失败页面。\n注意，`login()`函数接受一个领域对象作为参数，返回的是`ModelAndView`对象。  \n\n```Java\n@PostMapping(\"/login\")\npublic ModelAndView login(LoginData loginData) {\n    if (LOGIN.equals(loginData.getLogin()) \n      && PASSWORD.equals(loginData.getPassword())) {\n        return new ModelAndView(\"success\", \n          Collections.singletonMap(\"login\", loginData.getLogin()));\n    } else {\n        return new ModelAndView(\"failure\", \n          Collections.singletonMap(\"login\", loginData.getLogin()));\n    }\n}\n```\n\n`ModelAndView`保存了两个不同的对象：\n  - Model： 用来渲染页面用的键值对的map\n  - View： 填充Model数据的模版页面。  \n\n将它们合并起来是为了方便，这样controller的方法就可以同时返回这两个了。\n使用`Thymeleaf`作为模版引擎来渲染页面。  \n##### Java Web应用的基础-Servlet\n当你在浏览器里键入`http://localhost:8080/ `，然后按回车键，请求到达服务器的时候到底发生了什么？是如何在浏览器中看到这个web请求的数据的？\n因为这个项目是一个简单的Spring Boot应用，所以可以通过`Spring5Application`来运行。\nSpring Boot默认使用[Apache Tomcat](http://stackify.com/tomcat-performance-monitoring/)运行程序，运行成功后可能会看到如下的日志：\n\n```bash\n2017-10-16 20:36:11.626  INFO 57414 --- [main] \n  o.s.b.w.embedded.tomcat.TomcatWebServer  : \n  Tomcat initialized with port(s): 8080 (http)\n  \n2017-10-16 20:36:11.634  INFO 57414 --- [main] \n  o.apache.catalina.core.StandardService   : \n  Starting service [Tomcat]\n\n2017-10-16 20:36:11.635  INFO 57414 --- [main] \n  org.apache.catalina.core.StandardEngine  : \n  Starting Servlet Engine: Apache Tomcat/8.5.23\n```\n\n因为Tomcat是一个Servlet容器，所以几乎所有的HTTP请求都是由Java Servlet处理的。自然的Spring Web的入口就是一个Servlet。\nServlet是所有Java Web应用的核心组件；它非常的低成，并且没有暴露任何具体的编程模式，例如MVC。\n一个HTTP的Servelt只能接受HTTP请求，处理请求后返回响应。\n现在使用Servlet 3.0的API，可以不再使用XML配置，直接可以使用Java配置。\n##### Spring MVC的核心-DispatcherServlet\n作为Web开发者，我们希望抽象出以下枯燥和样板的任务，而关注于有用的业务逻辑  \n  - 将HTTP请求映射到响应处理函数\n  - 将HTTP请求数据和header解析成数据传输对象（DTOs）或者领域对象\n  - model-view-controller 互相交互\n  - 从DTO，领域对象等生成响应  \n\nSpring的`DispatcherServlet`提供了以上的功能，是Spring WEB MVC框架的核心，是应用接受所有请求的核心组件。\n稍后就会了解到`DispatcherServlet`可扩展性非常强。例如：它允许你加入现有或者新的适配器来适应不同的任务：\n  - 将请求映射到处理它的类或者函数(由`HandlerMapping`实现）\n  - 使用特定模式来处理请求，例如一个普通的Servlet，一个复杂的MVC 工作流，或者只是一个方法。(由`HandlerAdapter`实现）\n  - 通过名字解析试图对象，允许你使用不同的模版引擎，例如：XML，XSLT或者其他视图技术(由`ViewResolver`实现）\n  - 默认使用Apache Comons 的文件上传组件解析文件上传，或者也可以自己实现。\n  - 由`LocalResolver`实现本地化，包括cookie，session，HTTP的Accept Header，或者其他由用户定义的本地化。    \n\n##### 处理HTTP请求\n首先让我们重新审视一下在刚刚建立的应用中是如何处理HTTP请求的。\n`DispatcherServlet`有一个很长的继承层级。自顶向下理解每个单独的概念是非常有必要的。处理请求的函数将会更加有趣。\n![SpringMVC](https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/springmvc.png)\n理解HTTP请求在本地开发模式处理和远程处理是理解MVC架构非常重要的一步。\n###### GenericServlet\n`GenericServlet`时Servlet规范中的一部分，不直接处理HTTP。它定义了`service()`方法，来接受请求和返回响应。\n注意，`ServletRequest`和`ServletResponse`并不是绑定到HTTP协议的。\n```Java\npublic abstract void service(ServletRequest req, ServletResponse res) \n  throws ServletException, IOException;\n```\n服务器所有的请求，包括简单的GET请求都会调用这个方法。\n##### HttpServlet\n正如其名，`HttpServelt`是Servlet 规范中关于HTTP请求的实现。\n更确切的说，`HttpServlet`是一个实现了`service()`的抽象类。通过将不同的HTTP请求类型分开，由不同的函数处理，实现大约如下所示：\n```Java\nprotected void service(HttpServletRequest req, HttpServletResponse resp)\n    throws ServletException, IOException {\n\n    String method = req.getMethod();\n    if (method.equals(METHOD_GET)) {\n        // ...\n        doGet(req, resp);\n    } else if (method.equals(METHOD_HEAD)) {\n        // ...\n        doHead(req, resp);\n    } else if (method.equals(METHOD_POST)) {\n        doPost(req, resp);\n        // ...\n    }\n```\n\n##### HttpServletBean\n在这个继承关系中`HttpServletBean`是第一个Spring的类。从web.xml或者WebApplicationInitialzer获取的初始参数来注入bean。\n在应用中的请求分别调用doGet,doPost等方法来处理不同的HTTP请求。\n##### FrameworkServlet\n`FrameworkServlet`实现了`ApplicationContextAware`,集成Web的Application Context。不过它也可以创建自己的Application Context。\n正如上述所言，父类`HttpServletBean`通过将初始参数作为bean的属性注入。因此如果contex的类名在`contextClass`这个初始参数中，那么就有这个参数创建application context的实例，否则默认使用`XmlWebApplicationContext`。\n由于XML配置现在已经过时了。Spring Boot默认使用`AnnotationConfigWebApplicationContext`来配置`DispatcherServlet`。不过这个是很容易修改的。\n例如，想要在Spring MVC中使用Groovy的application context，可以将下列配置在web.xml中\n```bash\n  dispatcherServlet\n        org.springframework.web.servlet.DispatcherServlet\n        contextClass\n        org.springframework.web.context.support.GroovyWebApplicationContext\n```\n相同的配置也可以在`WebApplicationInitializer`中配置。\n##### DispatcherServlet: 统一处理请求\n`HttpServlet.service() `通过HTTP的动词类型来处理路由不同的请求到不同的方法，这个在底层的servlet实现的很好。但是，在SpringMVC的抽象层次中，不能仅靠方法类型来路由请求。\n同样的，`FrameworkServlet`的另一个主要功能就是将不同的处理使用`processRequest()`组合在一起。\n```Java\n@Override\nprotected final void doGet(HttpServletRequest request, \n  HttpServletResponse response) throws ServletException, IOException {\n    processRequest(request, response);\n}\n\n@Override\nprotected final void doPost(HttpServletRequest request, \n  HttpServletResponse response) throws ServletException, IOException {\n    processRequest(request, response);\n}\n```\n##### DispatcherServlet: 丰富请求\n最后,`DispatcherServlet`实现`doService() `方法。它向请求中加入了一些有用的对象，继续在web 的管道中传递下去，例如：web application context, locale resolver, theme resolver, theme source等\n```Java\nrequest.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, \n  getWebApplicationContext());\nrequest.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\nrequest.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\nrequest.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());\n```\n同时，`doService()`加入了输入输出的Flash Map，Flash Map是将参数从一个请求传递到另一个请求的基本模式。在重定向中很有用。(例如在重定向之后向用户展示一段简单的信息）\n```Java\nFlashMap inputFlashMap = this.flashMapManager\n  .retrieveAndUpdate(request, response);\nif (inputFlashMap != null) {\n    request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, \n      Collections.unmodifiableMap(inputFlashMap));\n}\nrequest.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());\n```\n接着`doService() `将会调用`doDispatch()`方法来分发请求。\n\n##### DispatcherServlet: 分发请求\n`dispatch() `的主要目的就是知道一个合适的处理请求的处理器并且传递request/response参数。处理器可以是任何对象，并不局限于一个特定的接口。同样也意味着Spring需要找到如何使用这个处理器的适配器。\n为了给请求找到合适的处理器，Spring会遍历实现`HandlerMapping`接口的注册的实现。有很多不同的实现可以满足我们各种需求。\n`SimpleUrlHandlerMapping`使用URL将请求映射到处理bean中。例如：它可以通过`Java.util.Properties `注入它的映射信息：\n```bash\n/welcome.html=ticketController\n/show.html=ticketController\n```\n`RequestMappingHandlerMapping`可能是最广泛使用的映射处理器。它将请求映射到`@Controller`类下的`@RequestMapping`修饰的方法上。这个就是上面那个例子中的`hello()`和`login()`。\n注意，上面两个方法分别是`@GetMapping`和`@PostMapping`修饰的。这两个注解来源于`@RequestMapping`。\n`dispatch() `同时也可以处理一些其他的HTTP的任务：\n  - 如果资源不存在，对GET请求进行短路处理。\n  - 对相应的请求使用multipart 解析。\n  - 如果处理器选择异步处理请求，对请求进行短路处理。  \n\n#####  处理请求\n现在Spring确定了处理请求的处理器和处理器的适配器，是时候处理请求了。下面是`HandlerAdapter.handle() `的签名。比较重要的一点是处理器可以选择如何处理请求：\n  - 直接将相应写入到response body 和 返回null\n  - 返回一个`ModelAndView`对象由`DispatcherServlet`渲染。  \n\n```Java\n@Nullable\nModelAndView handle(HttpServletRequest request, \n                    HttpServletResponse response, \n                    Object handler) throws Exception;\n```\nSpring提供了很多类型的处理器，下面是`SimpleControllerHandlerAdapter`如何处理Spring MVC的controller实例的(不要和@Controller搞混)。\n注意，controller处理器返回ModelAndView对象并不是由起渲染的。\n```Java\npublic ModelAndView handle(HttpServletRequest request, \n  HttpServletResponse response, Object handler) throws Exception {\n    return ((Controller) handler).handleRequest(request, response);\n}\n```\n第二个是`SimpleServletHandlerAdapter`它对一个普通的servlet适配。\nservlet并不知道`ModelAndView`，完全自己处理请求，将返回写入到相应的body中。因此它的适配器就直接返回null。\n```Java\npublic ModelAndView handle(HttpServletRequest request, \n  HttpServletResponse response, Object handler) throws Exception {\n    ((Servlet) handler).service(request, response);\n    return null;\n}\n```\n在本例中，controller是由`@RequestMapping`修饰的POJO，因此处理器会使用`HandlerMethod`来封装它的方法。Spring使用`RequestMappingHandlerAdapter`来适配这种处理器类型。\n##### 处理参数，返回处理器函数的值\n注意，一般来说controller并不会接收`HttpServletRequest`和`HttpServletResponse`作为参数，但是它可以接收和返回很多中其他类型，例如：领域对象，路径参数等。\n同样，也不强求一个controller返回一个`ModelAndView`实例。可以选择返回一个视图名称，`ResponseEntity`，或者是一个可以被转换成JSON的POJO。\n`RequestMappingHandlerAdapter`可以保证从`HttpServletRequest`中解析方法需要的参数，同时创建`ModelAndView`对象返回。\n下面这段代码就是`RequestMappingHandlerAdapter`中保证这件事情的：\n```Java\nServletInvocableHandlerMethod invocableMethod \n  = createInvocableHandlerMethod(handlerMethod);\nif (this.argumentResolvers != null) {\n    invocableMethod.setHandlerMethodArgumentResolvers(\n      this.argumentResolvers);\n}\nif (this.returnValueHandlers != null) {\n    invocableMethod.setHandlerMethodReturnValueHandlers(\n      this.returnValueHandlers);\n}\n```\n`argumentResolvers`在`HandlerMethodArgumentResolver`实例中有不同实现。一共有30多种不同的参数解析器的实现。他们可以从请求参数将函数需要的参数解析出来。包括：url路径变量，请求体参数，请求头，cookies，session等。\n`returnValueHandlers`在`HandlerMethodArgumentResolver`实例中有不同实现。同样也有很多不同的返回值处理器来处理方法返回的结果，创建`ModelAndView`对象。\n例如：当函数`hello()`返回一个string的时候，`ViewNameMethodReturnValueHandler`处理这个值。`login()`返回一个`ModelAndView`对象的时候，Sring使用`ModelAndViewMethodReturnValueHandler`处理这个值。\n##### 渲染视图\n现在Spring已经处理了HTTP请求，获取了`ModelAndView`实例，现在它需要在用户浏览器渲染HTML页面了。它依赖于由Model和选择的模版组成的`ModelAndView`对象。\n同样的，Spring也可以渲染JSON ,XML或者其他HTTP协议接受的类型。这些将在接下来的REST相关了解更多。\n现在回去看一下`DispatcherServlet`。` render() `首先使用`LocaleResolver`实例设置返回的Local。首先假设浏览器已经正确设置Accetp头。默认使用`AcceptHeaderLocaleResolver`来处理。\n在渲染过程中，`ModelAndView`可以包含一个视图的名字或者是已经选择的视图，或者如果controller依赖于默认视图也可以没有。\n既然`hello()`和`login()`方法制定了字符串名字作为视图名称，所以需要使用viewResolvers来查找视图。\n```Java\nfor (ViewResolver viewResolver : this.viewResolvers) {\n    View view = viewResolver.resolveViewName(viewName, locale);\n    if (view != null) {\n        return view;\n    }\n}\n```\nViewResolver的实现由很多，这里使用了由`thymeleaf-spring5`提供的`ThymeleafViewResolver`实现。解析器知道去哪里查找视图，并且提供相应的视图实例。\n调用完`render()`之后，Spring就完成了将HTML页面渲染到用户浏览器的任务。\n##### REST 支持\n除了MVC的场景，我们可以使用狂减创建rest web service。\n一个简单的场景，可以使用由`@RequestBody`修饰的POJO作为参数。由`@ResponseBody`修饰方法，指定方法的返回结果直接写入到响应体中。  \n\n```Java\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@ResponseBody\n@PostMapping(\"/message\")\npublic MyOutputResource sendMessage(\n  @RequestBody MyInputResource inputResource) {\n    \n    return new MyOutputResource(\"Received: \"\n      + inputResource.getRequestMessage());\n}\n```\n\n感谢SpringMVC的扩展性，这样做也是可以的。\n框架使用`HttpMessageConverter`将内部DTO转换成REST的表示。例如：`MappingJackson2HttpMessageConverter`的可以使用Jackson库将转换model和JSON。\n为了简化创建REST API，Srping 引入了`@RestController`注解。默认使用`@ResonseBody`这样就不需要在每个方法中使用了。\n```Java\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class RestfulWebServiceController {\n\n    @GetMapping(\"/message\")\n    public MyOutputResource getMessage() {\n        return new MyOutputResource(\"Hello!\");\n    }\n}\n```\n##### 结论\n在这篇文章中，详细描述了Spring MVC处理HTTP请求的各个步骤。了解到Spring 框架是如何将各个组件组合在一起提供处理HTTP协议的。\n\n\n"}}}