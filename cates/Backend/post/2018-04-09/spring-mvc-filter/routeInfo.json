{"path":"cates/Backend/post/2018-04-09/spring-mvc-filter","templateID":2,"sharedPropsHashes":{"tags":"Zpc8p0"},"localProps":{"post":{"title":"SpringMVC 教程 - Filter","iso8601Date":"2018-04-09T08:39:10+08:00","basename":"spring-mvc-filter","cover":"https://coding.net/u/shjie047/p/images/git/raw/master/stock-photo-247383127.jpg","tags":["Backend","Java","SpringMVC","Spring"],"date":"2018-04-09","cate":"Backend","summary":"简介\n\nspring-web模块提供了许多非常实用的Filter\n\nHTTP PUT FORM\n\n浏览器只能通过GET或者POST提交FORM数据，但是非浏览器的客户端可以使用PUT或者PATCH。Servlet API仅为POST方法提供了ServletRequest.getParameter*()方法获取FORM信息。\nspring-web模块提供了HttpPutFormContentFilter检查PUT或者PATCH方法的content-type是否是application/x-www-form-urlencoded,如果是，则从请求体重读取属性并封装到ServletRequest中，以便日后通过ServletRequest.getParameter*()获取FORM数据。\n\n重定向头\n\n由于请求会经过像负载均衡器这样的代理，那么host，port，scheme在创建一些资源文件的链接的时候返回给客户端可能是有所不同的。\nRFC 7239 为代理定义了Forwarded 的HTTP头来提供原始请求的信息。同样也有一些其他非标准的HTTP头，例如：X-Forwarded-Host,X-Forwarded-Port,X-Forwarded-Proto。\nForwardedHeaderFilter会从Forwarded,X-Forwarded-Host,X-Forwarded-Port或者X-Forwarded-Proto中获取跳转信息。他分装了请求以覆盖host，port，scheme，同样为日后的处理隐藏跳转信息。\n注意，根据RFC 7239第八节的解释，使用重定向头的时候会有安全问题。在应用层是无法判断一个挑战是否是可信的。所以要正确配置网络上游代理，以便过滤掉不合法的跳转。\n如果应用没有使用代理，那么就无需使用ForwardedHeaderFilter过滤器。\n\nShallow ETag\n\nShallowEtagHeaderFilter为ETG提供了过滤器，关于ETAG将在视图技术中详细解释。\n\nCORS\n\n通过controller的注解Spring MVC对CORS提供了详细的支持。在和Spring Sercurity一同使用的时候CorsFilter必须排在Spring Sercurity的过滤器之前。\n\n关于CORS\n\n由于安全原因，浏览器禁止AJAX跳出当前域去访问资源。例如你的银行帐号在一个tab页打卡了，另一个evil.com在其他tab打开。evil.com的脚本不能使用你的银行账号信息去访问银行的API。\nCross-Origin Resource Sharing (CORS) 是由众多浏览器实现的W3C的规范。他规定了允许哪些请求可以跨域，而不是通过弱安全的和功能受限的IFRAME和JSONP。\nHandlerMapping对CORS提供了内置支持。成功将请求映射到处理器后，HandlerMapping对当前请求检查CORS配置，预检请求直接处理，简单和实际请求则检查CORS请求，验证，设置返回header。\n为了开启跨域请求（例如Origin头和请求的host不一致），需要对CORS进行明确的配置。如果没有找到CORS的配置，那么直接拒绝预检请求，简单请求和实际请求不会添加响应头，因此浏览器不会获取到信息。\n每一个HandlerMapping都可以根据URL不同配置单独的 CorsConfiguration。一般来说应用会通过Java Config或者Xml 命名空间来配置单一，全局的CORS。\nHandlerMapping级别的全局CORS配置可以和handler级别的CORS合并。例如有注解的controller可以使用类或者方法级别的注解@CrossOrigin配置跨域。\n@CrossOrigin注解可以在controller层启动对请求的跨域检查，例如：\n`Java\n@RestController\n@RequestMapping(&quot;/account&quot;)\npublic class AccountController {\n\n@CrossOrigin\n@GetMapping(&quot;/{id}&quot;)\npublic Account retrieve(@PathVariable Long id) {\n    // ...\n}\n\n@DeleteMapping(&quot;/{id}&quot;)\npublic void remove(@PathVariable Long id) {\n    // ...\n}\n\n}\n\n默认情况下`@CrossOrigin`的作用如下：\n  - 允许所有的域\n  - 允许所有header\n  - 允许controller映射的方法\n  - `allowedCredentials` 默认关闭\n  - `max-age`默认30分钟\n`@CrossOrigin`同样支持类级别：\nJava\n@CrossOrigin(origins = &quot;http://domain2.com&quot;, maxAge = 3600)\n@RestController\n@RequestMapping(&quot;/account&quot;)\npublic class AccountController {\n\n@GetMapping(&quot;/{id}&quot;)\npublic Account retrieve(@PathVariable Long id) {\n    // ...\n}\n\n@DeleteMapping(&quot;/{id}&quot;)\npublic void remove(@PathVariable Long id) {\n    // ...\n}\n\n}\n\n`@CrossOrigin`同时可以在类和方法中使用：\nJava\n@CrossOrigin(maxAge = 3600)\n@RestController\n@RequestMapping(&quot;/account&quot;)\npublic class AccountController {\n\n@CrossOrigin(&quot;http://domain2.com&quot;)\n@GetMapping(&quot;/{id}&quot;)\npublic Account retrieve(@PathVariable Long id) {\n    // ...\n}\n\n@DeleteMapping(&quot;/{id}&quot;)\npublic void remove(@PathVariable Long id) {\n    // ...\n}\n\n}\n\n通过定义全局的CORS配置，来配合使用。全局的CORS配置可以通过Java Config或者XML的XNM命名空间来配置。\n默认情况下全局的CORS配置：\n  - 允许所有的域\n  - 允许所有的header\n  - 允许GET,HEAD，POST方法\n  - `allowedCredentials` 默认关闭\n  - `max-age`默认30分钟\n使用Java配置CORS\nJava\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n@Override\npublic void addCorsMappings(CorsRegistry registry) {\n\n    registry.addMapping(&quot;/api/**&quot;)\n        .allowedOrigins(&quot;http://domain2.com&quot;)\n        .allowedMethods(&quot;PUT&quot;, &quot;DELETE&quot;)\n        .allowedHeaders(&quot;header1&quot;, &quot;header2&quot;, &quot;header3&quot;)\n        .exposedHeaders(&quot;header1&quot;, &quot;header2&quot;)\n        .allowCredentials(true).maxAge(3600);\n\n    // Add more mappings...\n}\n\n}\n\n使用XML配置CORS\nXml\n&lt;mvc:cors&gt;\n\n&lt;mvc:mapping path=&quot;/api/**&quot;\n    allowed-origins=&quot;http://domain1.com, http://domain2.com&quot;\n    allowed-methods=&quot;GET, PUT&quot;\n    allowed-headers=&quot;header1, header2, header3&quot;\n    exposed-headers=&quot;header1, header2&quot; allow-credentials=&quot;true&quot;\n    max-age=&quot;123&quot; /&gt;\n\n&lt;mvc:mapping path=&quot;/resources/**&quot;\n    allowed-origins=&quot;http://domain1.com&quot; /&gt;\n\n&lt;/mvc:cors&gt;\n\n另外，也可以通过`CorsFilter`配置CORS。\nJava\nCorsConfiguration config = new CorsConfiguration();\n\n// Possibly...\n// config.applyPermitDefaultValues()\n\nconfig.setAllowCredentials(true);\nconfig.addAllowedOrigin(&quot;http://domain1.com&quot;);\nconfig.addAllowedHeader(&quot;&quot;);\nconfig.addAllowedMethod(&quot;&quot;);\n\nUrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\nsource.registerCorsConfiguration(&quot;/**&quot;, config);\n\nCorsFilter filter = new CorsFilter(source);\n`","readingtime":8,"url":"/cates/Backend/post/2018-04-09/spring-mvc-filter","dirs":["spring-mvc"],"relatives":[{"url":"/cates/Backend/post/2018-04-07/deep-in-spring-mvc","title":"深入理解Spring MVC"},{"url":"/cates/Backend/post/2018-04-10/spring-mvc-controller","title":"SpringMVC 教程 - Controller"},{"url":"/cates/Backend/post/2018-04-09/spring-mvc-dispatcher-servlet","title":"SpringMVC 教程 - DispatcherServlet"}],"body":"\n\n##### 简介\n`spring-web`模块提供了许多非常实用的Filter\n##### HTTP PUT FORM\n浏览器只能通过GET或者POST提交FORM数据，但是非浏览器的客户端可以使用PUT或者PATCH。Servlet API仅为POST方法提供了`ServletRequest.getParameter*()`方法获取FORM信息。\n`spring-web`模块提供了`HttpPutFormContentFilter`检查PUT或者PATCH方法的`content-type`是否是`application/x-www-form-urlencoded`,如果是，则从请求体重读取属性并封装到`ServletRequest`中，以便日后通过`ServletRequest.getParameter*()`获取FORM数据。\n##### 重定向头\n由于请求会经过像负载均衡器这样的代理，那么host，port，scheme在创建一些资源文件的链接的时候返回给客户端可能是有所不同的。\nRFC 7239 为代理定义了`Forwarded` 的HTTP头来提供原始请求的信息。同样也有一些其他非标准的HTTP头，例如：`X-Forwarded-Host`,`X-Forwarded-Port`,`X-Forwarded-Proto`。\n`ForwardedHeaderFilter`会从`Forwarded`,`X-Forwarded-Host`,`X-Forwarded-Port`或者`X-Forwarded-Proto`中获取跳转信息。他分装了请求以覆盖host，port，scheme，同样为日后的处理隐藏跳转信息。\n注意，根据RFC 7239第八节的解释，使用重定向头的时候会有安全问题。在应用层是无法判断一个挑战是否是可信的。所以要正确配置网络上游代理，以便过滤掉不合法的跳转。\n如果应用没有使用代理，那么就无需使用`ForwardedHeaderFilter`过滤器。\n##### Shallow ETag\n`ShallowEtagHeaderFilter`为ETG提供了过滤器，关于ETAG将在视图技术中详细解释。\n##### CORS\n通过controller的注解Spring MVC对CORS提供了详细的支持。在和Spring Sercurity一同使用的时候`CorsFilter`必须排在Spring Sercurity的过滤器之前。\n##### 关于CORS\n由于安全原因，浏览器禁止AJAX跳出当前域去访问资源。例如你的银行帐号在一个tab页打卡了，另一个evil.com在其他tab打开。evil.com的脚本不能使用你的银行账号信息去访问银行的API。\nCross-Origin Resource Sharing (CORS) 是由众多浏览器实现的W3C的规范。他规定了允许哪些请求可以跨域，而不是通过弱安全的和功能受限的IFRAME和JSONP。\n`HandlerMapping`对CORS提供了内置支持。成功将请求映射到处理器后，`HandlerMapping`对当前请求检查CORS配置，预检请求直接处理，简单和实际请求则检查CORS请求，验证，设置返回header。\n为了开启跨域请求（例如`Origin`头和请求的host不一致），需要对CORS进行明确的配置。如果没有找到CORS的配置，那么直接拒绝预检请求，简单请求和实际请求不会添加响应头，因此浏览器不会获取到信息。\n每一个`HandlerMapping`都可以根据URL不同配置单独的 `CorsConfiguration`。一般来说应用会通过Java Config或者Xml 命名空间来配置单一，全局的CORS。\n`HandlerMapping`级别的全局CORS配置可以和handler级别的CORS合并。例如有注解的controller可以使用类或者方法级别的注解`@CrossOrigin`配置跨域。\n`@CrossOrigin`注解可以在controller层启动对请求的跨域检查，例如：\n```Java\n@RestController\n@RequestMapping(\"/account\")\npublic class AccountController {\n\n    @CrossOrigin\n    @GetMapping(\"/{id}\")\n    public Account retrieve(@PathVariable Long id) {\n        // ...\n    }\n\n    @DeleteMapping(\"/{id}\")\n    public void remove(@PathVariable Long id) {\n        // ...\n    }\n}\n```\n默认情况下`@CrossOrigin`的作用如下：\n  - 允许所有的域\n  - 允许所有header\n  - 允许controller映射的方法\n  - `allowedCredentials` 默认关闭\n  - `max-age`默认30分钟\n`@CrossOrigin`同样支持类级别：\n```Java\n@CrossOrigin(origins = \"http://domain2.com\", maxAge = 3600)\n@RestController\n@RequestMapping(\"/account\")\npublic class AccountController {\n\n    @GetMapping(\"/{id}\")\n    public Account retrieve(@PathVariable Long id) {\n        // ...\n    }\n\n    @DeleteMapping(\"/{id}\")\n    public void remove(@PathVariable Long id) {\n        // ...\n    }\n}\n```\n`@CrossOrigin`同时可以在类和方法中使用：\n```Java\n@CrossOrigin(maxAge = 3600)\n@RestController\n@RequestMapping(\"/account\")\npublic class AccountController {\n\n    @CrossOrigin(\"http://domain2.com\")\n    @GetMapping(\"/{id}\")\n    public Account retrieve(@PathVariable Long id) {\n        // ...\n    }\n\n    @DeleteMapping(\"/{id}\")\n    public void remove(@PathVariable Long id) {\n        // ...\n    }\n}\n```\n通过定义全局的CORS配置，来配合使用。全局的CORS配置可以通过Java Config或者XML的XNM命名空间来配置。\n默认情况下全局的CORS配置：\n  - 允许所有的域\n  - 允许所有的header\n  - 允许GET,HEAD，POST方法\n  - `allowedCredentials` 默认关闭\n  - `max-age`默认30分钟\n使用Java配置CORS\n```Java\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n\n        registry.addMapping(\"/api/**\")\n            .allowedOrigins(\"http://domain2.com\")\n            .allowedMethods(\"PUT\", \"DELETE\")\n            .allowedHeaders(\"header1\", \"header2\", \"header3\")\n            .exposedHeaders(\"header1\", \"header2\")\n            .allowCredentials(true).maxAge(3600);\n\n        // Add more mappings...\n    }\n}\n```\n使用XML配置CORS\n```Xml\n<mvc:cors>\n\n    <mvc:mapping path=\"/api/**\"\n        allowed-origins=\"http://domain1.com, http://domain2.com\"\n        allowed-methods=\"GET, PUT\"\n        allowed-headers=\"header1, header2, header3\"\n        exposed-headers=\"header1, header2\" allow-credentials=\"true\"\n        max-age=\"123\" />\n\n    <mvc:mapping path=\"/resources/**\"\n        allowed-origins=\"http://domain1.com\" />\n\n</mvc:cors>\n```\n另外，也可以通过`CorsFilter`配置CORS。\n```Java\nCorsConfiguration config = new CorsConfiguration();\n\n// Possibly...\n// config.applyPermitDefaultValues()\n\nconfig.setAllowCredentials(true);\nconfig.addAllowedOrigin(\"http://domain1.com\");\nconfig.addAllowedHeader(\"\");\nconfig.addAllowedMethod(\"\");\n\nUrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\nsource.registerCorsConfiguration(\"/**\", config);\n\nCorsFilter filter = new CorsFilter(source);\n```\n\n"}}}