{"path":"tags/Backend","templateID":4,"sharedPropsHashes":{"tags":"1C8cqm"},"localProps":{"posts":[{"title":"Vagrant 入门指南","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-235497977.jpg","iso8601Date":"2015-11-07T00:49:47+08:00","basename":"Vagrant-intro","tags":["Vagrant","Translate","Backend"],"date":"2015-11-07","cate":"backend","summary":"原文地址\n\n开始\n\nVagrant 入门指南将会引导你完成你的第一个Vagrant项目，并且会向你展示Vagrant提供的基本的特色功能。如果你好奇Vagrant提供了什么好的功能，你可以阅读一下Why Vagrant。这篇入门指南将会基于[VirtualBox][1]来使用Vagrant，因为它免费，支持主流平台，并且Vagrant内建支持。当你完成这篇指南的时候，可以参考更多的提供商\n\n更喜欢读书？如果你更喜欢读实体书，那么你可能对由Vagrant作者编写，O&#39;Reilly 出版的Vagrant: Up and Running 更感兴趣，\n\n启动运行\n\nbash\n$ vagrant init hashicorp/precise32\n$ vagrant up\n\n\n运行了上面两个命令之后，会得到一个运行在[VirtualBox][1]虚拟机上的Ubuntu 12.04 LTS 32-bit。你可以通过vagrant ssh 以ssh的方式登陆，当你王城所有的操作的时候，也可以使用vagrant destory来删除所有的痕迹。现在想象 一下，以前你所有工作过的项目，都可以通过这个简单的方式来设置了。  通过使用Vagrant,对于任何项目来说vagrant up 是你唯一需要你用到的命令，例如，安装项目依赖，设置网络和同步文件夹，仍然可以很舒服的使用本机系统。  指南剩下的内容将会引导你设置更复杂的项目，涵盖跟多的Vagrant的特色。  \n\n项目配置\n\n 任何Vagrant项目配置的第一步都是创建一个Vagrantfile。该文件的作用有两个:1. 指定项目的根目录。很多Vagrant的配置跟这个目录有关。2. 描述项目所需要的机器类型和资源，以及如何安装软件，如何访问。  \n\n Vagrant 有一个内建的命令vagrant init用来初始化项目。出于本指南的目的，请在终端输入一下命令  \n\nbash\n$ mkdir vagrant_getting_started\n$ cd vagrant_getting_started\n$ vagrant init\n\n\n 以上命令将在你的当前目录下创建Vagrantfile。查看Vagrantfile会发现里面有各种注释和示例。不要因为他负责而感到恐惧，我们很快就能够修改它了。 同样也可以在一个已存在的目录下运行vagrant init，来未一个已有项目设置Vagrant环境。\n 如果你使用版本控制工具，那么Vagrantfile可以提交到版本库中。这样其他与这个项目相关的人就可以无需前期工作了。\n\nBoxes\n\n 由于从头构建一个虚拟机是一个费时的过程，所以Vagrant使用一个基本镜像来快速克隆一个虚拟机。这些基本镜像再Vagrant中被称作boxes，而且在创建玩Vagrantfile后的第一步就是为你的Vagrant环境指定一个box。  \n\n安装box\n\n 如果你运行了开始指南的命令，那么你已经在本机安装了一个box，你就不需要再次运行一下命令了。但是这部分仍然是值得阅读的，这样你就可以了解更多关于如何管理box的知识。 Boxes 由Vagrant的vagrant box add命令添加。这个将box存储在一个指定命名的目录下，这个多个Vagrant的环境可以重复利用。如果你还未添加已给box，那么可以运行一下命令。  \n\nbash\n$ vagrant box add hashicorp/precise32\n\n\n 这个将从HashiCorp&#39;s Atlas box catalog下载一个名字为hashicorp/precise32的box。你可以从HashiCorp&#39;s Atlas box catalog中找到各种box。很容易从HashiCorp&#39;s Atlas 下载镜像，同时你也可以通过本地文件，其他URL等添加。\n 已添加的boxes可以被多个环境重复利用。每个环境都是将其作为基础镜像克隆，而不会修改他。这就意味着两个环境同时使用了刚刚添加的hashicorp/precise32的box，其中一个主机添加文件并不会影响另一个主机。  \n\n使用box\n\n 现在已经吧box添加到Vagrant了，我们就可以把他作为一个基础镜像使用了。打开Vagrantfile，修改一下代码:\n\nbash\nVagrant.configure(&quot;2&quot;) do |config|\n  config.vm.box = &quot;hashicorp/precise32&quot;\nend\n\n 在这个例子中，&quot;hashicorp/precise32&quot; 的名字必须跟你add box的名字相同。这是Vagrant知道box如何用的方式。如果这个box没有被安装过，那么Vagrant将会自动下载并且当它运行的时候自动添加。 在下一节中我们将启动Vagrant并且与其进行交互。  \n\n寻找更多box\n\n 在本入门指南的后半部分，我们只会使用之前添加的&quot;hashicorp/precise32&quot;的box。但是，结束本指南的时候你的第一个问题可能就是我从南找到更多的box。 寻找更多box的最好的地方是HashiCorp&#39;s Atlas box catalog。HashiCopr 的Altas有一个公共目录，在目录里可以找到各种免费的，可以运行各种平台和技术的box。 HashiCorp的Altas同样也有一个很棒的搜索功能，这样就可以更方便的找到需要的box。 除了寻找免费的box外，HashiCorp的Altas还允许你构建自己的box，以及如果你想为自己的组织创建私有box。  \n\n启动并且SSH登陆\n\n 是时候启动你第一个Vagrant环境了。运行一下命令:  \n\nbash\nvagrant up\n\n\n 1分钟之内，这个命令运行完后，你就可以得到一个运行Ubuntu的虚拟机了。由于Vagrant运行虚拟机的时候没有UI，所以你不会看到任何输出。你可以SSH登陆到虚拟机来验证虚拟机是否运行：\n\nbash\nvagrant ssh\n\n\n 运行完这个命令后你就会进入ssh会话中。继续和机器交互，做任何你想做的事情。虽然是临时的虚拟机，但是还是要小心rm -rf / 这种命令，因为Vagrant的/vagrant目录与宿主机器共享了包含Vagrantfile的目录，如果运行了会删除所有的文件的。共享目录将会在下节描述。 花一点时间思考一下刚刚发生的事情：通过仅仅1行配置和1行命令，我们就启动了一个功能完整的，可以ssh登陆的虚拟机，太酷了。 当你用完虚拟机的时候，你可以在主机上使用vagrant destory来清除你再虚拟机的痕迹。\n\n同步文件夹\n\n虽然这么容易就可以启动一个虚拟机是很爽，但是并不是所有的人都喜欢通过ssh登陆终端修改文件。幸运的是，通过Vagrant，你并不是必须这么做的。通过使用同步文件夹Vagrant将会自动的将文件从虚拟机同步或者同步到虚拟机中。 默认情况下，Vagrant是共享你的项目目录（记住，这个是你Vagrantfile所在的目录）到虚拟机的/vagrant的。再次运行vagrant up 并且ssh到虚拟机。\n\nbash\n$ vagrant up\n...\n$ vagrant ssh\n...\nvagrant@precise32:~$ ls /vagrant\nVagrantfile\n\n\n 不管相不相信，在虚拟机的这个Vagrantfile和再宿主机上的那个Vagrantfile是同一个。继续创建一个文件证明一下：\n\nbash\nvagrant@precise32:~$ touch /vagrant/foo\nvagrant@precise32:~$ exit\n$ ls\nfoo Vagrantfile\n\n\n 哇！foo已经在你的宿主机里创建了。正如你所见，Vagrant会保持那个文件夹的同步。 通过使用同步文件夹，你可以继续在你的主机上使用你喜欢的编辑器，文件会自动的同步到虚拟机上的。\n\n配置\n\n 现在我们已经在虚拟机上运行了一份Ubuntu的拷贝，并且我们还可以从宿主机上编辑文件同时同步到虚拟机中。现在让我们通过webserver来提供这些文件。 我们可以SSH到虚拟机然后安装webserver然后提供这些文件，但是这样做，每一个用Vagrant的用户都需要重复相同的事情。不过Vagrant内建提供了自动配置的功能。使用这个功能，Vagrant可以在你vagrant up的时候自动安装软件，这样虚拟机就可以被重复创建并且可以直接使用了。  \n\n安装Apache\n\n 对于我们的项目来说可以仅仅使用Apache，并且我们是通过一个shell脚本创建的。再Vagrantfile相同的目录下创建一个名字为bootstrap.sh的文件。  \n\n`bash\n\n!/usr/bin/env bash\n\napt-get update\napt-get install -y apache2\nif ! [ -L /var/www ]; then\n  rm -rf /var/www\n  ln -fs /vagrant /var/www\nfi \n`\n\n 然后，我们需要配置Vagrant，让它在启动的时候运行这个脚本。我们通过修改Vagrantfile来实现这一功能，具体修改如下:\n\n\nVagrant.configure(&quot;2&quot;) do |config|\n  config.vm.box = &quot;hashicorp/precise32&quot;\n  config.vm.provision :shell, path: &quot;bootstrap.sh&quot;\nend\n\n\n “provision”这一行是新添加的，告诉Vagrant使用shell配置器运行bootstrap.sh脚本启动机器。脚本的路径是项目更目录的相对路径。\n\n配置\n\n 在所有的事情都配置好好，运行vagrant up来创建机器，Vagrant将会自动的配置它。运行的时候你会在终端看到shell脚本的输出。如果虚拟机已经开始运行了，运行vagrant reload --provision, 这个命令可以快速重启虚拟机并且跳过初始的导入步骤。--provision表示Vagrant需要运行配置，因为通常Vagrant只运行第一步。\n 当Vagrant完全运行起来的时候，web server同时也启动了。现在还不都能通过宿主机的浏览器看到，但是可以通过ssh到虚拟机进行验证。\n\n\n$ vagrant ssh\n...\nvagrant@precise32:~$ wget -qO- 127.0.0.1\n\n\n 这个可以运行成功，因为我们我们已经安装了Apache服务器并且设置默认的DocumentRoot指向了/vagrant。\n 你可以继续的创建文件，同时再终端里面验证，不过下一节我们将会讲述网络的相关知识，这样你就可以再本机的浏览器验证了。\n\n网络\n\n 目前为止我们运行了一个web server，并且可以再宿主机器上修改，同时自动同步到虚拟机中。然而，简单的从虚拟机的终端访问网页并不方便。在这一节中我们将使用Vagrant的网络特性，这样就可以方便的从宿主机器访问虚拟机了。\n\n端口转发\n\n 一个方法是使用端口转发功能。端口转发允许你指定虚拟机的一个端口跟宿主机的一个端口共享。这样你就可以在宿主机访问宿主机的端口，但是都会转发到虚拟机中。\n 现在我们配置端口来访问虚拟机的Apache服务。修改Vagrantfile如下：\n\n\nVagrant.configure(&quot;2&quot;) do |config|\n  config.vm.box = &quot;hashicorp/precise32&quot;\n  config.vm.provision :shell, path: &quot;bootstrap.sh&quot;\n  config.vm.network :forwarded_port, guest: 80, host: 4567\nend\n\n\n 运行vagrant reload，或者如果没有启动过虚拟机运行vagrant up。使配置生效。\n\n其他的网络配置\n\n Vagrant也有其他的网络配置，允许你给虚拟机配置固定ip，或者是桥接两台虚拟机。如果你对其感兴趣，可以阅读networking章节。\n\n共享\n\n 现在我们已经有了一台可运行的服务器，并且可以从本机直接访问，我们构建了一个相当实用的开发环境。但是，除了提供一个开发环境，Vagrant还可以很容易的和其他环境分享和合作。这个主要的功能叫做Vagrant Share。\n Vagrant Share运行你把你的Vagrant环境分享你世界上的每一个人。它将分配给你一个URL，这样世界上任何一台机器都可以实用你的环境了。\n\n登录Harshicorp&#39;s Altas\n\n 在分享你的Vagrant环境之前，你需要一个HashiCorp&#39;s Altas的账号。不必担心，它是免费的。\n 当你有了账号后，你就可以使用vagrant login来登陆\n\n\n$ vagrant login\nUsername or Email: mitchellh\nPassword (will be hidden):\nYou&#39;re now logged in!\n\n\n共享\n\n 当你登录之后，你就可以使用vagrant share来共享环境了。\n\n\n$ vagrant share\n...\n==&gt; default: Your Vagrant Share is running!\n==&gt; default: URL: http://frosty-weasel-0857.vagrantshare.com\n...\n\n\n 你的URL会是不同的，无需上面的URL。复制上面vagrant share生成的url到你的浏览器，你会看到我们已经做好的Apache的页面。\n 如果你在共享目录中改动了某个文件，重新刷新URL，你会看到已经更新了。这个URL直接路由到你的Vagrant环境，并且可以直接再世界上任何一台联网的机器上访问。\n 关闭共享只需要使用Ctrl+C即可，重新刷新URL，你会发现你的环境已经不再被共享了。\n Vagrant Share比简单的HTTP share 更强大，想要了解更多可以阅读完整的Vagrant Share文档。\n\n关闭\n\n 现在我们已经有一个开发web的基本环境。但是，现在是时候说一下开关了，可能是在运行其他的项目的时候使用，或者是吃午饭的时候使用，或者只是回家的时候。我们应该如何清理我们的开发环境。\n 通过Vagrant，我们可以suspend,halt或者destory虚拟机。每一个都有他们的优缺点，选择最适合你的那个。 suspend 使用vagrant suspend命令，保存当前运行环境并停止。当你想要继续运行的时候可以使用vagrant up命令，它会从你上次suspend中恢复。这个命令主要好处是速度非常快，通常关闭，启动都在5到10秒之间。缺点是虚拟机仍然会使用你的硬盘，并且在存储所有的状态的时候需要更大的硬盘。 halting 使用vagrant halt命令实现优雅的关闭虚拟机的操作系统并关闭虚拟机。在你想要使用的时候再次运行vagrant up命令启动。这个的好处是可以完全的关闭虚拟机并保留使用的硬盘资源，再下次启动的时候会是一个干净的虚拟机。缺点是冷启动的时候会慢一点，并且仍然会使用硬盘空间。\n* destory 使用vagrant destory命令，将会清楚虚拟机所有的痕迹。它将会停止操作系统，关闭虚拟机，并且清除所使用的磁盘空间。下次使用vagrant up的时候会出现问题。好处是不会有任何的残留在你机器上，同事磁盘空间和RAM都会还给本机。坏处是vagrant up将会从头开始，这样会花费更长的时间。\n\n重新构建\n\n 当你想重新使用虚拟机的时候，不管是是明天，一周之后，或者是一年之后，都可以通过vagrant up来轻松运行他。\n 只需要这样。而且由于你的Vagrant都再Vagrantfile里面配置的，所有你或者你的同事只需要简单的运行vagrant up即可重新创建相同的环境。\n\nProvider\n\n 在本指南开始的时候，我们的项目一直支持[VirtualBox][1]。但是Vagrant可以与多个后端Provider一起使用，例如VMware,AWS等。继续阅读来了解如何它们的更多信息以及如何使用它们。\n 当你安装了其他的Provider的时候,你不需要更改你的Vagrantfile，只需要在启动的时候加个参数即可：\n\n\n$ vagrant up --provider=vmware_fusion\n\n\n准备转移到云端了？使用AWS：\n\n\n$ vagrant up --provider=aws\n\n\n 当你使用其他Provider运行vagrant up的时候，其他的Vagrant命令不行也要指定Provider。Vagrant将会自动的计算出来。所以当你ssh,destory的或者运行其他命令的时候，只需要输入平时的命令即可，例如：vagrant destory，无需额外的参数。\n 更多信息请参考provider。\n[1]: https://www.virtualbox.org/","readingtime":12,"url":"/cates/backend/post/2015-11-07/Vagrant-intro","dirs":["vagrant"],"relatives":[{"url":"/cates/backend/post/2015-11-08/Vagrant-Ansible-quick-intro","title":"Vagrant & Ansible 快速入门教程"}]},{"title":"Vagrant & Ansible 快速入门教程","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-183601741.jpg","iso8601Date":"2015-11-08T08:39:10+08:00","basename":"Vagrant-Ansible-quick-intro","tags":["Ansible","Translate","Vagrant","Backend"],"date":"2015-11-08","cate":"backend","summary":"原文地址  \n\n就个人而言，我用过Chef，Puppet，简单的Bash脚本等用来配置服务器，其他服务和Vagrant Boxes。虽然Chef社区仍然在快速成长，但是我发布的关于Chef的文章仍然是最受欢迎的文章。然而，两个月之前，当我在一个项目中使用Ansible的时候所有的事情都变了。从此之后我再也没用过其他的配置工具，也找不到用其他工具的理由了。  \n\n看过了不少关于Ansible的教程，尝试这从中找出相应的模式和最佳实战，然而似乎在知识上有巨大的横沟。你可以用Ansible做很多事情，你也可以同时学习如何使用，但是跟我最新学习的工具一样，却反一个很简单地方入手学习的地方。今天我希望通过使用Vagrant和Ansible配置一个LAMP的技术栈来纠正他。  \n\n为什么使用Ansible\n\nAnsible和其他的配置管理工具最主要的区别就是Ansible是基于SSH的。Chef和Puppet都是有依赖的，而且必须在服务器上安装之后才能使用，而Ansible则不需要。它可以在你本机运行，使用SSH连接相应主机，在其运行相应命令。  \n\n为什么不直接使用Bash脚本呢？Ansible之所以比Bash脚本好是因为他简单。Ansible只是运行了一系列使用YAML格式编写的任务。同样Ansible还具有幂等性，这就意味着你可以多次运行同样的任务，并且这些任务的输入会保持一致（例如除非明确要求运行两次否则它不会对同一个任务运行两次）。同样这个可以通过Bash脚本编写，但是会很复杂。\n\nAnsible 和 Vagrant\n\n首先给你要确定已经安装了Ansible和Vagrant。它们的安装文档可以在它们的相关网站找到，它们都很容易安装的。\n\n基础\n\n我们将会创建一个新的文件夹来开始我们的项目。\n\nbash\nmkdir -p ~/Projects/vagrant-ansible\ncd ~/Projects/vagrant-ansible\n\n\n接着我们创建一个基于最新的Ubuntu的Vagrantfile。\n\nbash\nvagrant init ubuntu/trusty64\n\n\n运行完这个命令后在项目目录下会有一个叫Vagrantfile的文件。它包含了你想要配置的关于box的一些基本信息和一堆你现在不需要管的注释。删除所有的注释，你就会简单的得到以下的代码：\n\nbash\nVAGRANTFILE_API_VERSION = &quot;2&quot;\nVagrant.configure(VAGRANTFILE_API_VERSION) do |config|\n  config.vm.box = &quot;ubuntu/trusty64&quot;\nend\n\n\n我们需要在他配置好的适合访问服务器，所以我们将会吧Vagrant的80端口转发到本机的8080端口，将以下代码添加到end之前。\n\nbash\nconfig.vm.network &quot;forworded_port&quot;, guest: 80, host:8080\n\n\n现在Vagrant只需要配置一件事情。我们需要配置Vagrant使用Ansible作为配置器，并且知道去哪里需找这些命令。为了实现这个目的，我们将一下代码加到Vagrantfile的end之前。\n\nbash\nconfig.vm.provision :ansible do |ansible|\n  ansible.playbook = &quot;playbook.yml&quot;\nend\n\n\n以上所有的任务完成之后你的Vagrantfile将会是一下的配置。  \n\n`bash\nVAGRANTFILEAPIVERSION = &quot;2&quot;\n\nVagrant.configure(VAGRANTFILEAPIVERSION) do |config|\n  config.vm.box = &quot;ubuntu/trusty64&quot;\n\n  config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8080\n\n  config.vm.provision :ansible do |ansible|\n    ansible.playbook = &quot;playbook.yml&quot;\n  end\nend\n`\n\n基本术语\n\nAnsible再你的服务器上运行一系列的Tasks。把Task想象成一个单一的Bash命令。接着是playbook，Ansible通过Playbook得知将再服务器上运行什么任务。每一个Task运行一个Ansible的Module，Module是Ansible内建的各种命令，例如yun，创建用户等。稍后就会明白这些术语的具体意思。  \n\n第一个Playbook\n\n创建一个叫playbook.yml的文件，这个名字必须和Vagrantfile的ansible.playbook相同。\n\n所有Ansible的Playbook都必须是YAML格式的。传统上YAML文件是以三条横线开头的，但是Ansible并不是强制要求的，不过社区仍然会遵循这个规则。  \n\n新建的playbook是一个YAML的列表。这个列表应该包括要管理的host和各种要运行的task，将以下代码添加到playbook.yml文件中。\n\n```bash\n\nhost: all\nsudo: true\ntasks:\n`\n\n我们使用Vagrant并且只有一台主机，所以我们可以使用一个魔法值all，意思是在所有的机器上运行任务。然后我们告诉Ansible运行是需要sudo权限，最后我们添加了 tasks: 用来添加Task。\n\n要安装LAMP技术栈的基本步骤是：1. 更新 Apt Cache\n2. 安装 Apache\n3. 安装 MySQL\n4. 安装 PHP\n\n这就是所有我们必须的步骤。因为我们用的是Ubuntu的box，所有我们需要Ansible的apt模块。\n\n首先我们给每一个task一个name:，这个可以是任何描述，它用来描述这个任务，如下:\n\nbash\n- name: this should be some descriptive text\n\n\n接着我们指定一个Ansible的模块作为值，在本例中使用的是apt模块。\n\nbash\napt\n\n\n紧随其后的是一些key=value的由空格分隔的键值对。选择你想要传递给Ansible的键值对，可以通过Ansible的文档来查询所需要的键值对。\n\n安装Apache的任务如下：\n\nbash\n- name: install apache\n  apt: name=apache2 state=present\n\n\n这样就配置好了，很简单，对吧。我们将继续添加MySQL和PHP的Task到playbook.yml中，最后代码如下：\n\n```bash\n\nhosts: all\nsudo: true\ntasks:name: update apt cache\napt: update_cache=yesname: install apache\napt: name=apache2 state=presentname: install mysql\napt: name=mysql-server state=presentname: install php\napt: name=php5 state=present\n`\n\n现在我们已经配置完了，然后运行vagrant up，你将会看到如下图所示：\n  \n\n这样就搭建好了。如果你想让LAMP运行起来，你就可以ssh到Vagrant，然后将info.php文件添加到/var/www/html下。\nphp\n&lt;?php phpinfo();?&gt;\n\n\n然后在本机浏览器打开http://localhost:8080/info.php，就会看到你想要看到的。\n\n翻译到此，剩下的就是关于Ansible的使用了，这些可以通过Ansible的官方文档来学习","readingtime":8,"url":"/cates/backend/post/2015-11-08/Vagrant-Ansible-quick-intro","dirs":["vagrant"],"relatives":[{"url":"/cates/backend/post/2015-11-07/Vagrant-intro","title":"Vagrant 入门指南"}]},{"title":"Ansible 入门指南","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-41436438.jpg","iso8601Date":"2015-11-10T02:26:35+08:00","basename":"Ansible-introduction","tags":["Ansible","Translate","Backend"],"date":"2015-11-10","cate":"backend","summary":"原文地址\n\n快速入门\n\n前言\n\n 现在你已经知道如何安装Ansible了，现在可以深入并开始使用Ansible的一些命令了。\n 我们开始展示的并不是Ansible强大的配置、部署、调度的功能。这些功能由其他章节要讲的Playbook来处理。\n 这个章节是关于如何快速入门的。等你了解了Ansible的这些概念之后，就可以阅读特别命令简介来学习更多细节，接着你就可以深入理解Playbook，并且浏览更多的有趣功能。\n\n远程连接信息\n\n 在我们开始学习之前，理解Ansible是如何通过SSH连接到远程服务器是很重要的。\n 默认情况下，如果可以，Ansible 1.3 及其后续版本会使用原生的OpenSSh来连接远程服务器。这样就可以在~/.ssh/config下开启ControPersist(一个高性能的功能),Kerbos和其他选项，例如跳板机设置。然后，如果使用了Enterprise Linux 6(Red Hat Enterprise Linux 和其衍生版本，例如CentOS) 系统作为控制机，OpenSSH的版本可能过低导致无法开启ControlPersist功能。在这些操作系统中，Ansible将会回退到使用“paramiko”，他是OpenSSH的一个高质量的Python实现。如果你想使用像Kerberized SSH 等这样的功能，那么可以使用Federa，OSX或者Ubuntu作为你的控制机，直到你使用的平台有了更新的OpenSSH，或者你可以开启加速功能。加速功能。\n 如果使用的版本小于等于1.2，那么默认使用的就是paramiko，如果想要使用原生的SSH，那么需要加上-c ssh 选项或者再配置文件中配置。\n 可能偶尔在某些机器上不支持SFTP协议，虽然这种情况很少，但是也可能发生，这个时候可以在配置文件中切换到SCP模式。\n 当需要和远程主机会话是，Ansible默认假设你使用SSH keys。Ansible鼓励使用SSH 免密码登陆，但是使用密码登陆也是可以的，在使用的时候加上参数--ask-pass。如果需要使用sudo权限，那么也要提供--ask-sudo-pass参数。\n 任何管理系统运行时离被管理的系统越近越好。虽然这是个常识，但是还是值得分享的。如果你在云端使用Ansible，那么就把Ansible运行在云端。在大多数情况下，它都比直接在公共网络上运行更好。\n 作为一个高级话题，Ansible并不仅仅通过SSH连接主机。连接系统是可插拔的，有很多配置选项可以用来本地管理，例如管理chroot，lxc，jail container。一个叫做“Ansible-pull”的模式可以反转系统。通过配置好的git checkout 从中央存储库pull配置文件获取系统的“phone home”。\n\n第一个命令\n\n 目前为止，已经安装好Ansible了，现在可以开始运行一些简单的命令了。\n 编辑（或者创建）/etc/ansible/hosts文件，向其添加一个或者多个远程主机地址。本机的public ssh key 应该已经追加到远程主机的authorized_keys文件中。\n\nbash\n192.168.1.50\naserver.example.org\nbserver.example.org\n\n\n 这是一个清单文件，同样会再主机清单中介绍。\n 假设你使用的是SSH授权方式，设置ssh angent 防止重复输入密码。\n\nbash\nssh-agent bash\nssh-add ~/.ssh/id_rsa\n\n\n(根据你的设置，你可能需要使用--private-key选项来制定一个pem文件)\n 现在可以ping一下所有的主机了。\n\nbash\nansible all -m ping\n\n\n Ansible会想SSH那样使用你本机的用户名去连接远程机器，如果不想使用本机用户名，可以加上-u的选项。\n 如果你想使用sudo权限，同样也可以将上--sudo选项。\n\n`bash\n\nas bruce\n\n$ ansible all -m ping -u bruce\n\nas bruce sudoing to root\n\n$ ansible all -m ping -u bruce --sudo\n\nas bruce, sudoing to batman\n\n$ ansible all -m ping -u bruce --sudo --sudo-user batman\n\nWith latest version of ansible sudo is deprecated so use become\n\nas bruce, sudoing to root\n\n$ ansible all -m ping -u bruce -b\n\nas bruce, sudoing to batman\n\n$ ansible all -m ping -u bruce -b --become-user batman\n`\n\n(如果你突然想改变sudo 用户，可以再配置文件中修改。传递给sudo的标记例如-H也可以在那修改。)\n\n 现在在你所有的节点上运行一个实时的命令。\n\nbash\n$ ansible all -a &quot;/bin/echo hello&quot;\n\n\n 太棒了，刚刚通过Ansible与远程主机会话了。很快就可以阅读更多命令介绍来学习更多的实际例子，浏览各个模块都可以做什么，以及学习Ansible Playbooks的语法。Ansible不仅仅只能用来运行命令，他还有强大的配置管理系统和部署功能。还有许多需要学习的知识，但是你现在已经有一个完全可以运行的环境了。\n\n主机密钥检查\n\n Ansible 1.2.1 及其之后的版本，默认是有主机密钥检查功能的。\n 如果远程主机成新安装并且在know_hosts下有一个不同的key，直到修复之前，Ansible会一直返回错误。如果主机没有在know_hosts文件中，那么会出现提示来确认密钥。这样就会有一个你不希望的提示。\n&amp;emps; 如果你知道这个功能的影响，并且希望关闭这个功能，可以修改/etc/ansible/ansible.cfg或者是~/.ansible.cfg来关闭这个功能。\n\nbash\n[default]\nhost_key_checking = False\n\n\n 同样也可以通过环境变量来修改。\n\nbash\n$ export ANSIBLE_HOST_KEY_CHECKING=False\n\n\n 同时要注意主机密钥检查再paramiko模式中是很慢的，所以如果要使用这个功能最好使用ssh模式。\n 除非Ansible的任务被标记为&quot;nolog:True&quot;，否则Ansible会再远程注意的syslog中记录一些有用的信息。这个稍后再做解释。\n 如果要再本机开启log可以查看配置章节来设置“logpath”开启。企业用户可能会对Ansible Tower。Tower提供了一个健壮的数据库记录日志的功能，这样就可以随时通过图形界面或者REST API 来查看主机，项目，特殊的列表的日志。","readingtime":6,"url":"/cates/backend/post/2015-11-10/Ansible-introduction","dirs":["ansible"],"relatives":[]},{"title":"Go Web 架构","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-251622641.jpg","iso8601Date":"2015-11-11T03:01:21+08:00","basename":"Go-Web-architecture","tags":["Go","Architecture","Translate","Backend","Web"],"date":"2015-11-11","cate":"backend","summary":"原文地址\n\n使用Golang来创建Web项目是一件很麻烦的事情。如果你使用Rails，那么你可能不会有这个感触。我在Refer Madness中使用了下面这个架构。\n\nbash\n-public/\n-views/\n-models/\n-utils/\n-controllers/\n-web/\n-main.go\n\n\n我将打破这个体系，介绍各个目录的作用。在每个目录下，文件只能访问其同级或者上一级。这就意味着utils只能访问他自己和models，web只能访问它自己，controllers，utils，models。models只能访问它自己。我这么做是为了让层次清晰，防止出现递归依赖。现在来分析每一个目录，文件的作用。\n\nmain.go\n\nmain.go是创建依赖，获取环境变量，启动服务的主要文件。下面是它的实例。\n\n`Go\npackage main\n\nimport (\n  &quot;github.com/larryprice/refermadness/utils&quot;\n  &quot;github.com/larryprice/refermadness/web&quot;\n  &quot;github.com/stretchr/graceful&quot;\n  &quot;os&quot;\n)\n\nfunc main() {\n  isDevelopment := os.Getenv(&quot;ENVIRONMENT&quot;) == &quot;development&quot;\n  dbURL := os.Getenv(&quot;MONGOLABURI&quot;)\n  if isDevelopment {\n    dbURL = os.Getenv(&quot;DBPORT27017TCP_ADDR&quot;)\n  }\n\n  dbAccessor := utils.NewDatabaseAccessor(dbURL, os.Getenv(&quot;DATABASE_NAME&quot;), 0)\n  cuAccessor := utils.NewCurrentUserAccessor(1)\n  s := web.NewServer(dbAccessor, cuAccessor, os.Getenv(&quot;GOOGLEOAUTH2CLIENTID&quot;),\n    os.Getenv(&quot;GOOGLEOAUTH2CLIENTSECRET&quot;), os.Getenv(&quot;SESSIONSECRET&quot;),\n    isDevelopment, os.Getenv(&quot;GOOGLEANALYTICS_KEY&quot;))\n\n  port := os.Getenv(&quot;PORT&quot;)\n  if port == &quot;&quot; {\n    port = &quot;3000&quot;\n  }\n\n  graceful.Run(&quot;:&quot;+port, 0, s)\n}\n\n`\n\n因为main.go实在最低的层级，所以它可以访问所有的目录：在这个例子里是web和utils。在这里获取了所有的环境变量并把它们注入到合适的地方。在main.go中创建了服务器，注入依赖，并且在配置的端口启动服务器。\n\nweb\n\nweb目录下是主要的服务代码，同时也包括了中间件代码。下面是web目录的内部结构：\n\nbash\n-web/\n|-middleware/\n|-server.go\n\n\nserver.go包含了web server的定义。这个web server 创建了所有的web controller并且给negroni添加了中间件。下面是他的例子：\n\n`Go\npackage web\n\nimport (\n  &quot;github.com/codegangsta/negroni&quot;\n  &quot;github.com/goincremental/negroni-sessions&quot;\n  &quot;github.com/goincremental/negroni-sessions/cookiestore&quot;\n  &quot;github.com/gorilla/mux&quot;\n  &quot;github.com/larryprice/refermadness/controllers&quot;\n  &quot;github.com/larryprice/refermadness/utils&quot;\n  &quot;github.com/larryprice/refermadness/web/middleware&quot;\n  &quot;github.com/unrolled/secure&quot;\n  &quot;gopkg.in/unrolled/render.v1&quot;\n  &quot;html/template&quot;\n  &quot;net/http&quot;\n)\n\ntype Server struct {\n  *negroni.Negroni\n}\n\nfunc NewServer(dba utils.DatabaseAccessor, cua utils.CurrentUserAccessor, clientID, clientSecret,\n  sessionSecret string, isDevelopment bool, gaKey string) *Server {\n  s := Server{negroni.Classic()}\n  session := utils.NewSessionManager()\n  basePage := utils.NewBasePageCreator(cua, gaKey)\n  renderer := render.New()\n\n  router := mux.NewRouter()\n\n  // ...\n\n  accountController := controllers.NewAccountController(clientID, clientSecret, isDevelopment, session, dba, cua, basePage, renderer)\n  accountController.Register(router)\n\n  // ...\n\n  s.Use(sessions.Sessions(&quot;refermadness&quot;, cookiestore.New([]byte(sessionSecret))))\n  s.Use(middleware.NewAuthenticator(dba, session, cua).Middleware())\n  s.UseHandler(router)\n  return &amp;s\n}\n`\n\nServer结构体是一个negroni.Negroni的web server，在这个文件里有对utils和其他第三方包的引用，创建了一个router，一些controller，并且将controller注册到当前router。同时也引入了必要的中间件。说到中间件，下面是它的代码：\n\n`Go\npackage middleware\n\nimport (\n  &quot;github.com/codegangsta/negroni&quot;\n  &quot;github.com/larryprice/refermadness/utils&quot;\n  &quot;net/http&quot;\n)\n\ntype Database struct {\n  da utils.DatabaseAccessor\n}\n\nfunc NewDatabase(da utils.DatabaseAccessor) *Database {\n  return &amp;Database{da}\n}\n\nfunc (d Database) Middleware() negroni.HandlerFunc {\n  return func(rw http.ResponseWriter, r http.Request, next http.HandlerFunc) {\n    reqSession := d.da.Clone()\n    defer reqSession.Close()\n    d.da.Set(r, reqSession)\n    next(rw, r)\n  }\n}\n`\n\n这个是通过HTTP router访问数据库session的标注中间件。基本文件是从Brian Gesiak’s blog post on RESTful Go中得到，将其修改为适合我的文件。\n\ncontrollers/\n\n这里的controller与Rails里的controller的概念很像。Controller注册自己的router，设置自己的函数调用。一个简短的例子如下：\n\n`Go\npackage controllers\n\nimport (\n  &quot;encoding/json&quot;\n  &quot;errors&quot;\n  &quot;github.com/gorilla/mux&quot;\n  &quot;github.com/larryprice/refermadness/models&quot;\n  &quot;github.com/larryprice/refermadness/utils&quot;\n  &quot;gopkg.in/mgo.v2/bson&quot;\n  &quot;gopkg.in/unrolled/render.v1&quot;\n  &quot;html/template&quot;\n  &quot;net/http&quot;\n  &quot;strings&quot;\n)\n\ntype ServiceControllerImpl struct {\n  currentUser utils.CurrentUserAccessor\n  basePage    utils.BasePageCreator\n  renderer    *render.Render\n  database    utils.DatabaseAccessor\n}\n\nfunc NewServiceController(currentUser utils.CurrentUserAccessor, basePage utils.BasePageCreator,\n  renderer render.Render, database utils.DatabaseAccessor) ServiceControllerImpl {\n  return &amp;ServiceControllerImpl{\n    currentUser: currentUser,\n    basePage:    basePage,\n    renderer:    renderer,\n    database:    database,\n  }\n}\n\nfunc (sc ServiceControllerImpl) Register(router mux.Router) {\n  router.HandleFunc(&quot;/service/{id}&quot;, sc.single)\n  // ...\n}\n\n// ...\n\ntype serviceResult struct {\n  models.Service\n  RandomCode models.ReferralCode\n  UserCode   *models.ReferralCode\n}\n\ntype servicePage struct {\n  utils.BasePage\n  ResultString string\n}\n\nfunc (sc ServiceControllerImpl) single(w http.ResponseWriter, r http.Request) {\n  data, err := sc.get(w, r)\n\n  if len(r.Header[&quot;Content-Type&quot;]) == 1 &amp;&amp; strings.Contains(r.Header[&quot;Content-Type&quot;][0], &quot;application/json&quot;) {\n    if err != nil {\n      sc.renderer.JSON(w, http.StatusBadRequest, map[string]string{\n        &quot;error&quot;: err.Error(),\n      })\n      return\n    }\n    sc.renderer.JSON(w, http.StatusOK, data)\n    return\n  } else if err != nil {\n    http.Error(w, err.Error(), http.StatusBadRequest)\n  }\n\n  resultString,  := json.Marshal(data)\n  t,  := template.ParseFiles(&quot;views/layout.html&quot;, &quot;views/service.html&quot;)\n  t.Execute(w, servicePage{sc.basePage.Get(r), string(resultString)})\n}\n`\n\nutils/\n\n在utils目录下的文件提供了一些底层功能用来支持其他的代码。在这个例子中，主要是定义一个结构体来访问请求的上下文，处理session，定义一个特别的页面来继承。下面是通过访问上下文设置用户的例子：\n\n`Go\npackage utils\n\nimport (\n  &quot;github.com/gorilla/context&quot;\n  &quot;github.com/larryprice/refermadness/models&quot;\n  &quot;net/http&quot;\n)\n\ntype CurrentUserAccessor struct {\n  key int\n}\n\nfunc NewCurrentUserAccessor(key int) *CurrentUserAccessor {\n  return &amp;CurrentUserAccessor{key}\n}\n\nfunc (cua CurrentUserAccessor) Set(r http.Request, user *models.User) {\n  context.Set(r, cua.key, user)\n}\n\nfunc (cua CurrentUserAccessor) Clear(r http.Request) {\n  context.Delete(r, cua.key)\n}\n\nfunc (cua CurrentUserAccessor) Get(r http.Request) models.User {\n  if rv := context.Get(r, cua.key); rv != nil {\n    return rv.(models.User)\n  }\n  return nil\n}\n`\n\nmodels/\n\nmodel 是为了描述数据库中的数据的数据结构。在这个例子中使用model来访问数据库，创建一个空的model，然后通过查询数据库为其赋值。下面是一个例子：\n\n`Go\npackage models\n\nimport (\n  &quot;gopkg.in/mgo.v2&quot;\n  &quot;gopkg.in/mgo.v2/bson&quot;\n  &quot;strings&quot;\n  &quot;time&quot;\n)\n\ntype Service struct {\n  // identification information\n  ID          bson.ObjectId bson:&quot;_id&quot;\n  Name        string        bson:&quot;name&quot;\n  Description string        bson:&quot;description&quot;\n  URL         string        bson:&quot;url&quot;\n  Search      string        bson:&quot;search&quot;\n}\n\nfunc NewService(name, description, url string, creatorID bson.ObjectId) *Service {\n  url = strings.TrimPrefix(strings.TrimPrefix(url, &quot;http://&quot;), &quot;https://&quot;)\n  return &amp;Service{\n    ID:            bson.NewObjectId(),\n    Name:          name,\n    URL:           url,\n    Description:   description,\n    Search:        strings.ToLower(name) + &quot;;&quot; + strings.ToLower(description) + &quot;;&quot; + strings.ToLower(url),\n  }\n}\n\nfunc (s Service) Save(db mgo.Database) error {\n  _, err := s.coll(db).UpsertId(s.ID, s)\n  return err\n}\n\nfunc (s Service) FindByID(id bson.ObjectId, db mgo.Database) error {\n  return s.coll(db).FindId(id).One(s)\n}\n\nfunc (Service) coll(db mgo.Database) *mgo.Collection {\n  return db.C(&quot;service&quot;)\n}\n\ntype Services []Service\n\nfunc (s Services) FindByIDs(ids []bson.ObjectId, db mgo.Database) error {\n  return s.coll(db).Find(bson.M{&quot;_id&quot;: bson.M{&quot;$in&quot;: ids}}).Sort(&quot;name&quot;).All(s)\n}\n\nfunc (Services) coll(db mgo.Database) *mgo.Collection {\n  return db.C(&quot;service&quot;)\n}\n\n`\n\nviews/\n\n将Golang的模板文件放到views目录下。这样，不管用什么样的模板引擎都可以直接放到views下。\n\npublic/\n\n跟以前一样，这个文件都是放公开的文件的，例如css,img,scripts。\n\n如何运行\n\n毫无疑问，我最喜欢的就是docker，因此我将使用他来运行这个应用。如果不使用docker，那么可以将文件放到$GOPATH/src/github.com/larryprice/refermadness,运行go get来获取所有的依赖，然后运行 go run main.go或者go build; ./refermadness运行程序。如果你也喜欢使用docker，那么可以直接通过Dockerfile来运行。\n\n`bash\nFROM golang:1.4\n\nRUN go get github.com/codegangsta/gin\n\nADD . /go/src/github.com/larryprice/refermadness\nWORKDIR /go/src/github.com/larryprice/refermadness\nRUN go get\n`\n\n同时我也很喜欢compose，所以我也通过compose 文件来运行所有的应用。我用了JSC ，SASS和mongodb，所以一下是我的docker-compose.yml文件。\n\nGo\nmain:\n  build: .\n  command: gin run\n  env_file: .env\n  volumes:\n    - ./:/go/src/github.com/larryprice/refermadness\n  working_dir: /go/src/github.com/larryprice/refermadness\n  ports:\n    - &quot;3000:3000&quot;\n  links:\n    - db\nsass:\n  image: larryprice/sass\n  volumes:\n    - ./public/css:/src\njsx:\n  image: larryprice/jsx\n  volumes:\n    - ./public/scripts:/src\ndb:\n  image: mongo:3.0\n  command: mongod --smallfiles --quiet --logpath=/dev/null\n  volumes_from:\n    - dbvolume\ndbvolume:\n  image: busybox:ubuntu-14.04\n  volumes:\n    - /data/db\n\n\n然后运行docker-compose up来运行所有的容器并启动服务器。","readingtime":19,"url":"/cates/backend/post/2015-11-11/Go-Web-architecture","dirs":["go"],"relatives":[{"url":"/cates/backend/post/2015-11-12/HTTP-2-And-GO","title":"HTTP/2 和GO"},{"url":"/cates/backend/post/2015-11-15/create-a-homepage-for-Go-Web-App","title":"为Go Web App 创建一个主页面"},{"url":"/cates/backend/post/2015-11-12/develop-HTTP-middleware-using-Go","title":"使用Go开发HTTP中间件"},{"url":"/cates/backend/post/2015-11-13/http-Handler-And-Go-error-handle","title":"http.Handler 与Go的错误处理"}]},{"title":"HTTP/2 和GO","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-252006883.jpg","iso8601Date":"2015-11-12T19:39:21+08:00","basename":"HTTP-2-And-GO","tags":["Http","HTTP/2","Translate","Go","Backend"],"date":"2015-11-12","cate":"backend","summary":"原文地址\n\nHTTP/2是一个添加了一些新功能的HTTP的新版本，这些功能包括连接复用，首部压缩。再Go的标准库中暂时还没有HTTP/2的实现，但是现在有很多正在开发的库可以用来在Go中实现HTTP/2的server和client。\n\nBrad Fitzpatrick实现了一个golang.org/x/net/http2的库，这个库甚至最终会加入到标准库中，不过他现在正在开发，所以在其他的库中。因为他现在的开发很活跃，所有情况因人而异，但是如果你想实现HTTP/2的服务器，仍然可以使用这个库。\n\n创建HTTP/2服务器\n\n使用http2的库写一个服务器是很简单的。http2库和标准库的http包集成在一起，需要调用http2.ConfigureServer()来配置一个普通http使用HTTP/2协议。如果需要通过浏览器访问或者降级到HTTP 1.x 协议，那么你需要设置TLS 加密。虽然加密不是必须的，但是现在还没有浏览器支持非加密的HTTP/2协议。\n\n`Go\npackage main\n\nimport (\n    &quot;log&quot;\n    &quot;net/http&quot;\n    &quot;os&quot;\n\n&quot;golang.org/x/net/http2&quot;\n\n)\n\nfunc main() {\n    cwd, err := os.Getwd()\n    if err != nil {\n        log.Fatal(err)\n    }\n\nsrv := &amp;http.Server{\n    Addr:    &quot;:8000&quot;, // Normally &quot;:443&quot;\n    Handler: http.FileServer(http.Dir(cwd)),\n}\nhttp2.ConfigureServer(srv, &amp;http2.Server{})\nlog.Fatal(srv.ListenAndServeTLS(&quot;server.crt&quot;, &quot;server.key&quot;))\n\n}\n`\n\n创建HTTP/2 客户端\n\n现在使用http2的库创建客户端很hacky。虽然它会输出很多调试日志，但是对于大多数情况下运行的很好。可以使用http2.Transport对象，将他传给http包的client。\n\n`Go\npackage main\n\nimport (\n    &quot;fmt&quot;\n    &quot;io/ioutil&quot;\n    &quot;log&quot;\n    &quot;net/http&quot;\n\n&quot;golang.org/x/net/http2&quot;\n\n)\n\nfunc main() {\n    client := http.Client{\n        // InsecureTLSDial is temporary and will likely be\n        // replaced by a different API later.\n        Transport: &amp;http2.Transport{InsecureTLSDial: true},\n    }\n\nresp, err := client.Get(&quot;https://localhost:8000/&quot;)\nif err != nil {\n    log.Fatal(err)\n}\n\nbody, err := ioutil.ReadAll(resp.Body)\nif err != nil {\n    log.Fatal(err)\n}\n\nfmt.Println(string(body))\n\n}\n`\n\n更多阅读\n\n如果你对HTTP/2协议感兴趣，那么可以参考HTTP/2 主页，这个页面有很多其他资料的连接还有其他语言的实现。\n\n如果你想知道HTTP/2的服务端和客户端是如何实现的，那么Jxck&#39;s http2 implementation的实现就很值得一读。Jxck通过对标准的HTTP库的TLSNextProto设置一个钩子来实现的。你可以再这里阅读一些示例。\n\ngrpc-go 库同样也有自己的服务端和客户端的实现。","readingtime":5,"url":"/cates/backend/post/2015-11-12/HTTP-2-And-GO","dirs":["go"],"relatives":[{"url":"/cates/backend/post/2015-11-11/Go-Web-architecture","title":"Go Web 架构"},{"url":"/cates/backend/post/2015-11-15/create-a-homepage-for-Go-Web-App","title":"为Go Web App 创建一个主页面"},{"url":"/cates/backend/post/2015-11-12/develop-HTTP-middleware-using-Go","title":"使用Go开发HTTP中间件"},{"url":"/cates/backend/post/2015-11-13/http-Handler-And-Go-error-handle","title":"http.Handler 与Go的错误处理"}]},{"title":"使用Go开发HTTP中间件","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-228204533.jpg","iso8601Date":"2015-11-12T20:07:49+08:00","basename":"develop-HTTP-middleware-using-Go","tags":["HTTP","Go","Middleware","Backend"],"date":"2015-11-12","cate":"backend","summary":"原文地址\n\n 再web开发的背景下，“中间件”通常意思是“包装原始应用并添加一些额外的功能的应用的一部分”。这个概念似乎总是不被人理解，但是我认为中间件非常棒。\n 首先，一个好的中间件有一个责任就是可插拔并且自足。这就意味着你可以在接口级别嵌入你的中间件他就能直接运行。它不会影响你编码方式，不是框架，仅仅是你请求处理里面的一层而已。完全没必要重写你的代码，如果你想使用中间件的一个功能，你就帮他插入到那里，如果不想使用了，就可以直接移除。\n 纵观Go语言，中间件是非常普遍的，即使在标准库中。虽然开始的时候不会那么明显，在标准库net/http中的函数StripText或者TimeoutHandler就是我们要定义和的中间件的样子，处理请求和相应的时候他们包装你的handler，并处理一些额外的步骤。\n 我最近写的Go包nosurf同样也是个中间件。我特意将他从头开始设计。在大多数情况下，你不需要在应用层担心CSRF攻击，nosurf像其他的中间件一样可以自足，并且和net/http的接口无缝衔接。\n 同样你还可以使用中间件做：\n 隐藏长度防止缓冲攻击\n 速度限制\n 屏蔽爬虫\n 提供调试信息\n 添加HSTS，X-Frame-Options头\n 从错误中恢复\n* 等等\n\n编写一个简单的中间件\n\n 我们的第一个例子是写一个只允许一个域名下的用户访问的中间件，通过HTTP的HOSTheader实现。这样的中间件可以防止主机欺骗攻击。\n\n类型的机构\n\n 首先我们定义一个结构体，叫做SingleHost\n\nGo\ntype SingleHost struct {\n    handler     http.Handler\n    allowedHost string\n}\n\n\n 它只包含两个field。\n 如果是一个可用的Host，那么我们会调用嵌入的handler。\n allowedHost 就是允许的Host。\n 因为我们将其首字母小写，因此他们只对本包可见。我们需要给它定义已给构造函数。\n\nGo\nfunc NewSingleHost(handler http.Handler, allowedHost string) *SingleHost {\n    return &amp;SingleHost{handler: handler, allowedHost: allowedHost}\n}\n\n\n请求处理\n\n 现在需要实现真正的逻辑功能了。想要实现http.Handler，我们只需要实现他的一个方法。\n\nGo\ntype Handler interface {\n        ServeHTTP(ResponseWriter, *Request)\n}\n\n\n 实现如下：\n\nGo\nfunc (s *SingleHost) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    host := r.Host\n    if host == s.allowedHost {\n        s.handler.ServeHTTP(w, r)\n    } else {\n        w.WriteHeader(403)\n    }\n}\n\n\nServeHTTP只是检查请求的Host：\n 如果Host和配置的allowed一直，那么调用handler的ServeHTTP。\n 如果不一直返回403\n对于后一种情况，不仅不会得到应答，设置不知道有这个请求。\n现在我们已经开发哈了中间件，只需要将其插入到需要的地方。\n\nGo\nsingleHosted = NewSingleHost(myHandler, &quot;example.com&quot;)\nhttp.ListenAndServe(&quot;:8080&quot;, singleHosted)\n\n\n另一种方式\n\n 我们刚刚写的那个中间件很简单，它只有15行代码。写这样的中间件，可以使用样板方法。由于Go支持函数为一等公民和闭包，并且有http.HandlerFunc包装函数，我们可以通过他创建一个中间件，而不是将其放入到一个结构体中。下面是这个中间件的写法。\n\nGo\nfunc SingleHost(handler http.Handler, allowedHost string) http.Handler {\n    ourFunc := func(w http.ResponseWriter, r *http.Request) {\n        host := r.Host\n        if host == allowedHost {\n            handler.ServeHTTP(w, r)\n        } else {\n            w.WriteHeader(403)\n        }\n    }\n    return http.HandlerFunc(ourFunc)\n}\n\n 我们定义了一个简单的函数SingleHost，它包装了Handler和允许的Host，在其内部我们实现了一个跟上面中间件类似的功能。我们内部的函数就是一个闭包，因此他可以访问外部函数的变量。最终HandlerFunc让我们可以将其变为Handler。\n 觉得是使用HandlerFunc还是自己实现一个http.Handler完全取决于你自己。对于简单的情况，一个简单的函数就完全够了。如果你的中间件越来越多，那么就可以考虑实现自己的结构并把它们分开。\n 同时标准库同时使用了两种功能。StripPrefix使用的是HandlerFunc，TimeoutHandler使用的是自定义的结构体。\n\n一个更复杂的例子\n\n 我们的SingleHost并不重要，我们只检测一个属性，要么将他传递给其他的handler，要么直接返回。然而存在这种情况，我们的程序需要对处理完进行后续处理。\n\n添加数据是简单的\n\n 如果只是想简单的添加数据，那么使用Write就可以了。\n\n`Go\ntype AppendMiddleware struct {\n    handler http.Handler\n}\n\nfunc (a AppendMiddleware) ServeHTTP(w http.ResponseWriter, r http.Request) {\n    a.handler.ServeHTTP(w, r)\n    w.Write([]byte(&quot;Middleware says hello.&quot;))\n}\n`\n\n 返回的结构肯定会包含Middleware says hello.\n\n问题\n\n 但是操作其他的数据有点困难。例如我们想要在它前面添加数据而不是后面追加。如果我们在原Handler之前调用Write，那么将会失去控制，因为第一个Write已经将他写入了。\n 通过其他方法修改原始输出，例如替换字符串，改变响应header，或者设置状态码都不会起作用，因为当handler返回的时候数据已经返回到客户端了。\n 为了实现这个功能，我们需要一个特殊的ResponseWriter，他可以想buffer一样工作，收集数据，存储以备使用和修改。然后我们将这个ResponseWriter传递给handler，而不是传递真是的RW，这样在其之前我们已经修改了它了。\n 幸运的是在标准库中有这样的一个工具。在net/http/httptest包里的ResponseRecorder能做所有我们需要的：保存状态码，一个响应header的map，将body放入byte 缓冲中。虽然它是再测试中中使用的，但是很服务我们的情况。\n\n`Go\ntype ModifierMiddleware struct {\n    handler http.Handler\n}\n\nfunc (m ModifierMiddleware) ServeHTTP(w http.ResponseWriter, r http.Request) {\n    rec := httptest.NewRecorder()\n    // passing a ResponseRecorder instead of the original RW\n    m.handler.ServeHTTP(rec, r)\n    // after this finishes, we have the response recorded\n    // and can modify it before copying it to the original RW\n\n// we copy the original headers first\nfor k, v := range rec.Header() {\n    w.Header()[k] = v\n}\n// and set an additional one\nw.Header().Set(&quot;X-We-Modified-This&quot;, &quot;Yup&quot;)\n// only then the status code, as this call writes out the headers \nw.WriteHeader(418)\n\n// The body hasn&#39;t been written (to the real RW) yet,\n// so we can prepend some data.\ndata := []byte(&quot;Middleware says hello again. &quot;)\n\n// But the Content-Length might have been set already,\n// we should modify it by adding the length\n// of our own data.\n// Ignoring the error is fine here:\n// if Content-Length is empty or otherwise invalid,\n// Atoi() will return zero,\n// which is just what we&#39;d want in that case.\nclen, _ := strconv.Atoi(r.Header.Get(&quot;Content-Length&quot;))\nclen += len(data)\nr.Header.Set(&quot;Content-Length&quot;, strconv.Itoa(clen))\n\n// finally, write out our data\nw.Write(data)\n// then write out the original body\nw.Write(rec.Body.Bytes())\n\n}\n`\n最后僵尸我们中间件的输出：\n\n`\nHTTP/1.1 418 I&#39;m a teapot\nX-We-Modified-This: Yup\nContent-Type: text/plain; charset=utf-8\nContent-Length: 37\nDate: Tue, 03 Sep 2013 18:41:39 GMT\n\nMiddleware says hello again. Success!\n`\n这样就开启了一种新的可能，包装的handler完全手控制。\n\n和其他handler分享数据\n\n 在其他例子中，中间件可能需要暴露一些信息给其他中间件或者应用本身。例如nosurf需要给其他用户访问CSRF token的权限。\n 最简单是是使用一个map，但是通常不希望这样。它将http.Request 的指针作为key，其他数据作为value。下面是nosurf的例子，Go的map非线程安全，所以要自己是实现。\n\n`Go\ntype csrfContext struct {\n    token string\n    reason error\n}\n\nvar (\n    contextMap = make(map[http.Request]csrfContext)\n    cmMutex    = new(sync.RWMutex)\n)\n`\n 数据由Token设置：\n\n`Go\nfunc Token(req *http.Request) string {\n    cmMutex.RLock()\n    defer cmMutex.RUnlock()\n\nctx, ok := contextMap[req]\nif !ok {\n        return &quot;&quot;\n}\n\nreturn ctx.token\n\n}\n`\n源码可以再nosurf的项目的context.go中找到。","readingtime":11,"url":"/cates/backend/post/2015-11-12/develop-HTTP-middleware-using-Go","dirs":["go"],"relatives":[{"url":"/cates/backend/post/2015-11-11/Go-Web-architecture","title":"Go Web 架构"},{"url":"/cates/backend/post/2015-11-12/HTTP-2-And-GO","title":"HTTP/2 和GO"},{"url":"/cates/backend/post/2015-11-15/create-a-homepage-for-Go-Web-App","title":"为Go Web App 创建一个主页面"},{"url":"/cates/backend/post/2015-11-13/http-Handler-And-Go-error-handle","title":"http.Handler 与Go的错误处理"}]},{"title":"http.Handler 与Go的错误处理","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-186674453.jpg","iso8601Date":"2015-11-13T05:24:57+08:00","basename":"http-Handler-And-Go-error-handle","tags":["Go","Translate","Backend"],"date":"2015-11-13","cate":"backend","summary":"原文地址\n\n 在之前我写过一篇关于通过使用http.HandlerFunc来实现一个定制handler类型用来避免一些平常的错误的文章。func MyHandler(w http.ResponseWriter, r *http.Request)的签名经常可以看到。这是一个有用的通用的包含一些基本功能的handler类型，但是和其他事情一样，也有一些不足：\n 当你想要在一个handler中停止处理的时候，必须记得显示的调用一个return。这个在当你想要跑出一个从定向（301、302），未找到（404）或者服务器端错误（500）的状态的时候是很平常的。如果不这么做可能会引起一些微妙的错误（函数会继续执行），因为函数不需要一个返回值，编译器也不会警告你。\n 不容易传递额外的参数（例如，数据库连接池，配置）。你最后不得不实用一系列的全局变量（不算太坏，但是跟踪他们会导致难以扩展）或者将他们存到请求上下文中，然后每次都从其取出。这样做很笨重。\n* 一直在不断的重复同样的语句。想要记录数据库包返回的错误？既可以再每个查询方法中调用log.Printf，也可以再每个handler中返回错误。如果你的handler可以返回给一个集中记录错误的函数，并且跑出一个500的错误就更好了。\n\n 我以前的方法中使用了func(http.ResponseWriter, *http.Request)签名。这已经被证明是一个简介的方式，但是有个奇怪的地方是，返回一个无错误的状态，例如，200,302,303往往是多余的，因为要么你已经在其他地方设置了，要么就是没用的。例如：\n\n`Go\nfunc SomeHandler(w http.ResponseWriter, r *http.Request) (int, error) {\n    db, err := someDBcall()\n    if err != nil {\n        // This makes sense.\n        return 500, err\n    }\n\nif user.LoggedIn {\n    http.Redirect(w, r, &quot;/dashboard&quot;, 302)\n    // Superfluous! Our http.Redirect function handles the 302, not \n    // our return value (which is effectively ignored).\n    return 302, nil\n}\n\n}\n`\n\n看起来还行，但是我们可以做的更好\n\n一些区别\n\n 那么我们应该如何改进它？我们先列出代码：\n\n`Go\npackage handler\n\n// Error represents a handler error. It provides methods for a HTTP status \n// code and embeds the built-in error interface.\ntype Error interface {\n    error\n    Status() int\n}\n\n// StatusError represents an error with an associated HTTP status code.\ntype StatusError struct {\n    Code int\n    Err  error\n}\n\n// Allows StatusError to satisfy the error interface.\nfunc (se StatusError) Error() string {\n    return se.Err.Error()\n}\n\n// Returns our HTTP status code.\nfunc (se StatusError) Status() int {\n    return se.Code\n}\n\n// A (simple) example of our application-wide configuration.\ntype Env struct {\n    DB   *sql.DB\n    Port string\n    Host string\n}\n\n// The Handler struct that takes a configured Env and a function matching\n// our useful signature.\ntype Handler struct {\n    Env\n    H func(e Env, w http.ResponseWriter, r *http.Request) error\n}\n\n// ServeHTTP allows our Handler type to satisfy http.Handler.\nfunc (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    err := h.H(h.Env, w, r)\n    if err != nil {\n        switch e := err.(type) {\n        case Error:\n            // We can retrieve the status here and write out a specific\n            // HTTP status code.\n            log.Printf(&quot;HTTP %d - %s&quot;, e.Status(), e)\n            http.Error(w, e.Error(), e.Status())\n        default:\n            // Any error types we don&#39;t specifically look out for default\n            // to serving a HTTP 500\n            http.Error(w, http.StatusText(http.StatusInternalServerError),\n                http.StatusInternalServerError)\n        }\n    }\n}\n`\n\n 上面的代码不言自明，但是要说明一下一些突出的观点：\n\n我们自定义了一个Error类型（接口），他内嵌了Go的内建的error接口，同时提供了一个Status() int方法。我们提供了一个简单的StatusError类型（结构体），它满足handler.Error的接口。StatusError接受一个HTTP的状态码（int类型），一个可以让我们包装错误用来记录或者查询的error类型。我们的ServeHTTP方法包好了一个&quot;e := err.(type)&quot;的类型断言，它可以测试我们需要处理的错误，允许我们处理那些特别的错误。在这个例子中，他是只是一个handler.Error类型。其他的错误，例如其他包中的错误想net.Error，或者其他我们定义的额外的错误，如果想要检查，同样也可以检查。如果我们不想捕捉那些错误，那么default将会默认捕捉到。记住一点，ServeHTTP可以使我们的Handler类型满足http.Handler接口，这样他就可以在任何使用http.Handler的地方使用了，例如Go的net/http包或者所有的其他的第三方框架。这样使得定制的handler更有用，他们用起来很灵活。\n注意 net 包处理事情很简单。它又一个net.Error的接口，内嵌了内建的error接口。一些具体的类型实现了它。函数返回的具体类型跟错误的类型相同（DNS错误，解析错误等）。再datastore 包中定义的DBError有一个Query() string 方法，可以很好的解释。\n\n所有示例\n\n 它最后是什么样子的？我们是否可以将其分到不同的包中？\n\n`Go\npackage handler\n\nimport (\n    &quot;net/http&quot;\n)\n\n// Error represents a handler error. It provides methods for a HTTP status \n// code and embeds the built-in error interface.\ntype Error interface {\n    error\n    Status() int\n}\n\n// StatusError represents an error with an associated HTTP status code.\ntype StatusError struct {\n    Code int\n    Err  error\n}\n\n// Allows StatusError to satisfy the error interface.\nfunc (se StatusError) Error() string {\n    return se.Err.Error()\n}\n\n// Returns our HTTP status code.\nfunc (se StatusError) Status() int {\n    return se.Code\n}\n\n// A (simple) example of our application-wide configuration.\ntype Env struct {\n    DB   *sql.DB\n    Port string\n    Host string\n}\n\n// The Handler struct that takes a configured Env and a function matching\n// our useful signature.\ntype Handler struct {\n    Env\n    H func(e Env, w http.ResponseWriter, r *http.Request) error\n}\n\n// ServeHTTP allows our Handler type to satisfy http.Handler.\nfunc (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    err := h.H(h.Env, w, r)\n    if err != nil {\n        switch e := err.(type) {\n        case Error:\n            // We can retrieve the status here and write out a specific\n            // HTTP status code.\n            log.Printf(&quot;HTTP %d - %s&quot;, e.Status(), e)\n            http.Error(w, e.Error(), e.Status())\n        default:\n            // Any error types we don&#39;t specifically look out for default\n            // to serving a HTTP 500\n            http.Error(w, http.StatusText(http.StatusInternalServerError),\n                http.StatusInternalServerError)\n        }\n    }\n}\n\nfunc GetIndex(env Env, w http.ResponseWriter, r http.Request) error {\n    users, err := env.DB.GetAllUsers()\n    if err != nil {\n        // We return a status error here, which conveniently wraps the error\n        // returned from our DB queries. We can clearly define which errors \n        // are worth raising a HTTP 500 over vs. which might just be a HTTP \n        // 404, 403 or 401 (as appropriate). It&#39;s also clear where our \n        // handler should stop processing by returning early.\n        return StatusError{500, err}\n    }\n\nfmt.Fprintf(w, &quot;%+v&quot;, users)\nreturn nil\n\n}\n`\n\n main包：\n\n`Go\npackage main\n\nimport (\n    &quot;net/http&quot;\n    &quot;github.com/you/somepkg/handler&quot;\n)\n\nfunc main() {\n    db, err := sql.Open(&quot;connectionstringhere&quot;)\n    if err != nil {\n          log.Fatal(err)\n    }\n\n// Initialise our app-wide environment with the services/info we need.\nenv := &amp;handler.Env{\n    DB: db,\n    Port: os.Getenv(&quot;PORT&quot;),\n    Host: os.Getenv(&quot;HOST&quot;),\n    // We might also have a custom log.Logger, our \n    // template instance, and a config struct as fields \n    // in our Env struct.\n}\n\n// Note that we&#39;re using http.Handle, not http.HandleFunc. The \n// latter only accepts the http.HandlerFunc type, which is not \n// what we have here.\nhttp.Handle(&quot;/&quot;, handler.Handler{env, handler.GetIndex})\n\n// Logs the error if ListenAndServe fails.\nlog.Fatal(http.ListenAndServe(&quot;:8000&quot;, nil))\n\n}\n`\n\n 在实际使用时，会将handler和Env放入不同的包中，这里只是为了简单放在了同一个包中。","readingtime":11,"url":"/cates/backend/post/2015-11-13/http-Handler-And-Go-error-handle","dirs":["go"],"relatives":[{"url":"/cates/backend/post/2015-11-11/Go-Web-architecture","title":"Go Web 架构"},{"url":"/cates/backend/post/2015-11-12/HTTP-2-And-GO","title":"HTTP/2 和GO"},{"url":"/cates/backend/post/2015-11-15/create-a-homepage-for-Go-Web-App","title":"为Go Web App 创建一个主页面"},{"url":"/cates/backend/post/2015-11-12/develop-HTTP-middleware-using-Go","title":"使用Go开发HTTP中间件"}]},{"title":"为Go Web App 创建一个主页面","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-252035635.jpg","iso8601Date":"2015-11-15T01:59:00+08:00","basename":"create-a-homepage-for-Go-Web-App","tags":["Go","Translate","Backend"],"date":"2015-11-15","cate":"backend","summary":"原文地址\n\n 大多数web app都有一个相同的布局。这个布局可能包含一个header或者footer，甚至可能包含一个导航菜单。Go的标准库提供一个简单的方式来创建这些基本元素，通过被不同的页面重用，创建出模板页的效果。\n 这个简单的例子来解释如何实现的：\n 让我们来创建一个简单的包含两个view的web app，一个是 main 一个是about。这两个view都有相同的header和footer。\n header模板的代码如下：\n\nhtml\n{ { define &quot;header&quot; }}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;{ {.Title}}&lt;/title&gt;\n        &lt;link rel=&quot;stylesheet&quot; href=&quot;//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css&quot;&gt;\n        &lt;link rel=&quot;stylesheet&quot; href=&quot;//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-theme.min.css&quot;&gt;\n        &lt;style type=&quot;text/css&quot;&gt;\n            body {padding-bottom: 70px;}\n            .content {margin:10px;}\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;nav class=&quot;navbar navbar-default&quot; role=&quot;navigation&quot;&gt;\n          &lt;div class=&quot;navbar-header&quot;&gt;\n            &lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&gt;Go App&lt;/a&gt;\n          &lt;/div&gt;\n          &lt;div class=&quot;collapse navbar-collapse navbar-ex1-collapse&quot;&gt;  \n            &lt;ul class=&quot;nav navbar-nav&quot;&gt;\n                &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Main&lt;/a&gt;&lt;/li&gt;\n                &lt;li&gt;&lt;a href=&quot;/about&quot;&gt;About&lt;/a&gt;&lt;/li&gt;\n            &lt;/ul&gt;\n          &lt;/div&gt;\n        &lt;/nav&gt;\n{ { end }}\n\n\n footer模板的代码如下：\n\n`html\n{ { define &quot;footer&quot; }}\n        &lt;p class=&quot;navbar-text navbar-fixed-bottom&quot;&gt;Go Rocks!&lt;/p&gt;          &lt;script src=&quot;//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n{ { end }}\n\n`\n\n main 模板的代码如下：\n\nhtml\n{ {define &quot;main&quot;}}\n{ { template &quot;header&quot; .}}\n&lt;div class=&quot;content&quot;&gt;\n    &lt;h2&gt;Main&lt;/h2&gt;\n    &lt;div&gt;This is the Main page&lt;/div&gt;\n&lt;/div&gt;\n{ {template &quot;footer&quot; .}}\n{ { end}}\n\n\n about 模板的代码如下：\n\nhtml\n{ {define &quot;about&quot;}}\n{ { template &quot;header&quot; .}}\n&lt;div class=&quot;content&quot;&gt;\n    &lt;h2&gt;About&lt;/h2&gt;\n    &lt;div&gt;This is the About page&lt;/div&gt;\n&lt;/div&gt;\n{ {template &quot;footer&quot; .}}\n{ { end}}\n\n\n 服务器代码如下：\n\n`Go\npackage main\n\nimport (\n    &quot;html/template&quot;\n    &quot;net/http&quot;\n)\n\n//Compile templates on start\nvar templates = template.Must(template.ParseFiles(&quot;header.html&quot;, &quot;footer.html&quot;, &quot;main.html&quot;, &quot;about.html&quot;))\n\n//A Page structure\ntype Page struct {\n    Title string\n}\n\n//Display the named template\nfunc display(w http.ResponseWriter, tmpl string, data interface{}) {\n    templates.ExecuteTemplate(w, tmpl, data)\n}\n\n//The handlers.\nfunc mainHandler(w http.ResponseWriter, r *http.Request) {\n    display(w, &quot;main&quot;, &amp;Page{Title: &quot;Home&quot;})\n}\n\nfunc aboutHandler(w http.ResponseWriter, r *http.Request) {\n    display(w, &quot;about&quot;, &amp;Page{Title: &quot;About&quot;})\n}\n\nfunc main() {\n    http.HandleFunc(&quot;/&quot;, mainHandler)\n    http.HandleFunc(&quot;/about&quot;, aboutHandler)\n\n//Listen on port 8080\nhttp.ListenAndServe(&quot;:8080&quot;, nil)\n\n}\n`\n\n 每一个模板页都有一个 { { define &quot;name&quot; }}的命令来定义模板的名字。main和about页面通过{ { template &quot;name&quot; }}来包含header和footer。. 出入上下文来命名模板。现在，不管main和about页面如何执行，他们的页面都会包含header和footer。\n 两个页面的结果如下：\n\n  ","readingtime":6,"url":"/cates/backend/post/2015-11-15/create-a-homepage-for-Go-Web-App","dirs":["go"],"relatives":[{"url":"/cates/backend/post/2015-11-11/Go-Web-architecture","title":"Go Web 架构"},{"url":"/cates/backend/post/2015-11-12/HTTP-2-And-GO","title":"HTTP/2 和GO"},{"url":"/cates/backend/post/2015-11-12/develop-HTTP-middleware-using-Go","title":"使用Go开发HTTP中间件"},{"url":"/cates/backend/post/2015-11-13/http-Handler-And-Go-error-handle","title":"http.Handler 与Go的错误处理"}]},{"title":"OKHttp的调用","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-247611167.jpg","iso8601Date":"2017-03-18T23:10:03+08:00","basename":"calls","tags":["Translate","Java","OKHttp","HTTP","Backend"],"date":"2017-03-18","cate":"backend","summary":"原文地址\n\nHTTP客户端的任务是接受请求和产生响应。理论很简单，但是实战的时候就有点棘手了。\n\nRequests\n\n每一个HTTP请求都包含一个URL，一个方法（例如，GET，POST）和一些headers。请求同时可以包含一个特定类型的数据流作为body。\n\nResponses\n\nResponse 通过一个一个状态码（例如，200 成功，404未找到），headers，和一个可选的Body来响应请求。\n\n重写请求\n\n当使用OkHttp发送HTTP请求的时候，可以在高层次描述这个请求：通过这个URL和这些headers来获取响应。为了准确和更高的效率，OKHttp会在发送之前重现请求。\nOkHttp将会添加原请求没有的header，包括Content-length,Transfer-Encoding,User-Agent,Host,Connection，Content-Type。除非已经提供了，否则OKHttp回会添加 Acceept-Encoding来压缩响应。如果有Cookie，也会添加Cookie。\n有些请求会缓存响应。当被缓存的响应过期后，OKHttp会发送一个有条件的GET请求来获取新的响应，如果新现在的比缓存的响应更新，将会更新缓存过的响应。这要求If-Modified-Since和If-None-Match添加到headers中。\n\n重写响应\n\n如果透明压缩启用了，OKHttp将会把Content-Encoding和Content-Length从headers中移除，因为他们不是用来解压缩的。\n如果条件GET请求成功，从网上下载的响应和缓存的响应根据Spec合并。\n\n后续请求\n\n当请求的URL被转移了，web server 将会返回一个302的状态码来表示这个文档的新URL，OKHttp将会重定向到新的URL获取最终的响应。\n如果响应需要认证，OKHttp将会使用Authenticator（如果提供了一个）来认证。如果认证器提供了凭证，请求回使用凭证重试。\n\n重试请求\n\n有时连接失败，例如：连接池过期断开链接，或者无法连接服务器。OKHttp会通过不同的可用路由来重试请求。\n\ncalls\n\n通过重写，重定向，继续请求和重试，一个简单的请求可能会产生很多请求和响应。OKHttp使用call建立一个不管多少中间请求和响应的任务模型。总的来说这不多。但是了解代码将会继续工作，不管是URL重定向或者是转移故障其他IP。\ncall有两种工作方\n    同步：线程将会阻塞道到响应可读。\n    异步：将请求加入到其他线程的队列，当响应可读诗时，会在其他的线程获取回调。\n请求调用可以在任何线程取消。如果调用未完成，这个请求将会失败。当调用取消时，在先请求踢体或者读响应体的代码将会跑出IOException的异常。\n\n调度\n\n对于同步调用，将会由自身线程控制多少并发请求。太多并发连接浪费资源，太少又回有高延迟。\n对于异步来说，Dispatcher实现了最大并发的策略。可以设置没个服务器的最大并发（默认是5）和总体的并发（默认64）。","readingtime":3,"url":"/cates/backend/post/2017-03-18/calls","dirs":["okhttp"],"relatives":[{"url":"/cates/backend/post/2017-03-19/Recipes","title":"OKHttp Recipes"},{"url":"/cates/backend/post/2017-03-19/connections","title":"OKHttp connections"},{"url":"/cates/backend/post/2017-03-23/https","title":"OKHttp https"},{"url":"/cates/backend/post/2017-03-19/interceptors","title":"OKHttp 拦截器"}]},{"title":"OKHttp Recipes","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-199128865.jpg","iso8601Date":"2017-03-19T03:44:10+08:00","basename":"Recipes","tags":["Java","Translate","OKHttp","HTTP","Backend"],"date":"2017-03-19","cate":"backend","summary":"原文地址\n我们写了一些建议，来演示如何使用OKHttp来解决一些常见问题。\n\n同步GET\n\n下载文件，打印header，打印body。\nstring()方法对于小文档的响应来说是个既方便有高效的方法。但是如果一个文档太大（大于1M），就不要使用string()方法了，以为他会把整个文档加载到内存中,在这种情况下可以把body当作流来处理。  \n\n`Java\nprivate final OkHttpClient client = new OkHttpClient();\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(&quot;http://publicobject.com/helloworld.txt&quot;)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nHeaders responseHeaders = response.headers();\nfor (int i = 0; i &lt; responseHeaders.size(); i++) {\nSystem.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i));\n}\nSystem.out.println(response.body().string());\n\n`\n\n #### 异步GET\n 在工作线程下载文件，响应可读后回调。在响应的header准备好的时候回调。响应体可能仍然阻塞。现在OKHttp没有提供获取响应体的异步API。\n\n`Java\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(&quot;http://publicobject.com/helloworld.txt&quot;)\n    .build();\n\nclient.newCall(request).enqueue(new Callback() {\n    @Override public void onFailure(Call call, IOException e) {\n    e.printStackTrace();\n    }\n\n@Override public void onResponse(Call call, Response response) throws IOException {\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nHeaders responseHeaders = response.headers();\nfor (int i = 0, size = responseHeaders.size(); i &lt; size; i++) {\n    System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i));\n}\n\nSystem.out.println(response.body().string());\n}\n\n});\n}\n`\n\n #### 访问Header\n 总体上说Header有点像Map&lt;String,String&gt;，每一个字段都有或没有值。但是一些Header允许有多个值，就像Guava的[Multimap](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Multimap.html)。\n 例如HTTP提供多个Vary的值是很常见并且合法的。OKHttp的API在这两种情况下都能轻松使用。\n 当写入请求header的时候使用header(name,value)设置仅有一个的name和value。如果有存在的值，会先移除值再添加。 使用addHeader(name,value)添加header不会移除已经存在的header。\n 当读响应header的时候，header(name)只返回最后一个值，通常也仅有一个。如果没有值，将会返回null。以一个list的方式获取所有的值可以使用headers(name)`。\n 如果要访问所有的header，可以使用Headers类，支持坐标访问。\n\n`Java\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(&quot;https://api.github.com/repos/square/okhttp/issues&quot;)\n    .header(&quot;User-Agent&quot;, &quot;OkHttp Headers.java&quot;)\n    .addHeader(&quot;Accept&quot;, &quot;application/json; q=0.5&quot;)\n    .addHeader(&quot;Accept&quot;, &quot;application/vnd.github.v3+json&quot;)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nSystem.out.println(&quot;Server: &quot; + response.header(&quot;Server&quot;));\nSystem.out.println(&quot;Date: &quot; + response.header(&quot;Date&quot;));\nSystem.out.println(&quot;Vary: &quot; + response.headers(&quot;Vary&quot;));\n}\n`\n\n #### 使用POST发送String请求。\n 使用HTTP的POST给服务发送请求。这个例子发送了一个markdown文档到服务器用来将markdown渲染成HTML。因为整个请求是放在内存中的，所以使用此API的时候避免大文档（小于1M）。\n\n`Java\npublic static final MediaType MEDIATYPEMARKDOWN\n    = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nString postBody = &quot;&quot;\n    + &quot;Releases\\n&quot;\n    + &quot;--------\\n&quot;\n    + &quot;\\n&quot;\n    + &quot; * 1.0 May 6, 2013\\n&quot;\n    + &quot; * 1.1 June 15, 2013\\n&quot;\n    + &quot; * 1.2 August 11, 2013\\n&quot;;\n\nRequest request = new Request.Builder()\n    .url(&quot;https://api.github.com/markdown/raw&quot;)\n    .post(RequestBody.create(MEDIATYPEMARKDOWN, postBody))\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nSystem.out.println(response.body().string());\n}\n`\n\n #### 使用POST发送流\n 使用POST将请求体以流的方式发送。请求体在被写入的时候生成。这个例子直接使用了[Okio](https://github.com/square/okio)的缓冲库。可能你更熟悉OutputStream可以通过BufferedSink.outputStream获取。\n\n`Java\npublic static final MediaType MEDIATYPEMARKDOWN\n    = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequestBody requestBody = new RequestBody() {\n    @Override public MediaType contentType() {\n    return MEDIATYPEMARKDOWN;\n    }\n\n@Override public void writeTo(BufferedSink sink) throws IOException {\nsink.writeUtf8(&quot;Numbers\\n&quot;);\nsink.writeUtf8(&quot;-------\\n&quot;);\nfor (int i = 2; i &lt;= 997; i++) {\n    sink.writeUtf8(String.format(&quot; * %s = %s\\n&quot;, i, factor(i)));\n}\n}\n\nprivate String factor(int n) {\nfor (int i = 2; i &lt; n; i++) {\n    int x = n / i;\n    if (x * i == n) return factor(x) + &quot; × &quot; + i;\n}\nreturn Integer.toString(n);\n}\n\n};\n\nRequest request = new Request.Builder()\n    .url(&quot;https://api.github.com/markdown/raw&quot;)\n    .post(requestBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nSystem.out.println(response.body().string());\n}\n`\n\n #### 使用POST发送一个文件\n 文件很容易当作一个请求体。\n\n`Java\npublic static final MediaType MEDIATYPEMARKDOWN\n    = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;);\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nFile file = new File(&quot;README.md&quot;);\n\nRequest request = new Request.Builder()\n    .url(&quot;https://api.github.com/markdown/raw&quot;)\n    .post(RequestBody.create(MEDIATYPEMARKDOWN, file))\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nSystem.out.println(response.body().string());\n}\n`\n\n #### 发送form 参数\n 使用FormBody.Builder来创建一个同HTML 的form标签方式相同的请求踢。名字和值会被编码成HTML兼容的URL编码。\n\n`Java\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequestBody formBody = new FormBody.Builder()\n    .add(&quot;search&quot;, &quot;Jurassic Park&quot;)\n    .build();\nRequest request = new Request.Builder()\n    .url(&quot;https://en.wikipedia.org/w/index.php&quot;)\n    .post(formBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nSystem.out.println(response.body().string());\n}\n`\n\n #### 发送multipart请求\n MultipartBody.Builder可以创建和HTML上传文件兼容的请求。每一个multipart请求体自身也是请求体，可以有自己的header。如果提供了，这些header仅描述自身的一部分，例如Content-Dispositon。Content-Type,Content-Length如果可用会自动添加。\n\n`Java\nprivate static final String IMGURCLIENTID = &quot;...&quot;;\nprivate static final MediaType MEDIATYPEPNG = MediaType.parse(&quot;image/png&quot;);\n\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\n// Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image\nRequestBody requestBody = new MultipartBody.Builder()\n    .setType(MultipartBody.FORM)\n    .addFormDataPart(&quot;title&quot;, &quot;Square Logo&quot;)\n    .addFormDataPart(&quot;image&quot;, &quot;logo-square.png&quot;,\n        RequestBody.create(MEDIATYPEPNG, new File(&quot;website/static/logo-square.png&quot;)))\n    .build();\n\nRequest request = new Request.Builder()\n    .header(&quot;Authorization&quot;, &quot;Client-ID &quot; + IMGURCLIENTID)\n    .url(&quot;https://api.imgur.com/3/image&quot;)\n    .post(requestBody)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nSystem.out.println(response.body().string());\n}\n\n #### 使用Gson解析响应JSON\n [Gson](http://code.google.com/p/google-gson/)是一个很顺手的转换Java对象和JSON的API。这里我们用它来解析GitHub响应的JSON。\n 注意，ResponseBody.charStream()使用content-type`的响应header来选择解码响应流的字符集，如果没有提供默认使用UTF-8。\n\n`Java\nprivate final OkHttpClient client = new OkHttpClient();\nprivate final Gson gson = new Gson();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(&quot;https://api.github.com/gists/c2a7c39532239ff261be&quot;)\n    .build();\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nGist gist = gson.fromJson(response.body().charStream(), Gist.class);\nfor (Map.Entry&lt;String, GistFile&gt; entry : gist.files.entrySet()) {\n    System.out.println(entry.getKey());\n    System.out.println(entry.getValue().content);\n}\n}\n\nstatic class Gist {\nMap&lt;String, GistFile&gt; files;\n}\n\nstatic class GistFile {\nString content;\n}\n`\n\n #### 响应缓存\n 为了换成响应需要又一个可读写的缓存目录并且限制缓存的大小。缓存目录应该是私有的，并且非信任的应用无权访问。 同时访问一个缓冲目录回出现错误。大多数应用应该调用一次new OkHttpClient()，配置它的缓存，在其他地方使用统一个实例。否则两个缓存实例会互相损害，损坏换成，可能是你的应用崩溃。\n 响应缓存使用HTTP的header来配置。如果请求头添加了Cache-Control: max-stale=3600,OKHttp将会使用这些配置。是服务器来配置响应可以被缓存多长时间，通过响应头来配置，例如Cache-Control: max-age=9600。有一些header可以强制换成响应，强制一个网络返回或者强制一个有条件的GET确定缓存是否有效。\n\n`Java\nprivate final OkHttpClient client;\n\npublic CacheResponse(File cacheDirectory) throws Exception {\nint cacheSize = 10  1024  1024; // 10 MiB\nCache cache = new Cache(cacheDirectory, cacheSize);\n\nclient = new OkHttpClient.Builder()\n    .cache(cache)\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(&quot;http://publicobject.com/helloworld.txt&quot;)\n    .build();\n\nResponse response1 = client.newCall(request).execute();\nif (!response1.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response1);\n\nString response1Body = response1.body().string();\nSystem.out.println(&quot;Response 1 response:          &quot; + response1);\nSystem.out.println(&quot;Response 1 cache response:    &quot; + response1.cacheResponse());\nSystem.out.println(&quot;Response 1 network response:  &quot; + response1.networkResponse());\n\nResponse response2 = client.newCall(request).execute();\nif (!response2.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response2);\n\nString response2Body = response2.body().string();\nSystem.out.println(&quot;Response 2 response:          &quot; + response2);\nSystem.out.println(&quot;Response 2 cache response:    &quot; + response2.cacheResponse());\nSystem.out.println(&quot;Response 2 network response:  &quot; + response2.networkResponse());\n\nSystem.out.println(&quot;Response 2 equals Response 1? &quot; + response1Body.equals(response2Body));\n}\n`\n\n 为了阻止缓冲可以使用[CacheControl.FORCE_NETWORK](CacheControl.FORCE_NETWORK).为了阻止网络连接可以使用[CacheControl.FORCE_CACHE](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CacheControl.html#FORCE_CACHE)。警告：如果使用了FORCE_CACHE并且响应需要网络，将会返回504 Unsatisfiable Request。\n #### 取消请求\n 使用Call.cancel()立即取消正在进行的请求。如果一个线程正在写一个请求或者读一个响应将会抛出IOException。当一个请求不在需要的时候使用这个函数来保护网络。例如当用户导航离开应用的时候。同步和异步的请求都可以取消。\n\n`Java\nprivate final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay.\n    .build();\n\nfinal long startNanos = System.nanoTime();\nfinal Call call = client.newCall(request);\n\n// Schedule a job to cancel the call in 1 second.\nexecutor.schedule(new Runnable() {\n    @Override public void run() {\n    System.out.printf(&quot;%.2f Canceling call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);\n    call.cancel();\n    System.out.printf(&quot;%.2f Canceled call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);\n    }\n}, 1, TimeUnit.SECONDS);\n\ntry {\n    System.out.printf(&quot;%.2f Executing call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f);\n    Response response = call.execute();\n    System.out.printf(&quot;%.2f Call was expected to fail, but completed: %s%n&quot;,\n        (System.nanoTime() - startNanos) / 1e9f, response);\n} catch (IOException e) {\n    System.out.printf(&quot;%.2f Call failed as expected: %s%n&quot;,\n        (System.nanoTime() - startNanos) / 1e9f, e);\n}\n}\n`\n\n #### 超时\n 当端点不可达的时候使用超时使请求失败。网络分区可能是客户端连接问题，服务器可用性问题或者其他问题。OKHttp支持连接，读，写超时。\n\n`Java\nprivate final OkHttpClient client;\n\npublic ConfigureTimeouts() throws Exception {\nclient = new OkHttpClient.Builder()\n    .connectTimeout(10, TimeUnit.SECONDS)\n    .writeTimeout(10, TimeUnit.SECONDS)\n    .readTimeout(30, TimeUnit.SECONDS)\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay.\n    .build();\n\nResponse response = client.newCall(request).execute();\nSystem.out.println(&quot;Response completed: &quot; + response);\n}\n `\n\n #### 调用前配置\n 所有的HTTP调用配置都会在OkHttpClient中，包括，代理设置，超时和缓存。当需要修改某个调用的配置的时候，使用OKHttpClient.newBuilder()。这个函数会返回共享的连接池，调度器，并且跟原始client相同的配置。在下面这个例子中，一个请求的超时时间是500ms另一个是3000ms。\n\n `Java\nprivate final OkHttpClient client = new OkHttpClient();\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(&quot;http://httpbin.org/delay/1&quot;) // This URL is served with a 1 second delay.\n    .build();\n\ntry {\n    // Copy to customize OkHttp for this request.\n    OkHttpClient copy = client.newBuilder()\n        .readTimeout(500, TimeUnit.MILLISECONDS)\n        .build();\n\nResponse response = copy.newCall(request).execute();\nSystem.out.println(&quot;Response 1 succeeded: &quot; + response);\n\n} catch (IOException e) {\n    System.out.println(&quot;Response 1 failed: &quot; + e);\n}\n\ntry {\n    // Copy to customize OkHttp for this request.\n    OkHttpClient copy = client.newBuilder()\n        .readTimeout(3000, TimeUnit.MILLISECONDS)\n        .build();\n\nResponse response = copy.newCall(request).execute();\nSystem.out.println(&quot;Response 2 succeeded: &quot; + response);\n\n} catch (IOException e) {\n    System.out.println(&quot;Response 2 failed: &quot; + e);\n}\n}\n `\n\n #### 处理认证\n OKHttp会自动重试认证请求。当响应是401 Not Authorized,Authenticator需要用来提供凭证。将会重新实现一个带有凭证的请求，如果没有凭证可用跳过重试，返回null。\n 使用 Response.challenges()来获取任何认证口令的方案和域。当使用Basic认证的时候使用Credentials.basic(username,password)来编码一个header。\n\n`Java\nprivate final OkHttpClient client;\n\npublic Authenticate() {\nclient = new OkHttpClient.Builder()\n    .authenticator(new Authenticator() {\n        @Override public Request authenticate(Route route, Response response) throws IOException {\n        System.out.println(&quot;Authenticating for response: &quot; + response);\n        System.out.println(&quot;Challenges: &quot; + response.challenges());\n        String credential = Credentials.basic(&quot;jesse&quot;, &quot;password1&quot;);\n        return response.request().newBuilder()\n            .header(&quot;Authorization&quot;, credential)\n            .build();\n        }\n    })\n    .build();\n}\n\npublic void run() throws Exception {\nRequest request = new Request.Builder()\n    .url(&quot;http://publicobject.com/secrets/hellosecret.txt&quot;)\n    .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nSystem.out.println(response.body().string());\n}\n`","readingtime":22,"url":"/cates/backend/post/2017-03-19/Recipes","dirs":["okhttp"],"relatives":[{"url":"/cates/backend/post/2017-03-18/calls","title":"OKHttp的调用"},{"url":"/cates/backend/post/2017-03-19/connections","title":"OKHttp connections"},{"url":"/cates/backend/post/2017-03-23/https","title":"OKHttp https"},{"url":"/cates/backend/post/2017-03-19/interceptors","title":"OKHttp 拦截器"}]},{"title":"OKHttp connections","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-247676745.jpg","iso8601Date":"2017-03-19T03:05:48+08:00","basename":"connections","tags":["OKHttp","Translate","Java","HTTP","Backend"],"date":"2017-03-19","cate":"backend","summary":"原文地址\n虽然只提供了URL，但是OKHttp会使用URL，Address，Route三种方式来连接服务器。\n\nURLS\n\nURLs例如（https://github.com/square/okhttp) 是HTTP和Internet的基础。除了是一个表示互联网一切的命名方案，也指定了如何访问Web资源。\nURLs是抽象的：\n   它指出，调用可以是纯文本（http）或者加密（https），但是并没有指定一种加密算法。也没有指定如何验证各个端点的证书(HostnameVerifier)，或者是哪个证书可信(SSLSocketFactory)\n   它为指定是否需要使用代理服务器以及代理服务器如何授权。\n 它也是具体的，每个URL标识一个具体的路径（/square/okhttp)和查询（?q=sharks&amp;lang=en)。每个服务器有很多URL。\n\n #### Addresses\n Address指定了一个服务器（例如：github.com），以及连接服务器必要的所有的静态配置，包括：端口号，HTTPS设置，优先协议（例如，HTTP／2，SPDY）。\n URL使用了相同的Address，底层也可能实用了相同的TCP链接。复用连接可以提高性能：低延迟，高吞吐（TCP 慢启动)，低电量。OKHttp使用ConnectionPool自动复用HTTP／1.x连接，多路复用HTT／2和SPDY的连接。\n 在OKHttp，address的一些字段来源于URL（协议，主机名，端口），剩下的来自OKHttpClient。\n #### Routes\n Route提供了连接服务器必要的动态信息。包括，具体的IP地址（通过DNS查询），具体使用那个代理（ProxySelector），协n哪个TLS版本（HTTPS).\n 一个服务器可能有多条路有信息。例如：多台服务器部署在多个数据中心，DNS查询返回多个IP地址。\n #### Connections\n 当发起一个URL的请求的时候：\n   1. 使用URL和OKHttpCLient确定具体的Address。这个地址明确如何连接服务器。\n   2. 尝试从连接池中查找具体Address的连接。\n   3. 如果未找到有效的连接，使用Route来尝试获取。一般这样意味着通过DNS或去IP地址。然后，如果需要，选择一个TLS的版本和代理服务器。\n   4. 如果是一个新的Route，要么使用Socket直连，TLS隧道（HTTS方式），或者直接使用TLS。也会进行必要的TLS握手。\n   5. 发送请求，接受响应。\n 如果连接发生错误，OKHttp会选择另一个路由重试。这样OKHttp就可以在服务器端一些地址无法访问的时候恢复访问。同时如果连接池的连接失效或者常识的TLS 版本不支持也很有用。\n 当响应接收到了之后，连接会放回到连接池以便之后使用。连接在一段时间过期后回被移除连接池。","readingtime":2,"url":"/cates/backend/post/2017-03-19/connections","dirs":["okhttp"],"relatives":[{"url":"/cates/backend/post/2017-03-19/Recipes","title":"OKHttp Recipes"},{"url":"/cates/backend/post/2017-03-18/calls","title":"OKHttp的调用"},{"url":"/cates/backend/post/2017-03-23/https","title":"OKHttp https"},{"url":"/cates/backend/post/2017-03-19/interceptors","title":"OKHttp 拦截器"}]},{"title":"OKHttp 拦截器","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-229494049.jpg","iso8601Date":"2017-03-19T23:47:42+08:00","basename":"interceptors","tags":["Translate","Java","OKHttp","HTTP","Backend"],"date":"2017-03-19","cate":"backend","summary":"原文地址\n拦截器是一种监控，重写，重试请求的强大机制。下面这个例子是一个记录出发出请求和接受响应的简单的拦截器的例子。\n`Java\nclass LoggingInterceptor implements Interceptor {\n  @Override public Response intercept(Interceptor.Chain chain) throws IOException {\n    Request request = chain.request();\n\nlong t1 = System.nanoTime();\nlogger.info(String.format(&quot;Sending request %s on %s%n%s&quot;,\n    request.url(), chain.connection(), request.headers()));\n\nResponse response = chain.proceed(request);\n\nlong t2 = System.nanoTime();\nlogger.info(String.format(&quot;Received response for %s in %.1fms%n%s&quot;,\n    response.request().url(), (t2 - t1) / 1e6d, response.headers()));\n\nreturn response;\n\n  }\n}\n\n调用chain.proceed(request)`是每个拦截器最重要的实现。这个看起来简单的方法是所有HTTP工作的地方，也是对请求响应的地方。\n拦截器可以链式调用。假设你有一个压缩的拦截器和一个校验和的拦截器：你要先确定是先压缩再校验，还是先校验再压缩。OKHTTP使用列表跟踪拦截器，而且拦截器是顺序取消的。\n\n\n应用拦截器\n\n拦截器注册为应用拦截器或者网络拦截器。我们将使用上面定义的LoggingInterceptor来展示这两者的不同。\n通过调用OkHttpClient.Builder的addInterceptor()来注册一个应用拦截器。\n`Java\nOkHttpClient client = new OkHttpClient.Builder()\n    .addInterceptor(new LoggingInterceptor())\n    .build();\n\nRequest request = new Request.Builder()\n    .url(&quot;http://www.publicobject.com/helloworld.txt&quot;)\n    .header(&quot;User-Agent&quot;, &quot;OkHttp Example&quot;)\n    .build();\n\nResponse response = client.newCall(request).execute();\nresponse.body().close();\n\n链接`http://www.publicobject.com/helloworld.txt`重定向到链接`http://www.publicobject.com/helloworld.txt`,OKHttp回自动重定向。应用拦截器只会被调用一次。`chain.proceed()`返回的响应是重定向之后的响应。\nbash\nINFO: Sending request http://www.publicobject.com/helloworld.txt on null\nUser-Agent: OkHttp Example\n\nINFO: Received response for https://publicobject.com/helloworld.txt in 1179.7ms\nServer: nginx/1.4.6 (Ubuntu)\nContent-Type: text/plain\nContent-Length: 1759\nConnection: keep-alive\n\n因为response.request().url()和request.url()`获取的URL不同，所以可以得出上述结论。两行日志记录了两个不同的URL。\n\n网络拦截器\n\n注册网络拦截器和应用拦截器差不多，只是用addNetworkInterceptor()代替了addInterceptor()。\n`Java\nOkHttpClient client = new OkHttpClient.Builder()\n    .addNetworkInterceptor(new LoggingInterceptor())\n    .build();\n\nRequest request = new Request.Builder()\n    .url(&quot;http://www.publicobject.com/helloworld.txt&quot;)\n    .header(&quot;User-Agent&quot;, &quot;OkHttp Example&quot;)\n    .build();\n\nResponse response = client.newCall(request).execute();\nresponse.body().close();\n\n当运行这段代码的时候拦截器运行了两次，一次初始的地址`http://www.publicobject.com/helloworld.txt`，一次是重定向的地址`https://publicobject.com/helloworld.txt`。\nbash\nINFO: Sending request http://www.publicobject.com/helloworld.txt on Connection{www.publicobject.com:80, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=none protocol=http/1.1}\nUser-Agent: OkHttp Example\nHost: www.publicobject.com\nConnection: Keep-Alive\nAccept-Encoding: gzip\n\nINFO: Received response for http://www.publicobject.com/helloworld.txt in 115.6ms\nServer: nginx/1.4.6 (Ubuntu)\nContent-Type: text/html\nContent-Length: 193\nConnection: keep-alive\nLocation: https://publicobject.com/helloworld.txt\n\nINFO: Sending request https://publicobject.com/helloworld.txt on Connection{publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLSECDHERSAWITHAES256CBC_SHA protocol=http/1.1}\nUser-Agent: OkHttp Example\nHost: publicobject.com\nConnection: Keep-Alive\nAccept-Encoding: gzip\n\nINFO: Received response for https://publicobject.com/helloworld.txt in 80.9ms\nServer: nginx/1.4.6 (Ubuntu)\nContent-Type: text/plain\nContent-Length: 1759\nConnection: keep-alive\n\n网络请求同时也包含了更多的数据，例如:由OKHttp添加的用来支持响应压缩的Accept-Encoding: gzipheader。网络拦截器的chain有一个非空的Connection`，用来查询连接服务器的IP地址和TLS配置信息。\n\n如何选择拦截器\n\n每种拦截器都有优点。\n\n应用拦截器\n\n无需关心像重试，重定向等这样的中间过程。即使是从缓存响应，也会调用一次。只关心应用最初的目的，并不需要关心OKHttp注入的header，例如If-None-Match允许短路，不执行Chain.proceed()允许重试，执行多次Chain.proceed()\n\n网络拦截器\n\n可以操作想重试，重定向这样的中间过程。短路网络连接的从cache返回响应的时候不执行。可以监控呗发送到网络上的数据访问包含request的Connection\n\n重写请求\n\n拦截器可以添加，删除，替换请求头。如果请求有请求体，拦截器也可以转换请求体。例如：如果远程连接的服务器支持压缩，可以使用应用拦截器添加压缩请求体的拦截器。\n`Java\n/** This interceptor compresses the HTTP request body. Many webservers can&#39;t handle this! */\nfinal class GzipRequestInterceptor implements Interceptor {\n  @Override public Response intercept(Interceptor.Chain chain) throws IOException {\n    Request originalRequest = chain.request();\n    if (originalRequest.body() == null || originalRequest.header(&quot;Content-Encoding&quot;) != null) {\n      return chain.proceed(originalRequest);\n    }\n\nRequest compressedRequest = originalRequest.newBuilder()\n    .header(&quot;Content-Encoding&quot;, &quot;gzip&quot;)\n    .method(originalRequest.method(), gzip(originalRequest.body()))\n    .build();\nreturn chain.proceed(compressedRequest);\n\n  }\n\n  private RequestBody gzip(final RequestBody body) {\n    return new RequestBody() {\n      @Override public MediaType contentType() {\n        return body.contentType();\n      }\n\n  @Override public long contentLength() {\n    return -1; // We don&#39;t know the compressed length in advance!\n  }\n\n  @Override public void writeTo(BufferedSink sink) throws IOException {\n    BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));\n    body.writeTo(gzipSink);\n    gzipSink.close();\n  }\n};\n\n  }\n}\n`\n\n重写响应\n\n同样拦截器也可以重写响应，转化请求体。通常这样做比重写请求头更危险，因为这样做可能返回的并不是服务器预期值。\n如果你处在一个比较棘手的场景，并且准备处理后果，重写响应头就是一个很好的方式处理这类问题。例如：可以修复服务器未配置的Cache-Control来获取更好的缓存响应配置。\nJava\n/** Dangerous interceptor that rewrites the server&#39;s cache-control header. */\nprivate static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() {\n  @Override public Response intercept(Interceptor.Chain chain) throws IOException {\n    Response originalResponse = chain.proceed(chain.request());\n    return originalResponse.newBuilder()\n        .header(&quot;Cache-Control&quot;, &quot;max-age=60&quot;)\n        .build();\n  }\n};\n\n通常为了补充服务器相应的修复，这个方法是最好的。\n\n那些可以使用拦截器\n\n使用拦截器要求OKHttp 2.0即以上。不行的是拦截器不可以和OkUrlFactory，或者依赖于他的库同时使用，包括Retrofit1.8以下，Picasso2.4以下。","readingtime":9,"url":"/cates/backend/post/2017-03-19/interceptors","dirs":["okhttp"],"relatives":[{"url":"/cates/backend/post/2017-03-19/Recipes","title":"OKHttp Recipes"},{"url":"/cates/backend/post/2017-03-18/calls","title":"OKHttp的调用"},{"url":"/cates/backend/post/2017-03-19/connections","title":"OKHttp connections"},{"url":"/cates/backend/post/2017-03-23/https","title":"OKHttp https"}]},{"title":"mybatis 入门","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-235699493.jpg","iso8601Date":"2017-03-21T19:58:14+08:00","basename":"mybatis-started","tags":["Java","Mybatis","Translate","Backend"],"date":"2017-03-21","cate":"backend","summary":"原文链接\n\n安装\n\n使用Mybatis只需要将mybatis-x.x.x.jar添加到类路径即可。\n如果使用maven只需要将下列代码添加到pom.xml中。\nxml\n&lt;dependency&gt;\n  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\n  &lt;version&gt;x.x.x&lt;/version&gt;\n&lt;/dependency&gt;\n\n\n根据XML配置构建SqlSessionFactory\n\n每一个Mybatis应用都围绕SqlSessionFactory展开。一个SqlSessionFactory实例由SqlSessionFactoryBuilder创建。SqlSessionFacotryBuilder可以通过XML的配置文件或者一个配置好的Configuration类来创建SqlSessionFactory。\n根据XML配置来构建SqlSessionFacotry非常的简单。推荐使用在类路径来配置，但是同样可以使用任何的InputStream实例，包括一个普通的文件路径或者是file:// 的URL。Mybatis有一个叫Resource的工具函数，可以很容易的从类路径或者其他文件路径加载资源。\nJava\nString resource = &quot;org/mybatis/example/mybatis-config.xml&quot;;\nInputStream inputStream = Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n\nXML配置文件包含了Mybatis的核心设置，包括对应数据库连接的数据源，同样还有一个事务管理器来决定事务的范围和控制。完整的XML配置稍后会在文档中列出，下面是一个示例配置。\nxml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE configuration\n  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;\n  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n  &lt;environments default=&quot;development&quot;&gt;\n    &lt;environment id=&quot;development&quot;&gt;\n      &lt;transactionManager type=&quot;JDBC&quot;/&gt;\n      &lt;dataSource type=&quot;POOLED&quot;&gt;\n        &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;\n        &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;\n        &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;\n        &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;\n      &lt;/dataSource&gt;\n    &lt;/environment&gt;\n  &lt;/environments&gt;\n  &lt;mappers&gt;\n    &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;\n  &lt;/mappers&gt;\n&lt;/configuration&gt;\n\nXML配置文件的元素还有很多，上面这个配置只是指出了最重要的一部分。注意XML的header，是用来验证xml文件的。environment元素包含了一个事务管理器和一个连接池。mappers元素包含了很多mapper，mapper可以是xml配置或者只Java 的interface，他们都包含了SQL代码和mapper的定义。\n\n不使用XML构建SqlSessionFactory\n\n如果你不想使用XML配置或者想自己创建配置构造器，可以直接使用Java来构建配置。MyBatis提供了一个Configuration类可以提供所有XML配置文件所能提供的配置。\nJava\nDataSource dataSource = BlogDataSourceFactory.getBlogDataSource();\nTransactionFactory transactionFactory = new JdbcTransactionFactory();\nEnvironment environment = new Environment(&quot;development&quot;, transactionFactory, dataSource);\nConfiguration configuration = new Configuration(environment);\nconfiguration.addMapper(BlogMapper.class);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);\n\n注意在这个配置中添加了一个mapper类。mapper类包含了一个SQL映射的注解，这样可以避免使用XML配置mapper。但是由于Java注解的限制和一些MyBatis复杂的mapper配置，XML mapper仍然是一些复杂的高级映射的首选（例如，inner join)。因此MyBatis会自动寻找并加载每一个XML配置（在这个例子中BlogMapper.xml将会被从类路径中加载)。更多的稍后介绍。\n\n从SqlSessionFactory获取SqlSession\n\n 现在你已经有了SqlSessionFactory了，根据名字的提示，可以从它得到一个SqlSession实例。SqlSession包含了所有执行数据库操作的SQL方法。你可以直接通过SqlSession执行映射的SQL。例如：\nJava\nSqlSession session = sqlSessionFactory.openSession();\ntry {\n  Blog blog = session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);\n} finally {\n  session.close();\n}\n\n虽然这种方式对于之前的MyBatis的用户来说很熟悉，但是现在有一种跟清晰的方式。使用接口（例如：BlogMapper.class），该接口的方法定义了参数和返回值，这样就可以使用更加清晰的，类型安全的代码，而不再需要容易发生错误的并且去要强制类型转换的代码。例如：\nJava\nSqlSession session = sqlSessionFactory.openSession();\ntry {\n  BlogMapper mapper = session.getMapper(BlogMapper.class);\n  Blog blog = mapper.selectBlog(101);\n} finally {\n  session.close();\n}\n\n现在让我们来看一下到底执行了些什么。\n\n探索映射的SQL语句\n\n现在你可能在想SqlSession和Mapper类到底执行了什么。映射SQL语句这个主题比较大，这个主题差不多占据了此文档的一大部分。但是下面这些语句会展示这些示例到底执行了些什么。\n无论是上面还是下面这些例子，这些语句都可以被定义在XML或者注解上。让我们先使用XML类配置。通过XML映射实现的MyBatis全套功能使得MyBatis流行了很多年。如果你以前用过MyBatis，这些概念你可能很熟悉，但是也有为数众多的对XML映射文档的改进。下面是一个可以满足上面的SqlSesion调用的XML配置的映射语句。\nxml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE mapper\n  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt;\n  &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt;\n    select * from Blog where id = #{id}\n  &lt;/select&gt;\n&lt;/mapper&gt;\n\n虽然这个例子对于这个简单的项目看起来很重量级，实际上他是很轻量级的。你可以在一个XML的映射文件中定义许多的映射语句，因此你可以减少很多的XML的header和doctype声明。文件余下的部分完全可以自解释。在命名空间org.mybatis.example.BlogMapper中定义了一个名为selectBlog的映射语句。他可以让你像例子中那样通过全限定名org.mybatis.example.BlogMapper.selectBlog调用他。\nJava\nBlog blog = session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);\n\n注意他和调用的Java函数很相似，这么做是有原因的。这个名字可以直接映射具有相同名字的命名空间，函数名，参数，返回值都可以和select语句匹配。这样就可以通过简单的调用Mapper接口的函数来使用映射的SQL语句了。\nJava\nBlogMapper mapper = session.getMapper(BlogMapper.class);\nBlog blog = mapper.selectBlog(101);\n\n第二个例子有很多优势，首先他并不依赖于字符串字面量，这样他更加的安全。其次，IDE都有代码补全，当导航到映射一句的时候可以利用这个。\n\nnamespace 的注意事项MyBatis之前的版本Namespace是可选的，这样既没用又困惑。现在namespace是必须的，通过一个很长的，全限定名的语句来区分不同的语句。正如所见，namespace绑定了接口，即使你现在不使用他们，也要遵守这个规则，以防哪天改变想法。从长远来看，使用Namespace将他放在一个Java的package名中可以使代码更清晰，提高可用性。\n名字解析：为了减少输入，对于所有的命名配置，包括语句，result map， cache，使用下列名字解析规则：\n 全限定名（例如：com.mypackage.MyMapper.selectAllThings）直接查找，找到后直接使用。\n 短名字（例如：selectAllThings）可以使用任何明确的条目。然而如果匹配了多了个（例如：com.foo.selectAllThings and com.bar.selectAllThing），那么将会报名字模糊的错误，这个时候必须使用全限定名。\n\n对于BlogMapper还有一个小诀窍。他们的映射语句完全不需要XML配置文件，可以使用注解来代替。例如下面这个例子就可以代替XML配置：\nJava\npackage org.mybatis.example;\npublic interface BlogMapper {\n  @Select(&quot;SELECT * FROM blog WHERE id = #{id}&quot;)\n  Blog selectBlog(int id);\n}\n\n注解相对来说更加的简洁，但是由于注解自身的限制和一些复杂语句的复杂性，如果使用复杂的SQL语句最好还是使用XML配置。\n这个完全取决于你和你的团队和定义映射语句的一致性类决定使用哪个方式。也就是说你不需要仅仅选择一个。从注解到XML的迁移是很方便的，反之亦然。\n\n作用域和生命周期\n\n明白我们现在所讨论的类的作用域和生命周期是很重要的。错误的使用会导致并发错误。\n\n对象生命周期和依赖注入框架  依赖注入框架可以创建线程安全的，带事务管理的SqlSession和mapper并且将它们注入到需要的Bean中，因此你可以直接忽略他的生命周期。如果要熟悉MyBatis和DI 框架的关系可以看一下MyBatis-Spring 和MyBatis-Guice两个项目\n\nSqlSessionFactoryBuilder\n\n这个类被初始化，使用完之后可以直接丢弃了。当你创建完SqlSessionFactory之后就没必要留着他了。因此SqlSessionFactoryBuilder最好的作用域是在方法作用域中（例如一个本地变量）。可以重用SqlSessionFactoryBuilder来创建多个SqlSessionFactory实例，但是最好还是不要保留它，保证所有的XML都被解析用来做更重要的事情。\n\nSqlSessionFactory\n\n当SqlSesslionFactory创建了之后，就应该一直存在你的应用中。一般来说是没有理由重新创建或处理他的。在程序运行的时候最好不要多次重新构建SqlSessionFactory。如果这样做就会有坏代码的味道了。因此SqlSessionFactory的作用域最好是应用作用域。实现的方法有很多，最好的方法就是使用单例模式或者是静态单例模式。\n\nSqlSession\n\n每个线程都应该有自己的SqlSession。SqlSession的示例不能分享且非线程安全。因此最好的作用域是请求作用域和方法作用域。永远不要在静态域或者类实例中引用SqlSession。永远不要将SqlSession放到managed 作用域中，例如Servlet框架的HttpSession。如果使用的是web框架，可以将其放到HTTP 请求的作用域中。换句话说就是，接收到HTTP请求的时候可以打开SqlSesslion连接，响应的时候关闭。关闭SqlSession非常的重要，永远记得将其放在finally块中来关闭他。下面这个例子就是确保在finally中关闭SqlSesslion\nJava\nSqlSession session = sqlSessionFactory.openSession();\ntry {\n  // do work\n} finally {\n  session.close();\n}\n\n使用这个模式可以保证你的代码关闭了数据库的连接。\n\nMapper Instances\n\nMappers是你创建用来绑定映射语句的接口。每一个mapper实例都从SqlSession中获取。因此mapper的作用域和获取他们的SqlSession的作用域是一样的。然而mapper最好的租用与是方法作用域。他们应该在一个方法使用时创建，方法结束时丢弃。他们不需要显示的关闭。和SqlSession相同，将它们放到请求作用域中也是没问题的，但是在这个层次上处理如此多的资源会很棘手。所以就简单一点，把mapper实例放到方法作用域中，下面这个例子解释了如何使用他\nJava\nSqlSession session = sqlSessionFactory.openSession();\ntry {\n  BlogMapper mapper = session.getMapper(BlogMapper.class);\n  // do work\n} finally {\n  session.close();\n}\n","readingtime":9,"url":"/cates/backend/post/2017-03-21/mybatis-started","dirs":["mybatis"],"relatives":[{"url":"/cates/backend/post/2017-06-28/mybaits-configuration","title":"MyBatis 配置"}]},{"title":"OKHttp https","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-120709477.jpg","iso8601Date":"2017-03-23T21:32:29+08:00","basename":"https","tags":["Translate","Java","OKHttp","HTTP","Backend"],"date":"2017-03-23","cate":"backend","summary":"原文链接\n\nOKHttp尝试平衡两个相互矛盾的内容：\n  连接尽可能多的主机。包括使用boringssl的高级的主机和一些使用openssl的过时的主机。\n  连接的安全性。包括验证远程主机的证书，通过强密码进行数据交换。\n\n协商连接到HTTPS的时候，OKHttp需要知道需要提供的TLS版本和密码套件。如果一个客户端需要最大化链接就需要包含过时的TLS版本和弱设计的密码组合。一个严格的客户端想要最大化安全就需要只包含最新的TLS版本和强密码套件。\n安全和连接规范具体是由ConnectionSpec实现的。OKHttp包含三个内置的规范：\n  MODERN_TLS 是连接现代HTTPS服务器的配置。\n  COMPATIBLE_TLS 是连接非现代，但安全的HTTPS服务器的配置。\n * CLEARTEXT 是非安全的http的配置。\n\n默认OKHttp会尝试使用MODERN_TLS连接，如果现代配置失败，回到使用COMPATIBLE_TLS配置。\nTLS版本和密码套件在任一一个发布版本的人一个规范中都可能改变。例如，在OKHttp2.2，因为POODLE攻击就移除了SSL 3.0的支持。在OKHttp 3.0，移除了RC4的支持。同桌面浏览器一样，使用罪行的OKHttp版本可以获得最好的安全保障。\n也可以根据一组定制的TLS 版本和密码套件构建自己的规范。例如，下面这个配置要求使用三组高强度的密码套件。它的缺点就是必须是Android5.0+或者是最新的浏览器。\n`Java\nConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERNTLS)    .tlsVersions(TlsVersion.TLS12)\n    .cipherSuites(\n          CipherSuite.TLSECDHEECDSAWITHAES128GCMSHA256,\n          CipherSuite.TLSECDHERSAWITHAES128GCMSHA256,\n          CipherSuite.TLSDHERSAWITHAES128GCMSHA256)\n    .build();\n\nOkHttpClient client = new OkHttpClient.Builder() \n    .connectionSpecs(Collections.singletonList(spec))\n    .build();\n`\n\n证书锁定\n\n默认情况下OKHttp信任主机平台的证书颁发机构。这个策略可以最大化连接，但是也有可能收到权威证书攻击，例如2011 DigiNotar attack。同样也假设你的证书是权威机构颁发的。\n使用CertificatePinner限制了哪些证书和证书颁发机构值得信任。使用证书锁定可以提高安全性，但是限制了服务端团队升级他们的TLS证书。在没的到服务端团队的许可的时候不要使用证书锁定。\n`Java\n  public CertificatePinning() {\n    client = new OkHttpClient.Builder()\n        .certificatePinner(new CertificatePinner.Builder()\n            .add(&quot;publicobject.com&quot;, &quot;sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=&quot;)\n            .build())\n        .build();\n  }\n\n  public void run() throws Exception {\n    Request request = new Request.Builder()\n        .url(&quot;https://publicobject.com/robots.txt&quot;)\n        .build();\n\nResponse response = client.newCall(request).execute();\nif (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);\n\nfor (Certificate certificate : response.handshake().peerCertificates()) {\n  System.out.println(CertificatePinner.pin(certificate));\n}\n\n  }\n`\n\n定制信任证书\n\n下面所有的代码展示了如何使用你自己的配置代替服务端的证书配置。正如上述所言，**在没的到服务端团队的许可的时候不要使用定制证书*。\n`Java\n  private final OkHttpClient client;\n\n  public CustomTrust() {\n    SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());\n    client = new OkHttpClient.Builder()\n        .sslSocketFactory(sslContext.getSocketFactory())\n        .build();\n  }\n\n  public void run() throws Exception {\n    Request request = new Request.Builder()\n        .url(&quot;https://publicobject.com/helloworld.txt&quot;)\n        .build();\n\nResponse response = client.newCall(request).execute();\nSystem.out.println(response.body().string());\n\n  }\n\n  private InputStream trustedCertificatesInputStream() {\n    ... // Full source omitted. See sample.\n  }\n\n  public SSLContext sslContextForTrustedCertificates(InputStream in) {\n    ... // Full source omitted. See sample.\n  }\n`","readingtime":5,"url":"/cates/backend/post/2017-03-23/https","dirs":["okhttp"],"relatives":[{"url":"/cates/backend/post/2017-03-19/Recipes","title":"OKHttp Recipes"},{"url":"/cates/backend/post/2017-03-18/calls","title":"OKHttp的调用"},{"url":"/cates/backend/post/2017-03-19/connections","title":"OKHttp connections"},{"url":"/cates/backend/post/2017-03-19/interceptors","title":"OKHttp 拦截器"}]},{"title":"Linux 如何查找Java 程序CPU负载过高","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-250406255.jpg","iso8601Date":"2017-03-25T19:20:26+08:00","basename":"cpu-load-high","tags":["CPU","Java","Linux","Backend"],"date":"2017-03-25","cate":"backend","summary":"准备程序：\n\n`Java\npackage test;\n\npublic class Test{\n    public static void main(String[] args){\n        new Thread(new Runnable(){\n            public void run(){\n                while(true){\n\n            }\n        }\n    }).start();\n}\n\n}\n\n其中一个线程回导致一直占用CPU，编译运行。通过top 获取CPU占用信息\n![top cpu](https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/top.png)\n可以看到占用最高的 pid是 25955\n通过top -p 25955 -H 获取进程内部线程的CPU使用率。\n![topph](https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/tophp.png)\n可以发现占用最高的线程ID是 25965 将其转换为16进制python -c &#39;print hex(25965)&#39; 得到的值是0x656d \n使用 jstack -l 25955 &gt; jstack.log 得到Java进程的Thread dump，通过 grep -i 0x656d -A 30 jstack.log` 获取Java Thread id为0x656d的线程的thread dump。\n\n然后就可以定位相应代码查找代码占用CPU过高问题。","readingtime":2,"url":"/cates/backend/post/2017-03-25/cpu-load-high","dirs":["java"],"relatives":[{"url":"/cates/backend/post/2018-04-06/java8-date-time-api","title":"Java8 Date Time API"}]},{"title":"MyBatis 配置","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-248219739.jpg","iso8601Date":"2017-06-28T22:13:32+08:00","basename":"mybaits-configuration","tags":["Java","Mybatis","Translate","Backend"],"date":"2017-06-28","cate":"backend","summary":"原文链接\n\nMyBatis的配置包含了设置和属性，他们对MyBatis的行为有很大的影响。MyBatis的配置文件层次结构如下：\n configuration\n     properties\n     settings\n     typeAliases\n     typeHandlers\n     objectFactory\n     plugins\n     environments\n         environment\n             transactionManager\n             dataSource\n     databaseIdProvider\n    * mappers\n\nproperties\n\n可以通过一个典型的Java Properties 类实例配置可替换的外部属性，也可以通过子元素传递这些配置属性，例如\nxml\n&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;\n  &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt;\n  &lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&gt;\n&lt;/properties&gt;\n\n然后这些配置属性就可以应用于配置文件中需要动态配置的其他属性。例如：\nxml\n&lt;dataSource type=&quot;POOLED&quot;&gt;\n  &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;\n  &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;\n  &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;\n  &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;\n&lt;/dataSource&gt;\n\n在这个例子中的username和password将会被properties的配置属性替换。driver和url属性会被config.properties的配置替换。这个为配置提供了很多的选项。  Properties同样可以直传入SqlSessionFactoryBuild.build() 方法中，例如：\n`Java\nSqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props);\n\n// ... or ...\n\nSqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props);\n`\n如果同一个属性同时配置到不同的位置，MyBatis按照如下的顺序加载它们：  1. 在Properties内的子元素首先被加载。   2. 其次从resource classpath和url中加载属性并覆盖已存在的属性。  3. 作为方法参数的属性最后被加载，并且覆盖前面两次相同的属性。\n\n因此，优先级最高的是直接作为参数传入方法，其次是从resource classpath或者url加载的配置文件，最后是Properties中的子元素定义的属性。  MyBatis 3.4.2 之后可以如下使用默认占位符。\nxml\n&lt;dataSource type=&quot;POOLED&quot;&gt;\n  &lt;!-- ... --&gt;\n  &lt;property name=&quot;username&quot; value=&quot;${username:ut_user}&quot;/&gt; &lt;!-- If &#39;username&#39; property not present, username become &#39;ut_user&#39; --&gt;\n&lt;/dataSource&gt;\n\n这个功能默认是无效的，如果要开启这个功能，需要在配置属性中如下开启：\nxml\n&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;\n  &lt;!-- ... --&gt;\n  &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value=&quot;true&quot;/&gt; &lt;!-- Enable this feature --&gt;\n&lt;/properties&gt;\n\n注意：如果已经使用了“：”作为属性的键例如：db:username，或者是在sql的定义中使用了OGNL的三元符，例如：${tableName != null ? tableName : &#39;global_constants&#39;}那么就需要修改默认的分隔符，如下：\nxml\n&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;\n  &lt;!-- ... --&gt;\n  &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.default-value-separator&quot; value=&quot;?:&quot;/&gt; &lt;!-- Change default value of separator --&gt;\n&lt;/properties&gt;\n\nxml\n&lt;dataSource type=&quot;POOLED&quot;&gt;\n  &lt;!-- ... --&gt;\n  &lt;property name=&quot;username&quot; value=&quot;${db:username?:ut_user}&quot;/&gt;\n&lt;/dataSource&gt;\n","readingtime":4,"url":"/cates/backend/post/2017-06-28/mybaits-configuration","dirs":["mybatis"],"relatives":[{"url":"/cates/backend/post/2017-03-21/mybatis-started","title":"mybatis 入门"}]},{"title":"Jackson 简明教程","cover":"http://p6jqy6mfr.bkt.clouddn.com/0_ZclbzbQKdYKcf4Lv.jpg","iso8601Date":"2018-03-31T08:39:10+08:00","basename":"jackson-tutorial","tags":["JSON","Java","Jackson","Translate","Backend"],"date":"2018-03-31","cate":"backend","summary":"原文地址  \n\n一分钟教程：POJOs和JSON的互相转换\n\n最常用的功能就是将一段JSON片段组装成POJOs。所以我们首先从这个入手。下面是一个简单的，有两个属性的POJO：  \n\nJava\n// Note: can use getters/setters as well; here we just use public fields directly:\npublic class MyValue {\n  public String name;\n  public int age;\n  // NOTE: if using getters/setters, can keep fields `protected` or `private`\n}\n\n\n我们需要一个com.fasterxml.jackson.databind.ObjectMapper的实例来做所有的数据绑定，ObjectMapper仅需要创建一次即可。  \n\nJava\nObjectMapper mapper = new ObjectMapper(); // create once, reuse\n\n采用默认构造函数目前基本够用，当需要处理特殊情况的时候再学习如何根据情况配置ObjectMapper。以下是使用ObjectMapper的示例：  \n\nJava\nMyValue value = mapper.readValue(new File(&quot;data.json&quot;), MyValue.class);\n// or:\nvalue = mapper.readValue(new URL(&quot;http://some.com/api/entry.json&quot;), MyValue.class);\n// or:\nvalue = mapper.readValue(&quot;{\\&quot;name\\&quot;:\\&quot;Bob\\&quot;, \\&quot;age\\&quot;:13}&quot;, MyValue.class);\n\n如果想要生成JSON，只需要反过来就行：\n\nJava\nmapper.writeValue(new File(&quot;result.json&quot;), myResultObject);\n// or:\nbyte[] jsonBytes = mapper.writeValueAsBytes(myResultObject);\n// or:\nString jsonString = mapper.writeValueAsString(myResultObject);\n\n\n三分钟教程：泛型集合和树模型\n\n除了处理Bean风格的POJO，Jackson同时可以处理JDK的List和Map:`Java\nMap&lt;String, Integer&gt; scoreByName = mapper.readValue(jsonSource, Map.class);\nList&lt;String&gt; names = mapper.readValue(jsonSource, List.class);\n\n// and can obviously write out as well\nmapper.writeValue(new File(&quot;names.json&quot;), names);\n\n匹配这种，只要JSON的结构匹配，并且类型简单就可以。如果有POJO值，则需要声明他的实际类型(PS:POJO的属性如果是List`等类型，则不需要指定类型)  \n\nJava\nMap&lt;String, ResultValue&gt; results = mapper.readValue(jsonSource,\n   new TypeReference&lt;Map&lt;String, ResultValue&gt;&gt;() { } );\n// why extra work? Java Type Erasure will prevent type detection otherwise })\n\n然而，处理Map,List和其他&#39;简单&#39;类型(String,Number,Boolean)可以更见简单，对象遍历非常麻烦，所以Jackson的Tree Model迟早有用。  \n\n`Java\n// can be read as generic JsonNode, if it can be Object or Array; or,\n// if known to be Object, as ObjectNode, if array, ArrayNode etc:\nObjectNode root = mapper.readTree(&quot;stuff.json&quot;);\nString name = root.get(&quot;name&quot;).asText();\nint age = root.get(&quot;age&quot;).asInt();\n\n// can modify as well: this adds child Object as property &#39;other&#39;, set property &#39;type&#39;\nroot.with(&quot;other&quot;).put(&quot;type&quot;, &quot;student&quot;);\nString json = mapper.writeValueAsString(root);\n\n// with above, we end up with something like as &#39;json&#39; String:\n// {\n//   &quot;name&quot; : &quot;Bob&quot;, &quot;age&quot; : 13,\n//   &quot;other&quot; : {\n//      &quot;type&quot; : &quot;student&quot;\n//   }\n// }\n`\n树模型比data-bind更加的方便，尤其是高度动态的数据结构，或者JSON无法完美映射Java类的时候。\n\n五分钟教程：Streaming parser, generator\n\n有一种更见标准的处理模型，叫做incremental model，也叫Stream model ，这种处理方法和data-bind方式同样方便，和Tree Model同样灵活。data-bind和Tree Model 底层都是基于它。但是同样也暴露给那些想要极致性能和完全掌控解析JSON的用户。\n\n`Java\nJsonFactory f = mapper.getFactory(); // may alternatively construct directly too\n\n// First: write simple JSON output\nFile jsonFile = new File(&quot;test.json&quot;);\nJsonGenerator g = f.createGenerator(jsonFile);\n// write JSON: { &quot;message&quot; : &quot;Hello world!&quot; }\ng.writeStartObject();\ng.writeStringField(&quot;message&quot;, &quot;Hello world!&quot;);\ng.writeEndObject();\ng.close();\n\n// Second: read file back\nJsonParser p = f.createParser(jsonFile);\n\nJsonToken t = p.nextToken(); // Should be JsonToken.STARTOBJECT\nt = p.nextToken(); // JsonToken.FIELDNAME\nif ((t != JsonToken.FIELDNAME) || !&quot;message&quot;.equals(p.getCurrentName())) {\n   // handle error\n}\nt = p.nextToken();\nif (t != JsonToken.VALUESTRING) {\n   // similarly\n}\nString msg = p.getText();\nSystem.out.printf(&quot;My message to you is: %s!\\n&quot;, msg);\np.close(); }\n`\n\n10分钟教程：配置\n\n有两种入门的配置方法：feature 和 Annotation\n\nfeature 配置\n\n下面是一些最常用的配置\n首先从高层的data-bind配置开始：\n\n`Java\n// SerializationFeature for changing how JSON is written\n\n// to enable standard indentation (&quot;pretty-printing&quot;):\nmapper.enable(SerializationFeature.INDENTOUTPUT);\n// to allow serialization of &quot;empty&quot; POJOs (no properties to serialize)\n// (without this setting, an exception is thrown in those cases)\nmapper.disable(SerializationFeature.FAILONEMPTYBEANS);\n// to write java.util.Date, Calendar as number (timestamp):\nmapper.disable(SerializationFeature.WRITEDATESAS_TIMESTAMPS);\n\n// DeserializationFeature for changing how JSON is read as POJOs:\n\n// to prevent exception when encountering unknown property:\nmapper.disable(DeserializationFeature.FAILONUNKNOWNPROPERTIES);\n// to allow coercion of JSON empty String (&quot;&quot;) to null Object value:\nmapper.enable(DeserializationFeature.ACCEPTEMPTYSTRINGASNULLOBJECT);\n`\n下面是一些可以控制JSON底层解析，生成的配置：\n\n`Java\n// JsonParser.Feature for configuring parsing settings:\n\n// to allow C/C++ style comments in JSON (non-standard, disabled by default)\n// (note: with Jackson 2.5, there is also mapper.enable(feature) / mapper.disable(feature))\nmapper.configure(JsonParser.Feature.ALLOWCOMMENTS, true);\n// to allow (non-standard) unquoted field names in JSON:\nmapper.configure(JsonParser.Feature.ALLOWUNQUOTEDFIELDNAMES, true);\n// to allow use of apostrophes (single quotes), non standard\nmapper.configure(JsonParser.Feature.ALLOWSINGLEQUOTES, true);\n\n// JsonGenerator.Feature for configuring low-level JSON generation:\n\n// to force escaping of non-ASCII characters:\nmapper.configure(JsonGenerator.Feature.ESCAPENONASCII, true);\n`\n\n注解配置：修改属性名\n\n最简单的使用注解配置的方式是使用@JsonProperty:  \n\n`Java\npublic class MyBean {\n   private String _name;\n\n   // without annotation, we&#39;d get &quot;theName&quot;, but we want &quot;name&quot;:\n   @JsonProperty(&quot;name&quot;)\n   public String getTheName() { return _name; }\n\n   // note: it is enough to add annotation on just getter OR setter;\n   // so we can omit it here\n   public void setTheName(String n) { _name = n; }\n} \n`\n\n注解配置：忽略属性\n\n有两个可以设置忽略属性的注解，一个是@JsonIgnore 修饰的是单个属性，一个是@JsonIgnoreProperties 修饰的类。\n\n`Java\n// means that if we see &quot;foo&quot; or &quot;bar&quot; in JSON, they will be quietly skipped\n// regardless of whether POJO has such properties\n@JsonIgnoreProperties({ &quot;foo&quot;, &quot;bar&quot; })\npublic class MyBean\n{\n   // will not be written as JSON; nor assigned from JSON:\n   @JsonIgnore\n   public String internal;\n\n   // no annotation, public field is read/written normally\n   public String external;\n\n   @JsonIgnore\n   public void setCode(int c) { _code = c; }\n\n   // note: will also be ignored because setter has annotation!\n   public int getCode() { return _code; }\n} \n\n由于重命名，所以注解是在匹配的的字段，get，set中共享的：如果其中一个设置了@JsonIgnore`，其他的也受影响。当然也可以使用分离的注解来解决问题：\n\nJava\npublic class ReadButDontWriteProps {\n   private String _name;\n   @JsonProperty public void setName(String n) { _name = n; }\n   @JsonIgnore public String getName() { return _name; }\n} \n\n在这个例子中，name不会被写入到JSON中，但是如果JSON中有，则会映射到Java对象中。\n\n注解配置：定制注解构造器\n\n和其他的data-bind包不同，jackson 不需要定义默认的构造函数（即不包含参数的构造函数）。如果需要，可以定义一个简单的包含参数的构造函数:  \n\n`Java\npublic class CtorBean\n{\n  public final String name;\n  public final int age;\n\n  @JsonCreator // constructor can be public, private, whatever\n  private CtorBean(@JsonProperty(&quot;name&quot;) String name,\n    @JsonProperty(&quot;age&quot;) int age)\n  {\n      this.name = name;\n      this.age = age;\n  }\n}\n`\n构造函数在不可变对象中非常实用。也可以直接定义一个工厂方法：\n\n`Java\npublic class FactoryBean\n{\n    // fields etc omitted for brewity\n\n@JsonCreator\npublic static FactoryBean create(@JsonProperty(&quot;name&quot;) String name) {\n  // construct and return an instance\n}\n\n}\n`\n\n其他特性：\n\n一个有用，但是不被广泛知晓的功能就是Jackson可以任意转换两个POJO。可以将其想象成两步，第一步，将POJO写成JSON，第二步讲JSON写成另一个POJO。实现的时候用了更加高效的一种方法，并没有生成中间的JSON。\n转换在兼容的类型中运行的很好：\n\nJava\nResultType result = mapper.convertValue(sourceObject, ResultType.class);\n\n只要这两个POJO的类型兼容，即to json 和 from json的成功，那么就可以成功：\n\nJava\n// Convert from List&lt;Integer&gt; to int[]\nList&lt;Integer&gt; sourceList = ...;\nint[] ints = mapper.convertValue(sourceList, int[].class);\n// Convert a POJO into Map!\nMap&lt;String,Object&gt; propertyMap = mapper.convertValue(pojoValue, Map.class);\n// ... and back\nPojoType pojo = mapper.convertValue(propertyMap, PojoType.class);\n// decode Base64! (default byte[] representation is base64-encoded String)\nString base64 = &quot;TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz&quot;;\nbyte[] binary = mapper.convertValue(base64, byte[].class);\n\n基本上Jackson可以替换很多Apache Commons的组件，例如Base64的编码解码，处理动态POJO等。","readingtime":14,"url":"/cates/backend/post/2018-03-31/jackson-tutorial","dirs":["jackson"],"relatives":[]},{"title":"Java8 Date Time API","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-189436803.jpg","iso8601Date":"2018-04-06T08:39:10+08:00","basename":"java8-date-time-api","tags":["Backend","Java","Java8","Translate"],"date":"2018-04-06","cate":"backend","summary":"原文地址  \n\n简介\n\nJava8 带来了处理日期和时间需要的方式。几乎所有人都有使用Java Date 痛苦的经历。有很多人因此切换到了Joda Time，但是Java8现在有了更清晰，更可扩展的API。在我们学习API钱，先了解一下日期和时间的概念。Java日期遵循公历规则。表示时间和日期的类放在java.time包中。在这个包里比较重要的API有：  -  java.time.Period: 表示日期时期时间中的日期。表示日期部分的，年、月、日。例如：1年，两个月，5天。\n  -  java.time.Duration: 表示日期时间中的时间。 表示时间的，秒，纳秒。例如：5秒。\n  -  java.time.Instant: 表示时间线的一瞬间。保存的是UNIX时间戳的秒数，同时有另一个字段保存纳秒。\n  -  java.time.LocalDate: 保存日期时间中的日期，用年-月-日表示。不包含时区，是不可变类。\n  -  java.time.LocalTime: 保存日期时间中的时间，不包含时区。\n  -  java.time.LocalDateTime: 保存LocalDate和LocalTime，不包含时区。\n  -  java.time.ZoneDateTime: 保存LocalDateTIme，使用ZoneOffset保存时区信息。可以访问ZoneRule来转换本地时间。\n  -  java.time.ZoneOffset: 保存时区相对于UTC的位移，时区信息保存在ZoneId中。\n  -  java.time.OffsetDateTime: 通过位移来表示本地时间。这个类不包含时区规则。    \n\n创建本地日期\n\nJava\nInstant now = Instant.now();\n//2014-09-20T14:32:33.646Z\n\n\n这个语句创建了一个新的时间实例。这个实例没有时区信息，如果打印这个实例将会打印UTC时间。  \n\n打印Unix时间戳\n\nJava\nSystem.out.Println(now.getEpochSecond());\n// prints 1411137153\n\nUnix时间戳是从1970-01-01T00:00:00Z开始的。\n\nInstant 加时间\n\nJava\nInstant tomorrow = now.plus(1, ChronoUnit.DAYS);\n// prints 2014-09-20T14:32:33.646Z\n\n这个函数允许添加时间间隔。时间间隔可以是：NANOS, MICROS, MILLIS, SECONDS, MINUTES, HOURS, HALF_DAYS, DAYS。\n\nInstant 减时间\n\nJava\nInstant yesterday = now.minus(1,ChronoUnit.HALF_DAYS);\n// prints 2014-09-20T03:38:33.860Z\n\n这个minus函数允许从Instant中减时间，时间间隔同plus。\n\n对比两个Instant\n\nJava\nSystem.out.println(now.compareTo(tomorrow)); // prints -1\n\n对比函数可以比较两个日期，如果参数在比较的Instant之后则返回-1，之前则返回1。\n\n检查Instant是否在另一个Instant之后\n\nJava\nSystem.out.println(now.isAfter(yesterday));// prints true\n\n\n创建LocalDateTime\n\nJava\nLocalDateTime localDateTime = LocalDateTime.now();\nSystem.out.println(localDateTime); // prints 2014-09-28T13:01:40.556\n\n注意，这个得到的是本地时区的时间\n\n将LocalDateTime转换成其他时区时间\n\nJava\nSystem.out.println(localDateTime.atZone(ZoneId.of(&quot;America/New_York&quot;)));\n// prints 2014-09-28T13:07:31.207-04:00[America/New_York]\n\n这个将会创建一个新的ZonedDateTime\n\n从DateTime中获取星期\n\nJava\nSystem.out.println(DayOfWeek.from(localDateTime));\n// prints SUNDAY.\n// (yes, i am working on a sunday :-( ) ))\n\n\n从DateTime中获取一年中第几天\n\nJava\nSystem.out.println(localDateTime.get(ChronoField.DAY_OF_YEAR));\n// prints 271\n\n其他的可以是MINUTEOFHOUR, MINUTEOFDAY, HOUROFAMPM, HOUROFDAY, AMPMOFDAY, DAYOFWEEK, DAYOFMONTH, DAYOFYEAR, MONTHOFYEAR, YEAR, OFFSET_SECONDS（UTC时间的位移）\n\n从LocalDateTime中获取LocalDate\n\nJava\nSystem.out.println(localDateTime.toLocalDate());\n// prints 2014-09-29\n\n\n从LocalDateTIme中获取LocalTime\n\nJava\nSystem.out.println(localDateTime.toLocalTime());\n// prints 22:26:30.146\n\n\n通过年月日时分创建LocalDateTime\n\nJava\nSystem.out.println(LocalDateTime.of(2014, 10, 1, 10, 0));\n// prints 2014-10-01T10:00\n\n\n通过解析字符串创建LocalDateTime\n\nJava\nLocalDateTime parsedLocalDateTime = LocalDateTime.parse(&quot;2014-01-01T11:00&quot;);\n\n\n创建另一个时区的LocalDateTime\n\nJava\nSystem.out.println(LocalDateTime.now(ZoneId.of(&quot;UTC&quot;)));\n// prints 2014-09-29T17:07:26.653 (the local timezone in UTC)\n\n\n通过Instant和时区创建LocalDateTime\n\nJava\nInstant now = Instant.now();\nSystem.out.println(LocalDateTime.ofInstant(now, ZoneId.of(&quot;UTC&quot;)));\n//2014-09-29T17:09:19.644\n\n\n创建ZonedDateTime\n\nJava\nZonedDateTime zonedDateTime = ZonedDateTime.now();\n//2014-09-29T22:41:24.908+05:30[Asia/Calcutta]\n\n\n获取两个不同时间在不同单位之差\n\n\nSystem.out.println(zonedDateTime.until(ZonedDateTime.parse(&quot;2014-09-29T22:41:00-10:00&quot;), ChronoUnit.HOURS));\n// prints the difference between the current zonedDateTime and the zonedatetime parsed from the above string\n\n\n获取当前ZoneDateTime的位移\n\nJava\nSystem.out.println(zonedDateTime.getOffset());\n// prints the offset e.g. +10:00\n\n\n使用DateTimeFormatter解析或者格式化时间\n\nJava\nSystem.out.println(zonedDateTime.format(DateTimeFormatter.ofPattern(&quot;&#39;The&#39; dd &#39;day of&#39; MMM &#39;in year&#39; YYYY &#39;and zone is&#39; z&quot;)));\n// prints The 29 day of Sep in year 2014 and zone is IST\n\n\n将ZoneDateTime更改时区\n\n有两种方式可以完成这个任务，第一种不更改Instant更改时区，第二种更改时区不更改LocalTime\n`Java\n        System.out.println(zonedDateTime);\n        System.out.println(zonedDateTime.toInstant());\n        System.out.println(zonedDateTime.withZoneSameInstant(ZoneId.of(&quot;America/Chicago&quot;)));\n        System.out.println(zonedDateTime.withZoneSameLocal(ZoneId.of(&quot;America/Chicago&quot;)));\n\n    // prints \n    //System.out.println(zonedDateTime);\n    //System.out.println(zonedDateTime.toInstant());\n    //System.out.println(zonedDateTime.withZoneSameInstant(ZoneId.of(&quot;America/Chicago&quot;)));\n    //System.out.println(zonedDateTime.withZoneSameLocal(ZoneId.of(&quot;America/Chicago&quot;)));\n\n`","readingtime":9,"url":"/cates/backend/post/2018-04-06/java8-date-time-api","dirs":["java"],"relatives":[{"url":"/cates/backend/post/2017-03-25/cpu-load-high","title":"Linux 如何查找Java 程序CPU负载过高"}]},{"title":"深入理解Spring MVC","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-249089429.jpg","iso8601Date":"2018-04-07T08:39:10+08:00","basename":"deep-in-spring-mvc","tags":["Backend","Java","Spring","SpringMVC","Web"],"date":"2018-04-07","cate":"backend","summary":"原文地址  \n\n初始工程\n\n这篇文章中将使用最新的Spring Framework 5框架。主要关注的是Spring的经典Web技术栈，这套技术从最开始的Spring版本就开始支持，并且知道现在仍然是构建Spring Web应用的主要方式。使用Spring Boot和其他starter来设置初始工程。xml配置如下：\n`xml\n&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n    &lt;version&gt;2.0.1&lt;/version&gt;\n    &lt;relativePath/&gt;\n&lt;/parent&gt;\n\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n`\n\n测试项目\n\n为了理解Spring Web MVC是如何工作的，可以先实现一个简单的Login功能的。创建一个由@Controller来修饰的类InternalController，这个类包含一个Get的映射。hello()函数没有参数。返回一个由Spring解释的视图名字的字符串。（在本例中是login.html）  \n\n`Java\nimport org.springframework.web.bind.annotation.GetMapping;\n\n@GetMapping(&quot;/&quot;)\npublic String hello() {\n    return &quot;login&quot;;\n}\n`\n\n为了处理用户登陆逻辑，创建另一个接受POST请求的带有Login数据的方法。然后根据处理结果返回成功或者失败页面。\n注意，login()函数接受一个领域对象作为参数，返回的是ModelAndView对象。  \n\nJava\n@PostMapping(&quot;/login&quot;)\npublic ModelAndView login(LoginData loginData) {\n    if (LOGIN.equals(loginData.getLogin()) \n      &amp;&amp; PASSWORD.equals(loginData.getPassword())) {\n        return new ModelAndView(&quot;success&quot;, \n          Collections.singletonMap(&quot;login&quot;, loginData.getLogin()));\n    } else {\n        return new ModelAndView(&quot;failure&quot;, \n          Collections.singletonMap(&quot;login&quot;, loginData.getLogin()));\n    }\n}\n\n\nModelAndView保存了两个不同的对象：\n  - Model： 用来渲染页面用的键值对的map\n  - View： 填充Model数据的模版页面。  \n\n将它们合并起来是为了方便，这样controller的方法就可以同时返回这两个了。\n使用Thymeleaf作为模版引擎来渲染页面。  \n\nJava Web应用的基础-Servlet\n\n当你在浏览器里键入http://localhost:8080/ ，然后按回车键，请求到达服务器的时候到底发生了什么？是如何在浏览器中看到这个web请求的数据的？\n因为这个项目是一个简单的Spring Boot应用，所以可以通过Spring5Application来运行。\nSpring Boot默认使用Apache Tomcat运行程序，运行成功后可能会看到如下的日志：\n\n`bash\n2017-10-16 20:36:11.626  INFO 57414 --- [main] \n  o.s.b.w.embedded.tomcat.TomcatWebServer  : \n  Tomcat initialized with port(s): 8080 (http)\n\n2017-10-16 20:36:11.634  INFO 57414 --- [main] \n  o.apache.catalina.core.StandardService   : \n  Starting service [Tomcat]\n\n2017-10-16 20:36:11.635  INFO 57414 --- [main] \n  org.apache.catalina.core.StandardEngine  : \n  Starting Servlet Engine: Apache Tomcat/8.5.23\n`\n\n因为Tomcat是一个Servlet容器，所以几乎所有的HTTP请求都是由Java Servlet处理的。自然的Spring Web的入口就是一个Servlet。\nServlet是所有Java Web应用的核心组件；它非常的低成，并且没有暴露任何具体的编程模式，例如MVC。\n一个HTTP的Servelt只能接受HTTP请求，处理请求后返回响应。\n现在使用Servlet 3.0的API，可以不再使用XML配置，直接可以使用Java配置。\n\nSpring MVC的核心-DispatcherServlet\n\n作为Web开发者，我们希望抽象出以下枯燥和样板的任务，而关注于有用的业务逻辑  - 将HTTP请求映射到响应处理函数\n  - 将HTTP请求数据和header解析成数据传输对象（DTOs）或者领域对象\n  - model-view-controller 互相交互\n  - 从DTO，领域对象等生成响应  \n\nSpring的DispatcherServlet提供了以上的功能，是Spring WEB MVC框架的核心，是应用接受所有请求的核心组件。\n稍后就会了解到DispatcherServlet可扩展性非常强。例如：它允许你加入现有或者新的适配器来适应不同的任务：\n  - 将请求映射到处理它的类或者函数(由HandlerMapping实现）\n  - 使用特定模式来处理请求，例如一个普通的Servlet，一个复杂的MVC 工作流，或者只是一个方法。(由HandlerAdapter实现）\n  - 通过名字解析试图对象，允许你使用不同的模版引擎，例如：XML，XSLT或者其他视图技术(由ViewResolver实现）\n  - 默认使用Apache Comons 的文件上传组件解析文件上传，或者也可以自己实现。\n  - 由LocalResolver实现本地化，包括cookie，session，HTTP的Accept Header，或者其他由用户定义的本地化。    \n\n处理HTTP请求\n\n首先让我们重新审视一下在刚刚建立的应用中是如何处理HTTP请求的。\nDispatcherServlet有一个很长的继承层级。自顶向下理解每个单独的概念是非常有必要的。处理请求的函数将会更加有趣。\n\n理解HTTP请求在本地开发模式处理和远程处理是理解MVC架构非常重要的一步。\n\nGenericServlet\n\nGenericServlet时Servlet规范中的一部分，不直接处理HTTP。它定义了service()方法，来接受请求和返回响应。\n注意，ServletRequest和ServletResponse并不是绑定到HTTP协议的。\nJava\npublic abstract void service(ServletRequest req, ServletResponse res) \n  throws ServletException, IOException;\n\n服务器所有的请求，包括简单的GET请求都会调用这个方法。\n\nHttpServlet\n\n正如其名，HttpServelt是Servlet 规范中关于HTTP请求的实现。\n更确切的说，HttpServlet是一个实现了service()的抽象类。通过将不同的HTTP请求类型分开，由不同的函数处理，实现大约如下所示：\n`Java\nprotected void service(HttpServletRequest req, HttpServletResponse resp)\n    throws ServletException, IOException {\n\nString method = req.getMethod();\nif (method.equals(METHOD_GET)) {\n    // ...\n    doGet(req, resp);\n} else if (method.equals(METHOD_HEAD)) {\n    // ...\n    doHead(req, resp);\n} else if (method.equals(METHOD_POST)) {\n    doPost(req, resp);\n    // ...\n}\n\n`\n\nHttpServletBean\n\n在这个继承关系中HttpServletBean是第一个Spring的类。从web.xml或者WebApplicationInitialzer获取的初始参数来注入bean。\n在应用中的请求分别调用doGet,doPost等方法来处理不同的HTTP请求。\n\nFrameworkServlet\n\nFrameworkServlet实现了ApplicationContextAware,集成Web的Application Context。不过它也可以创建自己的Application Context。\n正如上述所言，父类HttpServletBean通过将初始参数作为bean的属性注入。因此如果contex的类名在contextClass这个初始参数中，那么就有这个参数创建application context的实例，否则默认使用XmlWebApplicationContext。\n由于XML配置现在已经过时了。Spring Boot默认使用AnnotationConfigWebApplicationContext来配置DispatcherServlet。不过这个是很容易修改的。\n例如，想要在Spring MVC中使用Groovy的application context，可以将下列配置在web.xml中\nbash\n  dispatcherServlet\n        org.springframework.web.servlet.DispatcherServlet\n        contextClass\n        org.springframework.web.context.support.GroovyWebApplicationContext\n\n相同的配置也可以在WebApplicationInitializer中配置。\n\nDispatcherServlet: 统一处理请求\n\nHttpServlet.service() 通过HTTP的动词类型来处理路由不同的请求到不同的方法，这个在底层的servlet实现的很好。但是，在SpringMVC的抽象层次中，不能仅靠方法类型来路由请求。\n同样的，FrameworkServlet的另一个主要功能就是将不同的处理使用processRequest()组合在一起。\n`Java\n@Override\nprotected final void doGet(HttpServletRequest request, \n  HttpServletResponse response) throws ServletException, IOException {\n    processRequest(request, response);\n}\n\n@Override\nprotected final void doPost(HttpServletRequest request, \n  HttpServletResponse response) throws ServletException, IOException {\n    processRequest(request, response);\n}\n`\n\nDispatcherServlet: 丰富请求\n\n最后,DispatcherServlet实现doService() 方法。它向请求中加入了一些有用的对象，继续在web 的管道中传递下去，例如：web application context, locale resolver, theme resolver, theme source等\nJava\nrequest.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, \n  getWebApplicationContext());\nrequest.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\nrequest.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\nrequest.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());\n\n同时，doService()加入了输入输出的Flash Map，Flash Map是将参数从一个请求传递到另一个请求的基本模式。在重定向中很有用。(例如在重定向之后向用户展示一段简单的信息）\nJava\nFlashMap inputFlashMap = this.flashMapManager\n  .retrieveAndUpdate(request, response);\nif (inputFlashMap != null) {\n    request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, \n      Collections.unmodifiableMap(inputFlashMap));\n}\nrequest.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());\n\n接着doService() 将会调用doDispatch()方法来分发请求。\n\nDispatcherServlet: 分发请求\n\ndispatch() 的主要目的就是知道一个合适的处理请求的处理器并且传递request/response参数。处理器可以是任何对象，并不局限于一个特定的接口。同样也意味着Spring需要找到如何使用这个处理器的适配器。\n为了给请求找到合适的处理器，Spring会遍历实现HandlerMapping接口的注册的实现。有很多不同的实现可以满足我们各种需求。\nSimpleUrlHandlerMapping使用URL将请求映射到处理bean中。例如：它可以通过Java.util.Properties 注入它的映射信息：\nbash\n/welcome.html=ticketController\n/show.html=ticketController\n\nRequestMappingHandlerMapping可能是最广泛使用的映射处理器。它将请求映射到@Controller类下的@RequestMapping修饰的方法上。这个就是上面那个例子中的hello()和login()。\n注意，上面两个方法分别是@GetMapping和@PostMapping修饰的。这两个注解来源于@RequestMapping。\ndispatch() 同时也可以处理一些其他的HTTP的任务：\n  - 如果资源不存在，对GET请求进行短路处理。\n  - 对相应的请求使用multipart 解析。\n  - 如果处理器选择异步处理请求，对请求进行短路处理。  \n\n处理请求\n\n现在Spring确定了处理请求的处理器和处理器的适配器，是时候处理请求了。下面是HandlerAdapter.handle() 的签名。比较重要的一点是处理器可以选择如何处理请求：\n  - 直接将相应写入到response body 和 返回null\n  - 返回一个ModelAndView对象由DispatcherServlet渲染。  \n\nJava\n@Nullable\nModelAndView handle(HttpServletRequest request, \n                    HttpServletResponse response, \n                    Object handler) throws Exception;\n\nSpring提供了很多类型的处理器，下面是SimpleControllerHandlerAdapter如何处理Spring MVC的controller实例的(不要和@Controller搞混)。\n注意，controller处理器返回ModelAndView对象并不是由起渲染的。\nJava\npublic ModelAndView handle(HttpServletRequest request, \n  HttpServletResponse response, Object handler) throws Exception {\n    return ((Controller) handler).handleRequest(request, response);\n}\n\n第二个是SimpleServletHandlerAdapter它对一个普通的servlet适配。\nservlet并不知道ModelAndView，完全自己处理请求，将返回写入到相应的body中。因此它的适配器就直接返回null。\nJava\npublic ModelAndView handle(HttpServletRequest request, \n  HttpServletResponse response, Object handler) throws Exception {\n    ((Servlet) handler).service(request, response);\n    return null;\n}\n\n在本例中，controller是由@RequestMapping修饰的POJO，因此处理器会使用HandlerMethod来封装它的方法。Spring使用RequestMappingHandlerAdapter来适配这种处理器类型。\n\n处理参数，返回处理器函数的值\n\n注意，一般来说controller并不会接收HttpServletRequest和HttpServletResponse作为参数，但是它可以接收和返回很多中其他类型，例如：领域对象，路径参数等。\n同样，也不强求一个controller返回一个ModelAndView实例。可以选择返回一个视图名称，ResponseEntity，或者是一个可以被转换成JSON的POJO。\nRequestMappingHandlerAdapter可以保证从HttpServletRequest中解析方法需要的参数，同时创建ModelAndView对象返回。\n下面这段代码就是RequestMappingHandlerAdapter中保证这件事情的：\nJava\nServletInvocableHandlerMethod invocableMethod \n  = createInvocableHandlerMethod(handlerMethod);\nif (this.argumentResolvers != null) {\n    invocableMethod.setHandlerMethodArgumentResolvers(\n      this.argumentResolvers);\n}\nif (this.returnValueHandlers != null) {\n    invocableMethod.setHandlerMethodReturnValueHandlers(\n      this.returnValueHandlers);\n}\n\nargumentResolvers在HandlerMethodArgumentResolver实例中有不同实现。一共有30多种不同的参数解析器的实现。他们可以从请求参数将函数需要的参数解析出来。包括：url路径变量，请求体参数，请求头，cookies，session等。\nreturnValueHandlers在HandlerMethodArgumentResolver实例中有不同实现。同样也有很多不同的返回值处理器来处理方法返回的结果，创建ModelAndView对象。\n例如：当函数hello()返回一个string的时候，ViewNameMethodReturnValueHandler处理这个值。login()返回一个ModelAndView对象的时候，Sring使用ModelAndViewMethodReturnValueHandler处理这个值。\n\n渲染视图\n\n现在Spring已经处理了HTTP请求，获取了ModelAndView实例，现在它需要在用户浏览器渲染HTML页面了。它依赖于由Model和选择的模版组成的ModelAndView对象。\n同样的，Spring也可以渲染JSON ,XML或者其他HTTP协议接受的类型。这些将在接下来的REST相关了解更多。\n现在回去看一下DispatcherServlet。 render() 首先使用LocaleResolver实例设置返回的Local。首先假设浏览器已经正确设置Accetp头。默认使用AcceptHeaderLocaleResolver来处理。\n在渲染过程中，ModelAndView可以包含一个视图的名字或者是已经选择的视图，或者如果controller依赖于默认视图也可以没有。\n既然hello()和login()方法制定了字符串名字作为视图名称，所以需要使用viewResolvers来查找视图。\nJava\nfor (ViewResolver viewResolver : this.viewResolvers) {\n    View view = viewResolver.resolveViewName(viewName, locale);\n    if (view != null) {\n        return view;\n    }\n}\n\nViewResolver的实现由很多，这里使用了由thymeleaf-spring5提供的ThymeleafViewResolver实现。解析器知道去哪里查找视图，并且提供相应的视图实例。\n调用完render()之后，Spring就完成了将HTML页面渲染到用户浏览器的任务。\n\nREST 支持\n\n除了MVC的场景，我们可以使用狂减创建rest web service。\n一个简单的场景，可以使用由@RequestBody修饰的POJO作为参数。由@ResponseBody修饰方法，指定方法的返回结果直接写入到响应体中。  \n\n`Java\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@ResponseBody\n@PostMapping(&quot;/message&quot;)\npublic MyOutputResource sendMessage(\n  @RequestBody MyInputResource inputResource) {\n\nreturn new MyOutputResource(&quot;Received: &quot;\n  + inputResource.getRequestMessage());\n\n}\n`\n\n感谢SpringMVC的扩展性，这样做也是可以的。\n框架使用HttpMessageConverter将内部DTO转换成REST的表示。例如：MappingJackson2HttpMessageConverter的可以使用Jackson库将转换model和JSON。\n为了简化创建REST API，Srping 引入了@RestController注解。默认使用@ResonseBody这样就不需要在每个方法中使用了。\n`Java\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class RestfulWebServiceController {\n\n@GetMapping(&quot;/message&quot;)\npublic MyOutputResource getMessage() {\n    return new MyOutputResource(&quot;Hello!&quot;);\n}\n\n}\n`\n\n结论\n\n在这篇文章中，详细描述了Spring MVC处理HTTP请求的各个步骤。了解到Spring 框架是如何将各个组件组合在一起提供处理HTTP协议的。","readingtime":17,"url":"/cates/backend/post/2018-04-07/deep-in-spring-mvc","dirs":["spring-mvc"],"relatives":[{"url":"/cates/backend/post/2018-04-10/spring-mvc-controller","title":"SpringMVC 教程 - Controller"},{"url":"/cates/backend/post/2018-04-09/spring-mvc-dispatcher-servlet","title":"SpringMVC 教程 - DispatcherServlet"},{"url":"/cates/backend/post/2018-04-09/spring-mvc-filter","title":"SpringMVC 教程 - Filter"}]},{"title":"SpringMVC 教程 - DispatcherServlet","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-239935763.jpg","iso8601Date":"2018-04-09T08:39:10+08:00","basename":"spring-mvc-dispatcher-servlet","tags":["Backend","Java","SpringMVC","Spring"],"date":"2018-04-09","cate":"backend","summary":"简介\n\n同许多其他的web框架一样，SpringMVC使用了前端控制器的设计模式，即一个以DispatcherServlet为核心的Servlet为处理请求提供了一个共享的算法，而实际的工作是由可配置的委托组件执行的。这个模式即灵活又支持多样的工作流。\n同其他的Servlet,依照Servlet 规范DispatcherServlet需要在web.xml或者Java配置中声明并映射URL。接着DispatcherServlet使用Spring的配置来查找委托组件，用来映射URL，解析视图，异常处理等。\n下面这个示例是使用Java配置来注册并初始化DispatcherServlet，这个类由Servlet容器自动发现。\n`Java\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n\n@Override\npublic void onStartup(ServletContext servletCxt) {\n\n    // Load Spring web application configuration\n    AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();\n    ac.register(AppConfig.class);\n    ac.refresh();\n\n    // Create and register the DispatcherServlet\n    DispatcherServlet servlet = new DispatcherServlet(ac);\n    ServletRegistration.Dynamic registration = servletCxt.addServlet(&quot;app&quot;, servlet);\n    registration.setLoadOnStartup(1);\n    registration.addMapping(&quot;/app/*&quot;);\n}\n\n}\n`\n\n下面这个示例是使用web.xml来注册并初始化的\n`xml\n&lt;web-app&gt;\n\n&lt;listener&gt;\n    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;\n&lt;/listener&gt;\n\n&lt;context-param&gt;\n    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n    &lt;param-value&gt;/WEB-INF/app-context.xml&lt;/param-value&gt;\n&lt;/context-param&gt;\n\n&lt;servlet&gt;\n    &lt;servlet-name&gt;app&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n&lt;/servlet&gt;\n\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;app&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n\n&lt;/web-app&gt;\n`\n\n层次结构\n\nDispatcherServlet需要一个扩展了的ApplicationContext的WebApplicationContext来配置自己的信息。WebApplicationContext包含了Servlet的ServletContext的引用，可以使用RequestContextUtils中的静态方法从WebApplicationContext中查找ServletContext。\n对于大多数应用来说一个WebApplicationContext就足够了。当然WebApplicatioContext也可以是有层次结构的，例如由多个Servlet共享的一个根WebApplicationContext，每个Servlet又有自己的子WebApplicationContext。\n根WebApplicationContext一般包括需要在多个Servlet中共享的基础bean，例如数据仓库，业务逻辑等。在Servlet规范中，这些bean可以被有效的继承和改写，子WebApplicationContext仅包含在其属于的Servlet中。\n\n下面这个例子就是WebApplicationContext的层级配置\n`Java\npublic class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n@Override\nprotected Class&lt;?&gt;[] getRootConfigClasses() {\n    return new Class&lt;?&gt;[] { RootConfig.class };\n}\n\n@Override\nprotected Class&lt;?&gt;[] getServletConfigClasses() {\n    return new Class&lt;?&gt;[] { App1Config.class };\n}\n\n@Override\nprotected String[] getServletMappings() {\n    return new String[] { &quot;/app1/*&quot; };\n}\n\n} \n`\n\n同样的，在web.xml中的配置\n`xml\n&lt;web-app&gt;\n\n&lt;listener&gt;\n    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;\n&lt;/listener&gt;\n\n&lt;context-param&gt;\n    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n    &lt;param-value&gt;/WEB-INF/root-context.xml&lt;/param-value&gt;\n&lt;/context-param&gt;\n\n&lt;servlet&gt;\n    &lt;servlet-name&gt;app1&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;/WEB-INF/app1-context.xml&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n&lt;/servlet&gt;\n\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;app1&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/app1/*&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n\n&lt;/web-app&gt;\n`\n\n特殊的bean类型\n\nDispatcherServlet委托专用的bean来处理请求，渲染响应。专用的bean指的是Spring管理的，实现WebFlux框架约定的实例。这些bean一般都是内建的约定，但是可以定制他们的属性，扩展或者代替这些bean。\n\nbean 类型 | 解释\n:---------- | :---------\nHandlerMapping | 处理器映射，具体由其子类实现。两个重要的子类，RequestMappingHandlerMapping,SimpleUrlHandlerMapping\nHandlerAdapter | 辅助DispatcherServlet执行特定的处理器。\nHandlerExceptionResolver | 将异常重定向到其他处理器或者是显示HTML的错误界面。\nViewResolver | 通过处理器返回的视图字符串查找具体的视图并渲染。 \nLocaleResolver, LocaleContextResolver | 支持国际化页面，使用例如时区等来解析本地化问题。 \nThemeResolver | 解析应用可用的主题，例如提供个性化框架 \nMultipartResolver | 处理上传文件 \nFlashMapManager | 保存和检索输入输出的FlashMap，它可以将属性从一个请求传递到另一个请求的输入输出，一般应用在重定向中。 \n\nWeb MVC 配置\n\n应用可以声明在特殊的bean类型中列出的bean来处理请求。DispatcherServlet会检查每一个bean的WebApplicationContext。如果没有指定的bean，那么就会使用DispatcherServlet.properties中定义的bean。\nMVC配置将会在以后详细的列出。\n\nServlet 配置\n\n在Servlet 3.0+中，可以使用编程的方式来代替web.xml配置。下面这个例子就是通过编程注册DispatcherServlet\n`Java\nimport org.springframework.web.WebApplicationInitializer;\n\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n\n@Override\npublic void onStartup(ServletContext container) {\n    XmlWebApplicationContext appContext = new XmlWebApplicationContext();\n    appContext.setConfigLocation(&quot;/WEB-INF/spring/dispatcher-config.xml&quot;);\n\n    ServletRegistration.Dynamic registration = container.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(appContext));\n    registration.setLoadOnStartup(1);\n    registration.addMapping(&quot;/&quot;);\n}\n\n}\n`\n\nWebApplicationInitializer是由SpringMVC提供的接口，用来保证上述实现可以由支持Servlet 3.0的容器自动检测并初始化。抽象类AbstractDispatcherServletInitializerl实现了WebApplicationInitializer 可以更加容易的注册DispathcerServlet。\n下面是使用Java配置的Spring\n`Java\npublic class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n@Override\nprotected Class&lt;?&gt;[] getRootConfigClasses() {\n    return null;\n}\n\n@Override\nprotected Class&lt;?&gt;[] getServletConfigClasses() {\n    return new Class&lt;?&gt;[] { MyWebConfig.class };\n}\n\n@Override\nprotected String[] getServletMappings() {\n    return new String[] { &quot;/&quot; };\n}\n\n}\n`\n\n如果使用的是xml配置，需要直接继承AbstractDispatcherServletInitializer\n`Java\npublic class MyWebAppInitializer extends AbstractDispatcherServletInitializer {\n\n@Override\nprotected WebApplicationContext createRootApplicationContext() {\n    return null;\n}\n\n@Override\nprotected WebApplicationContext createServletApplicationContext() {\n    XmlWebApplicationContext cxt = new XmlWebApplicationContext();\n    cxt.setConfigLocation(&quot;/WEB-INF/spring/dispatcher-config.xml&quot;);\n    return cxt;\n}\n\n@Override\nprotected String[] getServletMappings() {\n    return new String[] { &quot;/&quot; };\n}\n\n}\n`\n\nAbstractDispatcherServletInitializer同样提供了一个方便的函数来添加过滤器。\n`Java\npublic class MyWebAppInitializer extends AbstractDispatcherServletInitializer {\n\n// ...\n\n@Override\nprotected Filter[] getServletFilters() {\n    return new Filter[] {\n        new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };\n}\n\n}\n`\n\n每个过滤器根据他具体的类型添加一个默认的名字，并且自动映射到DispatcherServlet。\nisAsyncSupported方法是AbstractDispatcherServletInitializer的protect的方法，可以启动DispatcherServlet支持异步处理\n如果要定义自己的DispatcherServlet，那么可以重写createDispatcherServlet方法。\n\n处理请求\n\nDispatcherServlet处理请求的流程如下：  - 查找WebApplicationContext并将其作为request的一个属性保存起来，以便其他控制器或者处理链中的组件可以使用。默认保存键为DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE \n  - 本地化解析器保存在request中，以便处理链中的其他组件使用他来处理请求做本地化处理。如果不需要本地化，那么就不需要使用他。\n  - 主题解析器保存在request中，以便其他组件，例如视图查找器使用，如果不需要要主题定制，直接忽略。\n  - 如果指定了文件上传解析器，那么就会检查请求是否有文件上传，如果有请求有MultipartHttpServletRequest封装，以便其他组件处理。\n  - 查找合适的处理器处理请求。如果找到了处理器，那么就依次执行处理链上的组件，返回一个model或者视图。如果是注解的controller也可以直接渲染而不需要返回视图。\n  - 如果返回一个model，会渲染一个视图，如果没有返回model，那么就无需渲染视图了，因为视图可能已经被渲染了。\n\n在请求处理过程中如果出现了一场那么就可以使用WebApplicatioContext中的HandlerExceptionResolver来定制异常处理。\nSpringMVC 同样支持返回last-modification-date，对指定请求处理如何判断是否有last-modification-date非常直接：DispatcherServlet查找适合的处理器，并且检查其是否实现了LastModified接口，如果实现了，调用long getLastModified(request)返回给客户端。\n通过web.xml中Servlet的初始化参数可以定制DispatcherServlet.\n\n参数 | 解释 |\n:---------- | :---------\ncontextClass | 实现WebApplicationContext的类，默认使用XmlWebApplicationContext \ncontextConfigLocation | 传递给Context 实例的字符串，包括了bean的定义 \nnamespace | WebApplicationContext 的命名空间，默认[servlet-name]-servlet \n\n拦截器\n\nHandlerMapping支持拦截器，在对某些请求添加处理的时候非常有用，比如，权限检查。拦截器必须实现org.springframework.web.servlet包中的HandlerInterceptor，这个接口有三个处理函数分别对应请求处理前，请求处理后，完成请求处理。\n  - preHandle(..) 在请求处理前执行\n  - postHandle(..) 请求处理后执行\n  - afterCompletion(..) 整个请求处理结束后执行\npreHandle(..) 返回一个boolean值。可以使用这个值来中断处理请求链。当返回true的时候，处理将会继续执行，如果返回false，DispatcherServelt假定拦截器已经对请求正确处理了，例如渲染了一个页面等。将会中断请求处理链。\n注意，postHandle方法很少使用@ResponseBody和ResponseEntity。因为响应已经在postHandle执行之前有HandlerAdapter返回了。意味着在postHandle的时候再修改响应已经晚了。对应这种场景可以继承ResponseBodyAdvice或者实现ControllerAdvice或者直接配置RequestMappingHandlerAdapter来实现。\n\n异常处理\n\n如果在请求映射或者处理请求的时候抛出异常，DispatcherServelt会委托HandlerExceptionResolver来解析异常并提供可选择的处理，即返一个错误响应。\n下表是HandlerExceptionResolver的实现\n\n HandlerExceptionResolver | 描述 \n:---------- | :---------\nSimpleMappingExceptionResolver | 异常类名和错误页面名的映射。浏览器渲染错误页面的时候非常实用 \nDefaultHandlerExceptionResolver | 解析SpringMVC抛出的异常，同时将其映射到HTTP的错误码上ResponseStatusExceptionResolver | 解析@ResponseStatus注解，同时根据其注解值将其映射到HTTP的错误码上ExceptionHandlerExceptionResolver | 调用@Controller 或者@ControllerAdvice 类中使用@ExceptionHandler注解的方法 \n\n解析链\n\n可以通过在Spring的配置中声明多个HandlerExceptionResolverbean，来构成一个异常处理解析链，如果需要的话，同时可以设置他们解析的顺序。序号越大，处理越靠后。\nHandlerExceptionResolver可以返回：\n  - 指向错误页面的 ModelAndView\n  - 如果异常在解析链中被处理返回空ModelAndView\n  - 如果异常为被处理返回null，后续的解析起继续处理异常，如果异常一直未被处理，那么将会冒泡到Servlet容器处理\nSpring MVC的异常是有MVC配置自动声明的，@ResponseStatus注解异常，支持@ExceptionHandler方法的异常。这些处理器都是可以定制和替换的\n\nServlet容器异常\n\n如果HandlerExceptionResolver无法处理异常，那么异常将会继续传播，或者是返回了错误的HTTP状态码，例如4xx，5xx。Servlet容器可能会渲染一个错误的页面。这个页面也是可以定制的：\nxml\n&lt;error-page&gt;\n    &lt;location&gt;/error&lt;/location&gt;\n&lt;/error-page&gt;\n\n\n根据上述代码，当出现了无法处理的异常，或者返回错误码，容器会根据配置返回一个错误的URL。这个请求将会继续被DispatcherServlet处理，比如映射到一个@Controller的错误处理控制器上：\n`Java\n@RestController\npublic class ErrorController {\n\n@RequestMapping(path = &quot;/error&quot;)\npublic Map&lt;String, Object&gt; handle(HttpServletRequest request) {\n    Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();\n    map.put(&quot;status&quot;, request.getAttribute(&quot;javax.servlet.error.status_code&quot;));\n    map.put(&quot;reason&quot;, request.getAttribute(&quot;javax.servlet.error.message&quot;));\n    return map;\n}\n\n}\n`\n\n视图解析\n\nSpring MVC通过定义了ViewResolver和View两个接口可以让我们直接通过返回model来渲染视图，而不需要指定某一个特定的视图技术。ViewResolver提供了视图名和视图之间的映射关系。在提交给特定视图技术之前由View来准备数据。\n下列表格展示了ViewResolver的层级：\n\n ViewResolver | 描述 \n:---------- | :---------\nAbstractCachingViewResolver | 缓存解析过的视图。可设置cache属性为false来关闭缓存。在需要刷新缓存的场景可调用removeFromCache(String viewName, Locale loc)刷新。\nXmlViewResolver | 实现ViewResolver，可以接收一个同Spring XML bean同DTD的xml配置文件。默认在/WEB-INF/views.xml\nResourceBundleViewResolver | 解析定义在ResourceBundle中的视图，使用viewname.class作为视图类，viewname.url作为视图名\nUrlBasedViewResolver | 无需明确指定映射，直接通过解析url来查找视图名。\nInternalResourceViewResolver | 实现UrlBasedViewResolver,JstlView,TilesView，支持InternalResourceView例如：jsp，servlet class等。\nFreeMarkerViewResolver | UrlBasedViewResolver的子类，用来支持FreeMarker\nContentNegotiatingViewResolver | 根据请求的文件名或者Accept来确定视图\n\n视图处理\n\n如果需要的话，可以声明多个视图处理器，通过设置order属性来确定他们的顺序。order越大，处理越靠后。\n默认情况下ViewResolver可以返回null代表找不到视图。当然在JSP中，使用InternalResourceViewResolver来检查JSP是否存在的唯一方式就是通过RequestDispatcher执行一次调度。因此InternalResourceViewResolver必须是最后一个视图解析器。\n\n视图redirect\n\n视图前缀redirect: 表示视图需要执行一次redirect。UrlBasedViewResolver和其子类会识别出这是要给重定向，剩下的部分就是视图名。\n这个效果和Controller返回一个RedirectView一样，但是使用这个指令，controller就可以简单的返回一个视图名就可以了。视图名redirect:/myapp/some/resource将会返回相对于当前Servlet Context的视图，redirect:http://myhost.com/some/arbitrary/path 这种则会返回绝对URL。\n注意，如果一个controller被@ResponseStatus修饰，那么注解值优先级高于RedirectView\n\n视图Forwarding\n\n视图前缀forward: 表示视图执行forwarding。同样由UrlBasedViewResolver和其子类解析。通过创建InternalResourceView执行RequestDispatcher.forward()实现。因此这个指令对于InternalResourceViewResolver和InternalResourceViewResolver没啥用，但是对于使用了其他的视图技术但是仍然想用强制使用JSP或者Servlet的时候就很有用了。\n\n视图内容协商\n\nContentNegotiatingViewResolver并不会解析视图，而是将其委托给其他视图解析器，并且选择客户端请求描述选择视图。描述可以是Accept头或者参数，例如/path?format=pdf\nContentNegotiatingViewResolver通过对比请求的媒体类型和ViewResolvers支持的媒体类型来选择合适的View。被选中的列表中的第一个View将会被返回给客户端。\n\n本地化\n\n同Spring MVC，大多数Spring架构支持国际化。DispatcherServlet通过LocaleResolver根据客户端的区域自动解析消息。\n当请求到来时DispatcherServlet查找本地化解析器，如果找到则会设置本地化。通过RequestContext.getLocale()方法可以获取由本地化解析器解析的本地化语言。\n为了自动化解析，可以通过拦截器对具体的场景进行本地化解析，例如根据请求参数来解析。\n本地化解析器和拦截器定义在org.springframework.web.servlet.i18n包中，可以在应用中配置。下面是一些Spring使用的配置\n\nTimeZone\n\n通过获取客户端的时区来做本地化。LocaleContextResolver接口扩展了LocalResolver，提供了一个可能包含时区信息的LocaleContext。\n如果可以，用户的时区可以通过RequestContext.getTimeZone()方法获取。时区信息可以自动的被注册到Spring中的ConversionService 日期时间的Converter和Formatter使用。\n\nHeader resolver\n\n这个解析器检查accept-language头，一般来说包含的是客户端操作系统的区域。注意这个不支持时区。\n\nCookie resolver\n\n这个解析器检查cookie中可能包含的TimeZone和Locale。通过如下定义来使用：\n`xml\n&lt;bean id=&quot;localeResolver&quot; class=&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;&gt;\n\n&lt;property name=&quot;cookieName&quot; value=&quot;clientlanguage&quot;/&gt;\n\n&lt;!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --&gt;\n&lt;property name=&quot;cookieMaxAge&quot; value=&quot;100000&quot;/&gt;\n\n&lt;/bean&gt;\n`\n\nCookieLocaleResolver的属性：\n\n 名字 | 默认值 | 描述 \n:---------- | :--------- | :----------\ncookieName | classname + LOCALE | cookie名\ncookieMaxAge | Servlet容器默认值 | cookie生效时间\ncookiePath | / | cookie 保存位置\n\nSession resolver\n\nSessionLocaleResolver通过从session中检查可能包含的TimeZone和Locale。相对于CookieLocaleResolver，他将信息保存在HttpSession中。\n\nLocale interceptor\n\n可以通过拦截器启动针对某些映射的本地化策略，例如如下：\n`xml\n&lt;bean id=&quot;localeChangeInterceptor&quot;\n        class=&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;&gt;\n    &lt;property name=&quot;paramName&quot; value=&quot;siteLanguage&quot;/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;localeResolver&quot;\n        class=&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;/&gt;\n\n&lt;bean id=&quot;urlMapping&quot;\n        class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;\n    &lt;property name=&quot;interceptors&quot;&gt;\n        &lt;list&gt;\n            &lt;ref bean=&quot;localeChangeInterceptor&quot;/&gt;\n        &lt;/list&gt;\n    &lt;/property&gt;\n    &lt;property name=&quot;mappings&quot;&gt;\n        &lt;value&gt;/**/*.view=someController&lt;/value&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n`\n\n主题\n\n可以通过设置Spring MVC的主题来整体设置应用的外观，从而提高用户体验。主题是一些静态资源的集合，主要是可以影响外观的样式表和图片。\n为了应用主题，首先要设置一个org.springframework.ui.context.ThemeSource的接口。WebApplicationContext继承了ThemeSource，但是将其实现委托给了子类。默认使用的是org.springframework.ui.context.support.ResourceBundleThemeSource来从classpath的根目录下加载配置文件。配置文件格式如下：\n\nstyleSheet=/themes/cool/style.css\nbackground=/themes/cool/img/coolBg.jpg\n\n配置文件的名字是视图代码中的变量名。对于JSP而言可以如下显示：\nJSP\n&lt;%@ taglib prefix=&quot;spring&quot; uri=&quot;http://www.springframework.org/tags&quot;%&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;spring:theme code=&#39;styleSheet&#39;/&gt;&quot; type=&quot;text/css&quot;/&gt;\n    &lt;/head&gt;\n    &lt;body style=&quot;background=&lt;spring:theme code=&#39;background&#39;/&gt;&quot;&gt;\n        ...\n    &lt;/body&gt;\n&lt;/html&gt;\n\n\n默认情况下ResourceBundleThemeSource使用空的前缀名，这样配置文件直接从classpath根目录下加载。这样就可以将cool.properties定义放到classpath根目录下，ResourceBundleThemeSource默认使用标准的Java资源加载工具，同时也完全支持国际化，所以通过命名来支持cool_nl.properties。\n\n解析主题\n\nDispatcherServlet通过bean的名字themeResolver来查找ThemeResolver的实现。\nThemeResolver 的实现如下：\n\nClass | 描述 \n:---------- | :---------\nFixedThemeResolver | 选中一个固定的主题，设置defaultThemeName属性\nSessionThemeResolver | 主题由用户session维护。每个session只需要设置一次\nCookieThemeResolver | 通过cookie选择主题\n\nMultipart resolver\n\norg.springframework.web.multipart中的MultipartResolver是用来处理multipart请求的。共有给予Common Fileupload和Servlet 3.0 两种实现。\n为了使用multipart，需要在DispatcherServlet的Spring配置中声明一个名字为multipartResolver的bean。当POST请求的content-type是multipart/form-data的时候，解析器解析这个请求并且将HttpServletRequest封装成MultipartHttpServletRequest来处理请求。\n\nApache FileUpload\n\n使用Apache Commons FileUpload 只需要简单的配置一个类型为CommonsMultipartResolver，名字为multipartResolver的bean即可。当然也需要将commons-fileupload加入到依赖中。\n\nServlet 3.0\n\n使用Servlet 3.0则需要Servlet 容器的配置\n  - 使用Java配置，在Servlet注册中设置MultipartConfigElement。\n  - 使用web.xml 添加要给&lt;multipart-config&gt;的配置\n如下是使用Java的配置：\n\n`Java\npublic class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n// ...\n\n@Override\nprotected void customizeRegistration(ServletRegistration.Dynamic registration) {\n\n    // Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold\n    registration.setMultipartConfig(new MultipartConfigElement(&quot;/tmp&quot;));\n}\n\n}\n`\n\nServlet 3.0配置好之后，只需要添加类型为StandardServletMultipartResolver，名字为multipartResolver的配置即可。","readingtime":24,"url":"/cates/backend/post/2018-04-09/spring-mvc-dispatcher-servlet","dirs":["spring-mvc"],"relatives":[{"url":"/cates/backend/post/2018-04-07/deep-in-spring-mvc","title":"深入理解Spring MVC"},{"url":"/cates/backend/post/2018-04-10/spring-mvc-controller","title":"SpringMVC 教程 - Controller"},{"url":"/cates/backend/post/2018-04-09/spring-mvc-filter","title":"SpringMVC 教程 - Filter"}]},{"title":"SpringMVC 教程 - Filter","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-247383127.jpg","iso8601Date":"2018-04-09T08:39:10+08:00","basename":"spring-mvc-filter","tags":["Backend","Java","SpringMVC","Spring"],"date":"2018-04-09","cate":"backend","summary":"简介\n\nspring-web模块提供了许多非常实用的Filter\n\nHTTP PUT FORM\n\n浏览器只能通过GET或者POST提交FORM数据，但是非浏览器的客户端可以使用PUT或者PATCH。Servlet API仅为POST方法提供了ServletRequest.getParameter*()方法获取FORM信息。\nspring-web模块提供了HttpPutFormContentFilter检查PUT或者PATCH方法的content-type是否是application/x-www-form-urlencoded,如果是，则从请求体重读取属性并封装到ServletRequest中，以便日后通过ServletRequest.getParameter*()获取FORM数据。\n\n重定向头\n\n由于请求会经过像负载均衡器这样的代理，那么host，port，scheme在创建一些资源文件的链接的时候返回给客户端可能是有所不同的。\nRFC 7239 为代理定义了Forwarded 的HTTP头来提供原始请求的信息。同样也有一些其他非标准的HTTP头，例如：X-Forwarded-Host,X-Forwarded-Port,X-Forwarded-Proto。\nForwardedHeaderFilter会从Forwarded,X-Forwarded-Host,X-Forwarded-Port或者X-Forwarded-Proto中获取跳转信息。他分装了请求以覆盖host，port，scheme，同样为日后的处理隐藏跳转信息。\n注意，根据RFC 7239第八节的解释，使用重定向头的时候会有安全问题。在应用层是无法判断一个挑战是否是可信的。所以要正确配置网络上游代理，以便过滤掉不合法的跳转。\n如果应用没有使用代理，那么就无需使用ForwardedHeaderFilter过滤器。\n\nShallow ETag\n\nShallowEtagHeaderFilter为ETG提供了过滤器，关于ETAG将在视图技术中详细解释。\n\nCORS\n\n通过controller的注解Spring MVC对CORS提供了详细的支持。在和Spring Sercurity一同使用的时候CorsFilter必须排在Spring Sercurity的过滤器之前。\n\n关于CORS\n\n由于安全原因，浏览器禁止AJAX跳出当前域去访问资源。例如你的银行帐号在一个tab页打卡了，另一个evil.com在其他tab打开。evil.com的脚本不能使用你的银行账号信息去访问银行的API。\nCross-Origin Resource Sharing (CORS) 是由众多浏览器实现的W3C的规范。他规定了允许哪些请求可以跨域，而不是通过弱安全的和功能受限的IFRAME和JSONP。\nHandlerMapping对CORS提供了内置支持。成功将请求映射到处理器后，HandlerMapping对当前请求检查CORS配置，预检请求直接处理，简单和实际请求则检查CORS请求，验证，设置返回header。\n为了开启跨域请求（例如Origin头和请求的host不一致），需要对CORS进行明确的配置。如果没有找到CORS的配置，那么直接拒绝预检请求，简单请求和实际请求不会添加响应头，因此浏览器不会获取到信息。\n每一个HandlerMapping都可以根据URL不同配置单独的 CorsConfiguration。一般来说应用会通过Java Config或者Xml 命名空间来配置单一，全局的CORS。\nHandlerMapping级别的全局CORS配置可以和handler级别的CORS合并。例如有注解的controller可以使用类或者方法级别的注解@CrossOrigin配置跨域。\n@CrossOrigin注解可以在controller层启动对请求的跨域检查，例如：\n`Java\n@RestController\n@RequestMapping(&quot;/account&quot;)\npublic class AccountController {\n\n@CrossOrigin\n@GetMapping(&quot;/{id}&quot;)\npublic Account retrieve(@PathVariable Long id) {\n    // ...\n}\n\n@DeleteMapping(&quot;/{id}&quot;)\npublic void remove(@PathVariable Long id) {\n    // ...\n}\n\n}\n\n默认情况下`@CrossOrigin`的作用如下：\n  - 允许所有的域\n  - 允许所有header\n  - 允许controller映射的方法\n  - `allowedCredentials` 默认关闭\n  - `max-age`默认30分钟\n`@CrossOrigin`同样支持类级别：\nJava\n@CrossOrigin(origins = &quot;http://domain2.com&quot;, maxAge = 3600)\n@RestController\n@RequestMapping(&quot;/account&quot;)\npublic class AccountController {\n\n@GetMapping(&quot;/{id}&quot;)\npublic Account retrieve(@PathVariable Long id) {\n    // ...\n}\n\n@DeleteMapping(&quot;/{id}&quot;)\npublic void remove(@PathVariable Long id) {\n    // ...\n}\n\n}\n\n`@CrossOrigin`同时可以在类和方法中使用：\nJava\n@CrossOrigin(maxAge = 3600)\n@RestController\n@RequestMapping(&quot;/account&quot;)\npublic class AccountController {\n\n@CrossOrigin(&quot;http://domain2.com&quot;)\n@GetMapping(&quot;/{id}&quot;)\npublic Account retrieve(@PathVariable Long id) {\n    // ...\n}\n\n@DeleteMapping(&quot;/{id}&quot;)\npublic void remove(@PathVariable Long id) {\n    // ...\n}\n\n}\n\n通过定义全局的CORS配置，来配合使用。全局的CORS配置可以通过Java Config或者XML的XNM命名空间来配置。\n默认情况下全局的CORS配置：\n  - 允许所有的域\n  - 允许所有的header\n  - 允许GET,HEAD，POST方法\n  - `allowedCredentials` 默认关闭\n  - `max-age`默认30分钟\n使用Java配置CORS\nJava\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n\n@Override\npublic void addCorsMappings(CorsRegistry registry) {\n\n    registry.addMapping(&quot;/api/**&quot;)\n        .allowedOrigins(&quot;http://domain2.com&quot;)\n        .allowedMethods(&quot;PUT&quot;, &quot;DELETE&quot;)\n        .allowedHeaders(&quot;header1&quot;, &quot;header2&quot;, &quot;header3&quot;)\n        .exposedHeaders(&quot;header1&quot;, &quot;header2&quot;)\n        .allowCredentials(true).maxAge(3600);\n\n    // Add more mappings...\n}\n\n}\n\n使用XML配置CORS\nXml\n&lt;mvc:cors&gt;\n\n&lt;mvc:mapping path=&quot;/api/**&quot;\n    allowed-origins=&quot;http://domain1.com, http://domain2.com&quot;\n    allowed-methods=&quot;GET, PUT&quot;\n    allowed-headers=&quot;header1, header2, header3&quot;\n    exposed-headers=&quot;header1, header2&quot; allow-credentials=&quot;true&quot;\n    max-age=&quot;123&quot; /&gt;\n\n&lt;mvc:mapping path=&quot;/resources/**&quot;\n    allowed-origins=&quot;http://domain1.com&quot; /&gt;\n\n&lt;/mvc:cors&gt;\n\n另外，也可以通过`CorsFilter`配置CORS。\nJava\nCorsConfiguration config = new CorsConfiguration();\n\n// Possibly...\n// config.applyPermitDefaultValues()\n\nconfig.setAllowCredentials(true);\nconfig.addAllowedOrigin(&quot;http://domain1.com&quot;);\nconfig.addAllowedHeader(&quot;&quot;);\nconfig.addAllowedMethod(&quot;&quot;);\n\nUrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\nsource.registerCorsConfiguration(&quot;/**&quot;, config);\n\nCorsFilter filter = new CorsFilter(source);\n`","readingtime":8,"url":"/cates/backend/post/2018-04-09/spring-mvc-filter","dirs":["spring-mvc"],"relatives":[{"url":"/cates/backend/post/2018-04-07/deep-in-spring-mvc","title":"深入理解Spring MVC"},{"url":"/cates/backend/post/2018-04-10/spring-mvc-controller","title":"SpringMVC 教程 - Controller"},{"url":"/cates/backend/post/2018-04-09/spring-mvc-dispatcher-servlet","title":"SpringMVC 教程 - DispatcherServlet"}]},{"title":"SpringMVC 教程 - Controller","cover":"http://p6jqy6mfr.bkt.clouddn.com/stock-photo-244371365.jpg","iso8601Date":"2018-04-10T08:39:10+08:00","basename":"spring-mvc-controller","tags":["Backend","Java","SpringMVC","Spring"],"date":"2018-04-10","cate":"backend","summary":"声明Controller\n\nController也是一个标准的Spring bean，可以在Servlet的WebApplicationContext中定义。也可以使用@Controller注解，Spring会扫描注解自动注册为Spring的bean。\n开启自动注册@Controller注解的bean可以使用如下Java Config的配置：\n`Java\n@Configuration\n@ComponentScan(&quot;org.example.web&quot;)\npublic class WebConfig {\n\n// ...\n\n}\n\n如果使用xml配置，如下：\nxml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\n    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n    xsi:schemaLocation=&quot;\n        http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n\n&lt;context:component-scan base-package=&quot;org.example.web&quot;/&gt;\n\n&lt;!-- ... --&gt;\n\n&lt;/beans&gt;\n`\n\n请求映射\n\n@RequestMapping可以将请求映射到具体的Controller方法上。通过找到匹配的url，http 方法，请求参数，header，媒体类型来映射请求。这个注解既可以用在类级别，也可以用在方法级别上。\n为了方便@RequestMapping根据HTTP方法不同提供了如下快捷注解：\n  - @GetMapping\n  - @PostMapping\n  - @DeleteMapping\n  - @PutMapping\n  - @PatchMapping\n\n示例如下所示：\n`Java\n@RestController\n@RequestMapping(&quot;/persons&quot;)\nclass PersonController {\n\n@GetMapping(&quot;/{id}&quot;)\npublic Person getPerson(@PathVariable Long id) {\n    // ...\n}\n\n@PostMapping\n@ResponseStatus(HttpStatus.CREATED)\npublic void add(@RequestBody Person person) {\n    // ...\n}\n\n}\n`\n\nURI 模式\n\n请求映射支持glob模式和通配符\n  - ? 匹配一个字符\n  - * 匹配0个或多个字符\n  - ** 匹配0个或多个路径\n可以通过@PathVariable 访问在URI中定义的变量：\nJava\n@GetMapping(&quot;/owners/{ownerId}/pets/{petId}&quot;)\npublic Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {\n    // ...\n}\n \nURI的变量可以在类和方法中定义：\n`Java\n@Controller\n@RequestMapping(&quot;/owners/{ownerId}&quot;)\npublic class OwnerController {\n\n@GetMapping(&quot;/pets/{petId}&quot;)\npublic Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {\n    // ...\n}\n\n}\n`","readingtime":5,"url":"/cates/backend/post/2018-04-10/spring-mvc-controller","dirs":["spring-mvc"],"relatives":[{"url":"/cates/backend/post/2018-04-07/deep-in-spring-mvc","title":"深入理解Spring MVC"},{"url":"/cates/backend/post/2018-04-09/spring-mvc-dispatcher-servlet","title":"SpringMVC 教程 - DispatcherServlet"},{"url":"/cates/backend/post/2018-04-09/spring-mvc-filter","title":"SpringMVC 教程 - Filter"}]}],"tag":"Backend"}}