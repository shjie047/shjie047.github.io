{"path":"tags/go","templateID":3,"sharedPropsHashes":{},"localProps":{"posts":[{"title":"HTTP/2 和GO","tags":["http","HTTP/2","Translate","Go","backend"],"iso8601Date":"2015-11-12T19:39:21+08:00","basename":"HTTP-2-和GO","body":"\n[原文地址](https://www.ianlewis.org/en/http2-and-go)\n\nHTTP/2是一个添加了一些新功能的HTTP的新版本，这些功能包括连接复用，首部压缩。再Go的标准库中暂时还没有HTTP/2的实现，但是现在有很多正在开发的库可以用来在Go中实现HTTP/2的server和client。\n\nBrad Fitzpatrick实现了一个[golang.org/x/net/http2](https://godoc.org/golang.org/x/net/http2)的库，这个库甚至最终会加入到标准库中，不过他现在正在开发，所以在其他的库中。因为他现在的开发很活跃，所有情况因人而异，但是如果你想实现HTTP/2的服务器，仍然可以使用这个库。\n\n### 创建HTTP/2服务器\n\n使用http2的库写一个服务器是很简单的。http2库和标准库的http包集成在一起，需要调用`http2.ConfigureServer()`来配置一个普通http使用HTTP/2协议。如果需要通过浏览器访问或者降级到HTTP 1.x 协议，那么你需要设置TLS 加密。虽然加密不是必须的，但是现在还没有浏览器支持非加密的HTTP/2协议。\n\n```Go\npackage main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"os\"\n\n    \"golang.org/x/net/http2\"\n)\n\nfunc main() {\n    cwd, err := os.Getwd()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    srv := &http.Server{\n        Addr:    \":8000\", // Normally \":443\"\n        Handler: http.FileServer(http.Dir(cwd)),\n    }\n    http2.ConfigureServer(srv, &http2.Server{})\n    log.Fatal(srv.ListenAndServeTLS(\"server.crt\", \"server.key\"))\n}\n```\n\n### 创建HTTP/2 客户端\n\n现在使用http2的库创建客户端很hacky。虽然它会输出很多调试日志，但是对于大多数情况下运行的很好。可以使用`http2.Transport`对象，将他传给`http`包的client。\n\n```Go\npackage main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"log\"\n    \"net/http\"\n\n    \"golang.org/x/net/http2\"\n)\n\nfunc main() {\n    client := http.Client{\n        // InsecureTLSDial is temporary and will likely be\n        // replaced by a different API later.\n        Transport: &http2.Transport{InsecureTLSDial: true},\n    }\n\n    resp, err := client.Get(\"https://localhost:8000/\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(string(body))\n}\n```\n\n### 更多阅读\n\n如果你对HTTP/2协议感兴趣，那么可以参考[HTTP/2 主页](https://http2.github.io/)，这个页面有很多其他资料的连接还有其他语言的实现。\n\n如果你想知道HTTP/2的服务端和客户端是如何实现的，那么[Jxck's http2 implementation](https://github.com/Jxck/http2)的实现就很值得一读。Jxck通过对标准的HTTP库的TLSNextProto设置一个钩子来实现的。你可以再这里阅读一些[示例](https://github.com/Jxck/http2/blob/master/sample/http.go)。\n\ngrpc-go 库同样也有自己的服务端和客户端的实现。\n","date":"2015-11-12"},{"title":"http.Handler 与Go的错误处理","tags":["Go","Translate","backend"],"iso8601Date":"2015-11-13T05:24:57+08:00","basename":"http-Handler-与Go的错误处理","body":"\n\n[原文地址](http://elithrar.github.io/article/http-handler-error-handling-revisited/)\n\n 在之前我写过一篇关于通过使用`http.HandlerFunc`来实现一个定制handler类型用来避免一些平常的错误的[文章](http://elithrar.github.io/article/custom-handlers-avoiding-globals/)。`func MyHandler(w http.ResponseWriter, r *http.Request)`的签名经常可以看到。这是一个有用的通用的包含一些基本功能的handler类型，但是和其他事情一样，也有一些不足：\n* 当你想要在一个handler中停止处理的时候，必须记得显示的调用一个return。这个在当你想要跑出一个从定向（301、302），未找到（404）或者服务器端错误（500）的状态的时候是很平常的。如果不这么做可能会引起一些微妙的错误（函数会继续执行），因为函数不需要一个返回值，编译器也不会警告你。\n* 不容易传递额外的参数（例如，数据库连接池，配置）。你最后不得不实用一系列的全局变量（不算太坏，但是跟踪他们会导致难以扩展）或者将他们存到请求上下文中，然后每次都从其取出。这样做很笨重。\n* 一直在不断的重复同样的语句。想要记录数据库包返回的错误？既可以再每个查询方法中调用`log.Printf`，也可以再每个handler中返回错误。如果你的handler可以返回给一个集中记录错误的函数，并且跑出一个500的错误就更好了。\n\n 我以前的方法中使用了`func(http.ResponseWriter, *http.Request)`签名。这已经被证明是一个简介的方式，但是有个奇怪的地方是，返回一个无错误的状态，例如，200,302,303往往是多余的，因为要么你已经在其他地方设置了，要么就是没用的。例如：\n\n```Go\nfunc SomeHandler(w http.ResponseWriter, r *http.Request) (int, error) {\n    db, err := someDBcall()\n    if err != nil {\n        // This makes sense.\n        return 500, err\n    }\n\n    if user.LoggedIn {\n        http.Redirect(w, r, \"/dashboard\", 302)\n        // Superfluous! Our http.Redirect function handles the 302, not \n        // our return value (which is effectively ignored).\n        return 302, nil\n    }\n\n}\n```\n\n看起来还行，但是我们可以做的更好\n\n### 一些区别\n\n 那么我们应该如何改进它？我们先列出代码：\n\n```Go\npackage handler\n\n// Error represents a handler error. It provides methods for a HTTP status \n// code and embeds the built-in error interface.\ntype Error interface {\n    error\n    Status() int\n}\n\n// StatusError represents an error with an associated HTTP status code.\ntype StatusError struct {\n    Code int\n    Err  error\n}\n\n// Allows StatusError to satisfy the error interface.\nfunc (se StatusError) Error() string {\n    return se.Err.Error()\n}\n\n// Returns our HTTP status code.\nfunc (se StatusError) Status() int {\n    return se.Code\n}\n\n// A (simple) example of our application-wide configuration.\ntype Env struct {\n    DB   *sql.DB\n    Port string\n    Host string\n}\n\n// The Handler struct that takes a configured Env and a function matching\n// our useful signature.\ntype Handler struct {\n    *Env\n    H func(e *Env, w http.ResponseWriter, r *http.Request) error\n}\n\n// ServeHTTP allows our Handler type to satisfy http.Handler.\nfunc (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    err := h.H(h.Env, w, r)\n    if err != nil {\n        switch e := err.(type) {\n        case Error:\n            // We can retrieve the status here and write out a specific\n            // HTTP status code.\n            log.Printf(\"HTTP %d - %s\", e.Status(), e)\n            http.Error(w, e.Error(), e.Status())\n        default:\n            // Any error types we don't specifically look out for default\n            // to serving a HTTP 500\n            http.Error(w, http.StatusText(http.StatusInternalServerError),\n                http.StatusInternalServerError)\n        }\n    }\n}\n```\n\n 上面的代码不言自明，但是要说明一下一些突出的观点：\n\n* 我们自定义了一个`Error`类型（接口），他内嵌了Go的内建的error接口，同时提供了一个`Status() int`方法。\n* 我们提供了一个简单的`StatusError`类型（结构体），它满足`handler.Error`的接口。StatusError接受一个HTTP的状态码（int类型），一个可以让我们包装错误用来记录或者查询的error类型。\n* 我们的`ServeHTTP`方法包好了一个\"e := err.(type)\"的类型断言，它可以测试我们需要处理的错误，允许我们处理那些特别的错误。在这个例子中，他是只是一个`handler.Error`类型。其他的错误，例如其他包中的错误想net.Error，或者其他我们定义的额外的错误，如果想要检查，同样也可以检查。\n\n 如果我们不想捕捉那些错误，那么`default`将会默认捕捉到。记住一点，`ServeHTTP`可以使我们的Handler类型满足http.Handler接口，这样他就可以在任何使用http.Handler的地方使用了，例如Go的net/http包或者所有的其他的第三方框架。这样使得定制的handler更有用，他们用起来很灵活。\n 注意 net 包处理事情很简单。它又一个net.Error的接口，内嵌了内建的error接口。一些具体的类型实现了它。函数返回的具体类型跟错误的类型相同（DNS错误，解析错误等）。再datastore 包中定义的DBError有一个Query() string 方法，可以很好的解释。\n\n### 所有示例\n\n 它最后是什么样子的？我们是否可以将其分到不同的包中？\n\n```Go\npackage handler\n\nimport (\n    \"net/http\"\n)\n\n// Error represents a handler error. It provides methods for a HTTP status \n// code and embeds the built-in error interface.\ntype Error interface {\n    error\n    Status() int\n}\n\n// StatusError represents an error with an associated HTTP status code.\ntype StatusError struct {\n    Code int\n    Err  error\n}\n\n// Allows StatusError to satisfy the error interface.\nfunc (se StatusError) Error() string {\n    return se.Err.Error()\n}\n\n// Returns our HTTP status code.\nfunc (se StatusError) Status() int {\n    return se.Code\n}\n\n// A (simple) example of our application-wide configuration.\ntype Env struct {\n    DB   *sql.DB\n    Port string\n    Host string\n}\n\n// The Handler struct that takes a configured Env and a function matching\n// our useful signature.\ntype Handler struct {\n    *Env\n    H func(e *Env, w http.ResponseWriter, r *http.Request) error\n}\n\n// ServeHTTP allows our Handler type to satisfy http.Handler.\nfunc (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    err := h.H(h.Env, w, r)\n    if err != nil {\n        switch e := err.(type) {\n        case Error:\n            // We can retrieve the status here and write out a specific\n            // HTTP status code.\n            log.Printf(\"HTTP %d - %s\", e.Status(), e)\n            http.Error(w, e.Error(), e.Status())\n        default:\n            // Any error types we don't specifically look out for default\n            // to serving a HTTP 500\n            http.Error(w, http.StatusText(http.StatusInternalServerError),\n                http.StatusInternalServerError)\n        }\n    }\n}\n\nfunc GetIndex(env *Env, w http.ResponseWriter, r *http.Request) error {\n    users, err := env.DB.GetAllUsers()\n    if err != nil {\n        // We return a status error here, which conveniently wraps the error\n        // returned from our DB queries. We can clearly define which errors \n        // are worth raising a HTTP 500 over vs. which might just be a HTTP \n        // 404, 403 or 401 (as appropriate). It's also clear where our \n        // handler should stop processing by returning early.\n        return StatusError{500, err}\n    }\n\n    fmt.Fprintf(w, \"%+v\", users)\n    return nil\n}\n```\n\n main包：\n\n```Go\npackage main\n\nimport (\n    \"net/http\"\n    \"github.com/you/somepkg/handler\"\n)\n\nfunc main() {\n    db, err := sql.Open(\"connectionstringhere\")\n    if err != nil {\n          log.Fatal(err)\n    }\n\n    // Initialise our app-wide environment with the services/info we need.\n    env := &handler.Env{\n        DB: db,\n        Port: os.Getenv(\"PORT\"),\n        Host: os.Getenv(\"HOST\"),\n        // We might also have a custom log.Logger, our \n        // template instance, and a config struct as fields \n        // in our Env struct.\n    }\n\n    // Note that we're using http.Handle, not http.HandleFunc. The \n    // latter only accepts the http.HandlerFunc type, which is not \n    // what we have here.\n    http.Handle(\"/\", handler.Handler{env, handler.GetIndex})\n\n    // Logs the error if ListenAndServe fails.\n    log.Fatal(http.ListenAndServe(\":8000\", nil))\n}\n```\n\n 在实际使用时，会将handler和Env放入不同的包中，这里只是为了简单放在了同一个包中。\n\n","date":"2015-11-13"},{"title":"为Go Web App 创建一个主页面","tags":["Go","Translate","backend"],"iso8601Date":"2015-11-15T01:59:00+08:00","basename":"为Go-Web-App-创建一个主页面","body":"\n\n\n[原文地址](http://sanatgersappa.blogspot.com/2013/11/creating-master-page-for-your-go-web-app.html)\n\n 大多数web app都有一个相同的布局。这个布局可能包含一个header或者footer，甚至可能包含一个导航菜单。Go的标准库提供一个简单的方式来创建这些基本元素，通过被不同的页面重用，创建出模板页的效果。\n 这个简单的例子来解释如何实现的：\n 让我们来创建一个简单的包含两个view的web app，一个是 main 一个是about。这两个view都有相同的header和footer。\n header模板的代码如下：\n\n```html\n{ { define \"header\" }}\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>{ {.Title}}</title>\n        <link rel=\"stylesheet\" href=\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css\">\n        <link rel=\"stylesheet\" href=\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-theme.min.css\">\n        <style type=\"text/css\">\n            body {padding-bottom: 70px;}\n            .content {margin:10px;}\n        </style>\n    </head>\n    <body>\n        <nav class=\"navbar navbar-default\" role=\"navigation\">\n          <div class=\"navbar-header\">\n            <a class=\"navbar-brand\" href=\"/\">Go App</a>\n          </div>\n          <div class=\"collapse navbar-collapse navbar-ex1-collapse\">  \n            <ul class=\"nav navbar-nav\">\n                <li><a href=\"/\">Main</a></li>\n                <li><a href=\"/about\">About</a></li>\n            </ul>\n          </div>\n        </nav>\n{ { end }}\n```\n\n footer模板的代码如下：\n\n\n```html\n{ { define \"footer\" }}\n        <p class=\"navbar-text navbar-fixed-bottom\">Go Rocks!</p>    \n        <script src=\"//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js\"></script>\n    </body>\n</html>\n{ { end }}\n\n```\n\n main 模板的代码如下：\n\n```html\n{ {define \"main\"}}\n{ { template \"header\" .}}\n<div class=\"content\">\n    <h2>Main</h2>\n    <div>This is the Main page</div>\n</div>\n{ {template \"footer\" .}}\n{ { end}}\n```\n\n about 模板的代码如下：\n\n```html\n{ {define \"about\"}}\n{ { template \"header\" .}}\n<div class=\"content\">\n    <h2>About</h2>\n    <div>This is the About page</div>\n</div>\n{ {template \"footer\" .}}\n{ { end}}\n```\n\n 服务器代码如下：\n\n```Go\npackage main\n\nimport (\n    \"html/template\"\n    \"net/http\"\n)\n\n//Compile templates on start\nvar templates = template.Must(template.ParseFiles(\"header.html\", \"footer.html\", \"main.html\", \"about.html\"))\n\n//A Page structure\ntype Page struct {\n    Title string\n}\n\n//Display the named template\nfunc display(w http.ResponseWriter, tmpl string, data interface{}) {\n    templates.ExecuteTemplate(w, tmpl, data)\n}\n\n//The handlers.\nfunc mainHandler(w http.ResponseWriter, r *http.Request) {\n    display(w, \"main\", &Page{Title: \"Home\"})\n}\n\nfunc aboutHandler(w http.ResponseWriter, r *http.Request) {\n    display(w, \"about\", &Page{Title: \"About\"})\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", mainHandler)\n    http.HandleFunc(\"/about\", aboutHandler)\n\n    //Listen on port 8080\n    http.ListenAndServe(\":8080\", nil)\n}\n```\n\n 每一个模板页都有一个 `{ { define \"name\" }}`的命令来定义模板的名字。main和about页面通过`{ { template \"name\" }}`来包含header和footer。`.` 出入上下文来命名模板。现在，不管main和about页面如何执行，他们的页面都会包含header和footer。\n 两个页面的结果如下：\n\n![main](https://raw.githubusercontent.com/mashuai/hexo-blog/master/goweb/main.png)  \n![about](https://raw.githubusercontent.com/mashuai/hexo-blog/master/goweb/about.png)  \n","date":"2015-11-15"},{"title":"使用Go开发HTTP中间件","tags":["HTTP","Go","Middleware","backend"],"iso8601Date":"2015-11-12T20:07:49+08:00","basename":"使用Go开发HTTP中间件","body":"\n[原文地址](https://justinas.org/writing-http-middleware-in-go/)\n\n 再web开发的背景下，“中间件”通常意思是“包装原始应用并添加一些额外的功能的应用的一部分”。这个概念似乎总是不被人理解，但是我认为中间件非常棒。\n 首先，一个好的中间件有一个责任就是可插拔并且自足。这就意味着你可以在接口级别嵌入你的中间件他就能直接运行。它不会影响你编码方式，不是框架，仅仅是你请求处理里面的一层而已。完全没必要重写你的代码，如果你想使用中间件的一个功能，你就帮他插入到那里，如果不想使用了，就可以直接移除。\n 纵观Go语言，中间件是非常普遍的，即使在标准库中。虽然开始的时候不会那么明显，在标准库`net/http`中的函数`StripText`或者`TimeoutHandler`就是我们要定义和的中间件的样子，处理请求和相应的时候他们包装你的handler，并处理一些额外的步骤。\n 我最近写的Go包[nosurf](https://github.com/justinas/nosurf)同样也是个中间件。我特意将他从头开始设计。在大多数情况下，你不需要在应用层担心CSRF攻击，nosurf像其他的中间件一样可以自足，并且和`net/http`的接口无缝衔接。\n 同样你还可以使用中间件做：\n* 隐藏长度防止缓冲攻击\n* 速度限制\n* 屏蔽爬虫\n* 提供调试信息\n* 添加HSTS，X-Frame-Options头\n* 从错误中恢复\n* 等等\n\n### 编写一个简单的中间件\n\n 我们的第一个例子是写一个只允许一个域名下的用户访问的中间件，通过HTTP的`HOST`header实现。这样的中间件可以防止[主机欺骗攻击](http://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html)。\n\n### 类型的机构\n\n 首先我们定义一个结构体，叫做`SingleHost`\n\n```Go\ntype SingleHost struct {\n    handler     http.Handler\n    allowedHost string\n}\n```\n\n 它只包含两个field。\n* 如果是一个可用的Host，那么我们会调用嵌入的handler。\n* allowedHost 就是允许的Host。\n 因为我们将其首字母小写，因此他们只对本包可见。我们需要给它定义已给构造函数。\n\n```Go\nfunc NewSingleHost(handler http.Handler, allowedHost string) *SingleHost {\n    return &SingleHost{handler: handler, allowedHost: allowedHost}\n}\n```\n\n### 请求处理\n\n 现在需要实现真正的逻辑功能了。想要实现`http.Handler`，我们只需要实现他的一个方法。\n\n```Go\ntype Handler interface {\n        ServeHTTP(ResponseWriter, *Request)\n}\n```\n\n 实现如下：\n\n```Go\nfunc (s *SingleHost) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    host := r.Host\n    if host == s.allowedHost {\n        s.handler.ServeHTTP(w, r)\n    } else {\n        w.WriteHeader(403)\n    }\n}\n```\n\n`ServeHTTP`只是检查请求的Host：\n* 如果Host和配置的allowed一直，那么调用handler的ServeHTTP。\n* 如果不一直返回403\n对于后一种情况，不仅不会得到应答，设置不知道有这个请求。\n现在我们已经开发哈了中间件，只需要将其插入到需要的地方。\n\n```Go\nsingleHosted = NewSingleHost(myHandler, \"example.com\")\nhttp.ListenAndServe(\":8080\", singleHosted)\n```\n\n### 另一种方式\n\n 我们刚刚写的那个中间件很简单，它只有15行代码。写这样的中间件，可以使用样板方法。由于Go支持函数为一等公民和闭包，并且有`http.HandlerFunc`包装函数，我们可以通过他创建一个中间件，而不是将其放入到一个结构体中。下面是这个中间件的写法。\n\n```Go\nfunc SingleHost(handler http.Handler, allowedHost string) http.Handler {\n    ourFunc := func(w http.ResponseWriter, r *http.Request) {\n        host := r.Host\n        if host == allowedHost {\n            handler.ServeHTTP(w, r)\n        } else {\n            w.WriteHeader(403)\n        }\n    }\n    return http.HandlerFunc(ourFunc)\n}\n```\n 我们定义了一个简单的函数`SingleHost`，它包装了`Handler`和允许的Host，在其内部我们实现了一个跟上面中间件类似的功能。我们内部的函数就是一个闭包，因此他可以访问外部函数的变量。最终HandlerFunc让我们可以将其变为Handler。\n 觉得是使用HandlerFunc还是自己实现一个http.Handler完全取决于你自己。对于简单的情况，一个简单的函数就完全够了。如果你的中间件越来越多，那么就可以考虑实现自己的结构并把它们分开。\n 同时标准库同时使用了两种功能。`StripPrefix`使用的是HandlerFunc，TimeoutHandler使用的是自定义的结构体。\n\n### 一个更复杂的例子\n\n 我们的`SingleHost`并不重要，我们只检测一个属性，要么将他传递给其他的handler，要么直接返回。然而存在这种情况，我们的程序需要对处理完进行后续处理。\n\n### 添加数据是简单的\n\n 如果只是想简单的添加数据，那么使用Write就可以了。\n\n```Go\ntype AppendMiddleware struct {\n    handler http.Handler\n}\n\nfunc (a *AppendMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    a.handler.ServeHTTP(w, r)\n    w.Write([]byte(\"Middleware says hello.\"))\n}\n```\n\n 返回的结构肯定会包含`Middleware says hello.`\n\n### 问题\n\n 但是操作其他的数据有点困难。例如我们想要在它前面添加数据而不是后面追加。如果我们在原Handler之前调用Write，那么将会失去控制，因为第一个Write已经将他写入了。\n 通过其他方法修改原始输出，例如替换字符串，改变响应header，或者设置状态码都不会起作用，因为当handler返回的时候数据已经返回到客户端了。\n 为了实现这个功能，我们需要一个特殊的ResponseWriter，他可以想buffer一样工作，收集数据，存储以备使用和修改。然后我们将这个ResponseWriter传递给handler，而不是传递真是的RW，这样在其之前我们已经修改了它了。\n 幸运的是在标准库中有这样的一个工具。在`net/http/httptest`包里的ResponseRecorder能做所有我们需要的：保存状态码，一个响应header的map，将body放入byte 缓冲中。虽然它是再测试中中使用的，但是很服务我们的情况。\n\n```Go\ntype ModifierMiddleware struct {\n    handler http.Handler\n}\n\nfunc (m *ModifierMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    rec := httptest.NewRecorder()\n    // passing a ResponseRecorder instead of the original RW\n    m.handler.ServeHTTP(rec, r)\n    // after this finishes, we have the response recorded\n    // and can modify it before copying it to the original RW\n\n    // we copy the original headers first\n    for k, v := range rec.Header() {\n        w.Header()[k] = v\n    }\n    // and set an additional one\n    w.Header().Set(\"X-We-Modified-This\", \"Yup\")\n    // only then the status code, as this call writes out the headers \n    w.WriteHeader(418)\n\n    // The body hasn't been written (to the real RW) yet,\n    // so we can prepend some data.\n    data := []byte(\"Middleware says hello again. \")\n\n    // But the Content-Length might have been set already,\n    // we should modify it by adding the length\n    // of our own data.\n    // Ignoring the error is fine here:\n    // if Content-Length is empty or otherwise invalid,\n    // Atoi() will return zero,\n    // which is just what we'd want in that case.\n    clen, _ := strconv.Atoi(r.Header.Get(\"Content-Length\"))\n    clen += len(data)\n    r.Header.Set(\"Content-Length\", strconv.Itoa(clen))\n\n    // finally, write out our data\n    w.Write(data)\n    // then write out the original body\n    w.Write(rec.Body.Bytes())\n}\n```\n最后僵尸我们中间件的输出：\n\n```\nHTTP/1.1 418 I'm a teapot\nX-We-Modified-This: Yup\nContent-Type: text/plain; charset=utf-8\nContent-Length: 37\nDate: Tue, 03 Sep 2013 18:41:39 GMT\n\nMiddleware says hello again. Success!\n```\n这样就开启了一种新的可能，包装的handler完全手控制。\n\n### 和其他handler分享数据\n\n 在其他例子中，中间件可能需要暴露一些信息给其他中间件或者应用本身。例如nosurf需要给其他用户访问CSRF token的权限。\n 最简单是是使用一个map，但是通常不希望这样。它将http.Request 的指针作为key，其他数据作为value。下面是nosurf的例子，Go的map非线程安全，所以要自己是实现。\n\n```Go\ntype csrfContext struct {\n    token string\n    reason error\n}\n\nvar (\n    contextMap = make(map[*http.Request]*csrfContext)\n    cmMutex    = new(sync.RWMutex)\n)\n```\n 数据由Token设置：\n\n```Go\nfunc Token(req *http.Request) string {\n    cmMutex.RLock()\n    defer cmMutex.RUnlock()\n\n    ctx, ok := contextMap[req]\n    if !ok {\n            return \"\"\n    }\n\n    return ctx.token\n}\n```\n源码可以再nosurf的项目的[context.go](https://github.com/justinas/nosurf/blob/master/context.go)中找到。\n\n\n","date":"2015-11-12"},{"title":"Go Web 架构","tags":["Go","Architecture","Translate","backend","Web"],"iso8601Date":"2015-11-11T03:01:21+08:00","basename":"Go-Web-架构","body":"\n\n[原文地址](https://larry-price.com/blog/2015/06/25/architecture-for-a-golang-web-app)\n\n使用Golang来创建Web项目是一件很麻烦的事情。如果你使用Rails，那么你可能不会有这个感触。我在[Refer Madness](https://www.refer-madness.com/)中使用了下面这个架构。\n\n```bash\n-public/\n-views/\n-models/\n-utils/\n-controllers/\n-web/\n-main.go\n```\n\n我将打破这个体系，介绍各个目录的作用。在每个目录下，文件只能访问其同级或者上一级。这就意味着`utils`只能访问他自己和`models`，`web`只能访问它自己，`controllers`，`utils`，`models`。`models`只能访问它自己。我这么做是为了让层次清晰，防止出现递归依赖。现在来分析每一个目录，文件的作用。\n\n#### main.go\n\n`main.go`是创建依赖，获取环境变量，启动服务的主要文件。下面是它的实例。\n\n```Go\npackage main\n\nimport (\n  \"github.com/larryprice/refermadness/utils\"\n  \"github.com/larryprice/refermadness/web\"\n  \"github.com/stretchr/graceful\"\n  \"os\"\n)\n\nfunc main() {\n  isDevelopment := os.Getenv(\"ENVIRONMENT\") == \"development\"\n  dbURL := os.Getenv(\"MONGOLAB_URI\")\n  if isDevelopment {\n    dbURL = os.Getenv(\"DB_PORT_27017_TCP_ADDR\")\n  }\n\n  dbAccessor := utils.NewDatabaseAccessor(dbURL, os.Getenv(\"DATABASE_NAME\"), 0)\n  cuAccessor := utils.NewCurrentUserAccessor(1)\n  s := web.NewServer(*dbAccessor, *cuAccessor, os.Getenv(\"GOOGLE_OAUTH2_CLIENT_ID\"),\n    os.Getenv(\"GOOGLE_OAUTH2_CLIENT_SECRET\"), os.Getenv(\"SESSION_SECRET\"),\n    isDevelopment, os.Getenv(\"GOOGLE_ANALYTICS_KEY\"))\n\n  port := os.Getenv(\"PORT\")\n  if port == \"\" {\n    port = \"3000\"\n  }\n\n  graceful.Run(\":\"+port, 0, s)\n}\n\n```\n\n因为`main.go`实在最低的层级，所以它可以访问所有的目录：在这个例子里是`web`和`utils`。在这里获取了所有的环境变量并把它们注入到合适的地方。在`main.go`中创建了服务器，注入依赖，并且在配置的端口启动服务器。\n\n#### web\n\n`web`目录下是主要的服务代码，同时也包括了中间件代码。下面是`web`目录的内部结构：\n\n```bash\n-web/\n|-middleware/\n|-server.go\n```\n\n`server.go`包含了web server的定义。这个web server 创建了所有的web controller并且给negroni添加了中间件。下面是他的例子：\n\n```Go\npackage web\n\nimport (\n  \"github.com/codegangsta/negroni\"\n  \"github.com/goincremental/negroni-sessions\"\n  \"github.com/goincremental/negroni-sessions/cookiestore\"\n  \"github.com/gorilla/mux\"\n  \"github.com/larryprice/refermadness/controllers\"\n  \"github.com/larryprice/refermadness/utils\"\n  \"github.com/larryprice/refermadness/web/middleware\"\n  \"github.com/unrolled/secure\"\n  \"gopkg.in/unrolled/render.v1\"\n  \"html/template\"\n  \"net/http\"\n)\n\ntype Server struct {\n  *negroni.Negroni\n}\n\nfunc NewServer(dba utils.DatabaseAccessor, cua utils.CurrentUserAccessor, clientID, clientSecret,\n  sessionSecret string, isDevelopment bool, gaKey string) *Server {\n  s := Server{negroni.Classic()}\n  session := utils.NewSessionManager()\n  basePage := utils.NewBasePageCreator(cua, gaKey)\n  renderer := render.New()\n\n  router := mux.NewRouter()\n\n  // ...\n\n  accountController := controllers.NewAccountController(clientID, clientSecret, isDevelopment, session, dba, cua, basePage, renderer)\n  accountController.Register(router)\n\n  // ...\n\n  s.Use(sessions.Sessions(\"refermadness\", cookiestore.New([]byte(sessionSecret))))\n  s.Use(middleware.NewAuthenticator(dba, session, cua).Middleware())\n  s.UseHandler(router)\n  return &s\n}\n```\n\n`Server`结构体是一个`negroni.Negroni`的web server，在这个文件里有对`utils`和其他第三方包的引用，创建了一个router，一些controller，并且将controller注册到当前router。同时也引入了必要的中间件。说到中间件，下面是它的代码：\n\n```Go\npackage middleware\n\nimport (\n  \"github.com/codegangsta/negroni\"\n  \"github.com/larryprice/refermadness/utils\"\n  \"net/http\"\n)\n\ntype Database struct {\n  da utils.DatabaseAccessor\n}\n\nfunc NewDatabase(da utils.DatabaseAccessor) *Database {\n  return &Database{da}\n}\n\nfunc (d *Database) Middleware() negroni.HandlerFunc {\n  return func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n    reqSession := d.da.Clone()\n    defer reqSession.Close()\n    d.da.Set(r, reqSession)\n    next(rw, r)\n  }\n}\n```\n\n这个是通过HTTP router访问数据库session的标注中间件。基本文件是从[Brian Gesiak’s blog post on RESTful Go](http://modocache.svbtle.com/restful-go)中得到，将其修改为适合我的文件。\n\n#### controllers/\n\n这里的controller与Rails里的controller的概念很像。Controller注册自己的router，设置自己的函数调用。一个简短的例子如下：\n\n```Go\npackage controllers\n\nimport (\n  \"encoding/json\"\n  \"errors\"\n  \"github.com/gorilla/mux\"\n  \"github.com/larryprice/refermadness/models\"\n  \"github.com/larryprice/refermadness/utils\"\n  \"gopkg.in/mgo.v2/bson\"\n  \"gopkg.in/unrolled/render.v1\"\n  \"html/template\"\n  \"net/http\"\n  \"strings\"\n)\n\ntype ServiceControllerImpl struct {\n  currentUser utils.CurrentUserAccessor\n  basePage    utils.BasePageCreator\n  renderer    *render.Render\n  database    utils.DatabaseAccessor\n}\n\nfunc NewServiceController(currentUser utils.CurrentUserAccessor, basePage utils.BasePageCreator,\n  renderer *render.Render, database utils.DatabaseAccessor) *ServiceControllerImpl {\n  return &ServiceControllerImpl{\n    currentUser: currentUser,\n    basePage:    basePage,\n    renderer:    renderer,\n    database:    database,\n  }\n}\n\nfunc (sc *ServiceControllerImpl) Register(router *mux.Router) {\n  router.HandleFunc(\"/service/{id}\", sc.single)\n  // ...\n}\n\n// ...\n\ntype serviceResult struct {\n  *models.Service\n  RandomCode *models.ReferralCode\n  UserCode   *models.ReferralCode\n}\n\ntype servicePage struct {\n  utils.BasePage\n  ResultString string\n}\n\nfunc (sc *ServiceControllerImpl) single(w http.ResponseWriter, r *http.Request) {\n  data, err := sc.get(w, r)\n\n  if len(r.Header[\"Content-Type\"]) == 1 && strings.Contains(r.Header[\"Content-Type\"][0], \"application/json\") {\n    if err != nil {\n      sc.renderer.JSON(w, http.StatusBadRequest, map[string]string{\n        \"error\": err.Error(),\n      })\n      return\n    }\n    sc.renderer.JSON(w, http.StatusOK, data)\n    return\n  } else if err != nil {\n    http.Error(w, err.Error(), http.StatusBadRequest)\n  }\n\n  resultString, _ := json.Marshal(data)\n  t, _ := template.ParseFiles(\"views/layout.html\", \"views/service.html\")\n  t.Execute(w, servicePage{sc.basePage.Get(r), string(resultString)})\n}\n```\n\n#### utils/\n\n在`utils`目录下的文件提供了一些底层功能用来支持其他的代码。在这个例子中，主要是定义一个结构体来访问请求的上下文，处理session，定义一个特别的页面来继承。下面是通过访问上下文设置用户的例子：\n\n```Go\npackage utils\n\nimport (\n  \"github.com/gorilla/context\"\n  \"github.com/larryprice/refermadness/models\"\n  \"net/http\"\n)\n\ntype CurrentUserAccessor struct {\n  key int\n}\n\nfunc NewCurrentUserAccessor(key int) *CurrentUserAccessor {\n  return &CurrentUserAccessor{key}\n}\n\nfunc (cua *CurrentUserAccessor) Set(r *http.Request, user *models.User) {\n  context.Set(r, cua.key, user)\n}\n\nfunc (cua *CurrentUserAccessor) Clear(r *http.Request) {\n  context.Delete(r, cua.key)\n}\n\nfunc (cua *CurrentUserAccessor) Get(r *http.Request) *models.User {\n  if rv := context.Get(r, cua.key); rv != nil {\n    return rv.(*models.User)\n  }\n  return nil\n}\n```\n\n#### models/\n\nmodel 是为了描述数据库中的数据的数据结构。在这个例子中使用model来访问数据库，创建一个空的model，然后通过查询数据库为其赋值。下面是一个例子：\n\n```Go\npackage models\n\nimport (\n  \"gopkg.in/mgo.v2\"\n  \"gopkg.in/mgo.v2/bson\"\n  \"strings\"\n  \"time\"\n)\n\ntype Service struct {\n  // identification information\n  ID          bson.ObjectId `bson:\"_id\"`\n  Name        string        `bson:\"name\"`\n  Description string        `bson:\"description\"`\n  URL         string        `bson:\"url\"`\n  Search      string        `bson:\"search\"`\n}\n\nfunc NewService(name, description, url string, creatorID bson.ObjectId) *Service {\n  url = strings.TrimPrefix(strings.TrimPrefix(url, \"http://\"), \"https://\")\n  return &Service{\n    ID:            bson.NewObjectId(),\n    Name:          name,\n    URL:           url,\n    Description:   description,\n    Search:        strings.ToLower(name) + \";\" + strings.ToLower(description) + \";\" + strings.ToLower(url),\n  }\n}\n\nfunc (s *Service) Save(db *mgo.Database) error {\n  _, err := s.coll(db).UpsertId(s.ID, s)\n  return err\n}\n\nfunc (s *Service) FindByID(id bson.ObjectId, db *mgo.Database) error {\n  return s.coll(db).FindId(id).One(s)\n}\n\nfunc (*Service) coll(db *mgo.Database) *mgo.Collection {\n  return db.C(\"service\")\n}\n\ntype Services []Service\n\nfunc (s *Services) FindByIDs(ids []bson.ObjectId, db *mgo.Database) error {\n  return s.coll(db).Find(bson.M{\"_id\": bson.M{\"$in\": ids}}).Sort(\"name\").All(s)\n}\n\nfunc (*Services) coll(db *mgo.Database) *mgo.Collection {\n  return db.C(\"service\")\n}\n\n```\n\n#### views/\n\n将Golang的模板文件放到`views`目录下。这样，不管用什么样的模板引擎都可以直接放到`views`下。\n\n#### public/\n\n跟以前一样，这个文件都是放公开的文件的，例如`css`,`img`,`scripts`。\n\n#### 如何运行\n\n毫无疑问，我最喜欢的就是[docker](https://www.docker.com/)，因此我将使用他来运行这个应用。如果不使用docker，那么可以将文件放到`$GOPATH/src/github.com/larryprice/refermadness`,运行`go get`来获取所有的依赖，然后运行 `go run main.go`或者`go build; ./refermadness`运行程序。如果你也喜欢使用docker，那么可以直接通过`Dockerfile`来运行。\n\n```bash\nFROM golang:1.4\n\nRUN go get github.com/codegangsta/gin\n\nADD . /go/src/github.com/larryprice/refermadness\nWORKDIR /go/src/github.com/larryprice/refermadness\nRUN go get\n```\n\n同时我也很喜欢[compose](https://github.com/docker/compose)，所以我也通过compose 文件来运行所有的应用。我用了JSC ，SASS和mongodb，所以一下是我的`docker-compose.yml`文件。\n\n```Go\nmain:\n  build: .\n  command: gin run\n  env_file: .env\n  volumes:\n    - ./:/go/src/github.com/larryprice/refermadness\n  working_dir: /go/src/github.com/larryprice/refermadness\n  ports:\n    - \"3000:3000\"\n  links:\n    - db\nsass:\n  image: larryprice/sass\n  volumes:\n    - ./public/css:/src\njsx:\n  image: larryprice/jsx\n  volumes:\n    - ./public/scripts:/src\ndb:\n  image: mongo:3.0\n  command: mongod --smallfiles --quiet --logpath=/dev/null\n  volumes_from:\n    - dbvolume\ndbvolume:\n  image: busybox:ubuntu-14.04\n  volumes:\n    - /data/db\n```\n\n然后运行`docker-compose up`来运行所有的容器并启动服务器。\n\n\n","date":"2015-11-11"}]}}