{"path":"tags/javascript","templateID":3,"sharedPropsHashes":{},"localProps":{"posts":[{"author":"Travis Fischer","title":"那些值得一用的JS库","tags":["Javascript","frontend","前端","NodeJS","Node","npm"],"iso8601Date":"2018-03-10T08:00:00+08:00","basename":"JavaScript_Modules_Worth_Using","body":"\n\n本文收集了前端JS开发和NodeJS开发中的一些优秀的库和工具。\n\n## 1. 命令行工具\n\n> [np](https://github.com/sindresorhus/np) - 更好的`npm publish`\n\n如果你是一个npm作者，强烈推荐使用[np](https://github.com/sindresorhus/np)模块，它能为你轻而易举地解决更新版本、添加git发布tag和发布代码到npm，特别是当你有很多npm模块要维护的时候。\n\n> [yarn](https://yarnpkg.com/) - 更好的包管理工具，同时兼容npm\n\n虽然npm v5已经比上一个版本速度提升很多，但是个人感觉在本地开发中yarn仍然以速度和稳定性取胜。但是无论用哪个工具，你都在使用同一个npm包的数据，究竟两者孰优孰劣并没有定论，所以挑选哪个工具还是要看你的项目需求。\n\n> [prettier](https://prettier.io/) - 强烈推荐的一款代码格式化工具\n\nPrettier通过代码解析强制要求代码风格保持一致，然后用内置的规则来重新输出样式，并通过必要的代码封装来限制代码最大行数。\n\n> [now](https://zeit.co/now)\n\nNow毫无疑问是迄今为止最好的免费部署系统，以简单、稳定和功能多著称。它非常适合测试静态和动态部署，并且很方便扩充服务器。\n\n> [asciinema](https://asciinema.org/) - 录制高质量的终端(terminal)信息\n\n一款录制终端 & 代码的神器，从此分享代码告别截屏！\n\n## 2. Promise\n\n这一小节值得专门拿出来写一篇文章，尤其现在`async/await`已经成为JS的并发编程的标准。这里收集了一些Node端非常有用的Promise相关库：\n\n> [pify](https://github.com/sindresorhus/pify) - 转换callback为promise\n\n目前有很多方法都可以把过时的callback-style的代码转成promise-style，但是pify可能是其中最好的解决方案。它体积很小，同时有util.promisify(node本地接口)没有的一些细节：比如方法自动绑定等。\n\n> [p-map](https://github.com/sindresorhus/p-map) - 给并行设置限制数\n\n并行虽然很好，但是大多时候出于带宽或者计算资源的考虑需要设置一个对并行的限制，这是p-map擅长的领域。它可以取代不支持限制并行的`Promise.all()`方法。\n\n> [p-retry](https://github.com/sindresorhus/p-retry) - 给promise请求添加重新请求机制\n\n通常在发送http请求或者外部服务调用的时候可以用p-retry在外部封装一层，提高请求的健壮性。\n\n> [p-timeout](https://github.com/sindresorhus/p-timeout) - 为promise请求添加超时处理\n\n为promise请求指定一个超时时间，然后添加超时处理方案\n\n### 3. 数据抓取\n\n有很多很棒的抓取工具，有一些直接操作HTML，像[cheerio](https://github.com/cheeriojs/cheerio)，还有一个些可以模拟一个完整的浏览器环境像[puppeteer](https://github.com/GoogleChrome/puppeteer)。具体使用哪种工具还是要依赖使用场景。\n\n> [cheerio](https://github.com/cheeriojs/cheerio) - 快速、灵活和实现核心jQuery Api，服务于服务端\n\n当你想操作HTML时，Cheerio非常适合快速 & 肮脏的web数据抓取。它提供了健壮的类jQuery语法，用来遍历和处理HTML文档。在抓取远程HTML文档时，Cheerio和下面要介绍的[require-promise-native](https://github.com/request/request-promise-native)非常适合搭配一起使用。\n\n> [puppeteer](https://github.com/GoogleChrome/puppeteer) - Headless Chrome Node API\n\n和cheerio不同，puppeteer是在[headless Chrome](https://developers.google.com/web/updates/2017/04/headless-chrome)(没有UI的Chrome，供服务端自动化测试用)外包装的一层高级API，通过[开发工具协议](https://chromedevtools.github.io/devtools-protocol/)控制headless Chrome或者Chromium，它也可以通过配置来使用全部Chrome或者Chromius的功能。\n\n### 4. Node.js\n\n> [dotenv-safe](https://github.com/rolodato/dotenv-safe) - 从`.env`里加载环境变量\n\n这个模块扩展了非常流行的库[dotenv](https://github.com/motdotla/dotenv)，通过添加一个`.env.example`文件强制保证预期环境变量的存在。与原始版本一样，它为Node提供了快速的、安全的和健壮的环境变量。\n\n> [request](https://github.com/request/request)和[request-promise-native](https://github.com/request/request-promise-native) - 简单的HTTP请求客户端\n\n发送HTTP请求是一个极其常用的操作，常用的库是[request-promise-native](https://github.com/request/request-promise-native)，它封装了[request](https://github.com/request/request)库，并提供了本地ES6的`Promise`支持。\n\n> [consolidate](https://github.com/tj/consolidate.js) - Node的模板引擎整合库\n\nConsolidate可以非常漂亮的处理任何后端模板（email, html等等）。它提供了简单、稳定的各种模板引擎接口。\n\n> [execa](https://github.com/sindresorhus/execa) - 更好的`child_process`\n\n在需要执行shell命令或者spawn一个子进程时极其有用\n\n> [fs-extra](https://github.com/jprichardson/node-fs-extra) - 更好的`fs`，拥有更多方法和Promise支持\n\n### 5. 数学\n\n[d3-random](https://github.com/d3/d3-random) - 生成各种分布的随机数\n\n[d3-ease](https://github.com/d3/d3-ease) - 产生流畅动画的Easing函数\n\n### 6. 测试\n\n[ava](https://github.com/avajs/ava) - 很棒的JS test runner\n\nAva是比较新的JS单元测试工具，它具有众多JS测试库(Mocha、tape、chai和其他库)的优点，默认情况下采用并行运行的方式。\n\n[nock](https://github.com/node-nock/nock) - HTTP模拟请求\n\nNock是一个很棒的测试HTTP请求的库。如果你的Node模块需要发送HTTP请求，并且你想要对这个请求做单元测试，那么nock是你的不二之选。\n","date":"2018-03-10"},{"title":"ES2016, 2017和2018到底有哪些新东西？","author":"rajaraodv","tags":["js","JavaScript","前端","frontend","ECMAScript","ECMAScript 2016","ECMAScript 2017","ECMAScript 2018","es6","es7","async","await","async/await"],"iso8601Date":"2018-04-03T08:00:00+08:00","basename":"Here_are_examples_of_everything_new_in_ECMAScript_2016_2017_and_2018","body":"\n\n![](1_Z-9unq6Am3vekNOa5fD1xg.png)\n\nJavascript总是在发布新功能，想要一直跟上脚步不太容易，配套的demo也很少，本文旨在结合实例展示最新的18个新特性，做个技术的布道者。\n\n**下面依照版本的先后顺序开始介绍:**\n\n![](1_K09EWrqTcTwN9_dlhlzy6Q.png)\n\n## 1. Array.prototype.includes\n\n首先是数组的一个实例方法`includes`，这个方法的功能很简单：用于判断某一项是否在数组里，和这个方法功能类似的有`indexOf`，两者的区别是`indexOf`无法判断`NaN`，\n如图：\n\n```Javascript\nconst arr = [1, 2, 3, 4, NaN];\n\n// es5\nif (arr.indexOf(3) >= 0) {\n  console.log(true)\n}\n\n// es2016\nif (arr.includes(e)) {\n  console.log(true)\n}\n\n// 注：indexOf不支持检查`NaN`\narr.indexOf(NaN) // -1\narr.includes(NaN) // true\n```\n\n\n## 2. 求幂运算符\n\n第二个新功能也比较简单：**求幂运算符** -- `**`，用于取代之前的求幂方法`Math.pow`，\n如图：\n\n```Javascript\n// 之前\nMath.pow(3, 2) // 9\n\n// 现在\n3**2 // 9\n```\n\n![](1_fV_95TaY3ocgE8hlDhhv8w.png)\n\n## 1. Object.values()\n\n`Object.values`这个方法和`Object.keys`类似，都是返回一个数组，通过方法名可以直观的猜到返回的是对象的值(value)，需要注意的是：两个方法都是返回自身原型的属性，不包括原型链上的属性，如图：\n\n```Javascript\nconst cars = {BMW: 3, Tesla: 2, Toyota: 1}\n\n// es5\nconst vals = Object.keys(cars).map(key => cars[key]) \nconsole.log(vals) // [3, 2, 1]\n\n// es2016\nconst values = Object.values(cars)\nconsole.log(values) // [3, 2, 1]\n```\n\n\n## 2. Object.entries()\n\n`Object.entries()`这个方法比较有意思，有点像`Object.keys`和`Object.values`的结合体，同时返回对象的`key`和`value`，并封装在一个数组里，这个方法的好处在于你可以通过`for of`遍历一次取出key/value 或者 把`Object`转为`Map`：\n\n**例1**，遍历:\n\n```Javascript\nconst cars = { BMW: 3, Tesla: 2, Toyota: 1 }\n\n// es5的遍历方式\n// 需要把`key`取出来，再遍历\nObject.keys(cars).forEach(key => {\n  console.log(`key: ${key}, value: ${cars[key]}`)\n})\n\n// es2017\nfor (let [key, value] of Object.entries(cars)) {\n  console.log(`key: ${key}, value: ${cars[key]}`)\n}\n``` \n\n**例2**，把object直接转换为`Map`:\n\n```Javascript\nconst cars = { BMW: 3, Tesla: 2, Toyota: 1 }\n\n// es5\nconst map1 = new Map()\nObject.keys(cars).map(key => {\n  map1.set(key, cars[key])\n})\n\nconsole.log(map1) // Map { 'BMW': 3, 'Tesla': 2, 'Toyota': 1 }\n\n// es2016\nconst map2 = new Map(Object.entries(cars))\n\nconsole.log(map2) // Map { 'BMW': 3, 'Tesla': 2, 'Toyota': 1 }\n```\n\n## 3. String padding\n\nString增加了两个实例方法 -- `padStart`和`padEnd`，这两个方法可以在字符串的首/尾添加其他字符串:\n\n```Javascript\n// 'someStr'.padStart(字符数, [,添加的字符])\n\n'hello'.padStart('10', 'a') // 'aaaaahello', 添加了5个字符`a`后一共`10`个字符\n'hello'.padEnd('10', 'b') // 'hellobbbbb'\n'hello'.padStart('7') // '  hello', 在头部添加两个个空格\n```\n\n### 3.1 padStart示例\n\n```Javascript\nconst formatted = [0, 1, 12, 123, 1234, 12345].map(num =>\n  num.toString().padStart(10, '0')\n)\n\nconsole.log(formatted)\n// 输出:\n// [\n//   '0000000000',\n//   '0000000001',\n//   '0000000012,'\n//   '0000000234,'\n//   '0000001234,'\n//   '0009012345'\n// ]\n```\n\n### 3.2 padEnd示例\n\n```Javascript\nconst cars = {\n  '🚙BMW': '10',\n  '🚘Tesla': '5',\n  '🚖Lamborghini': '0'\n}\n\nObject.entries(cars).map(([name, count]) => {\n  console.log(`${name.padEnd(20, ' -')} Count: ${count.padStart(3, '0')}`)\n});\n\n//输出:\n// 🚙BMW - - - - - - -  Count: 010\n// 🚘Tesla - - - - - -  Count: 005\n// 🚖Lamborghini - - -  Count: 000\n```\n\n## 4.Object.getOwnPropertyDescriptors\n\n这个方法的作用是补充`Object.assign`的功能，在浅拷贝(shallow clone)对象的基础上，也会复制`getter`和`setter`方法：\n\n下面的例子用`Object.defineProperties`拷贝原对象`Car`到新对象`ElectricCar`来区分`Object.assign`和`Object.getOwnPropertyDescriptors`。\n\n```Javascript\nconst Car = {\n  name: 'BMW',\n  price: 100000,\n  set discount(x) {\n    this.d = x\n  }\n  get discount() {\n    return this.d\n  }\n}\n\nconsole.log(Object.getOwnPropertyDescriptor(Car, 'discount')\n// 输出:\n// {\n//   get: [Function: get],\n//   set: [Function: set],\n//   enumerable: true,\n//   configurable: true\n// }\n\nconst ElectricCar = Object.assign({}, Car)\nconsole.log(Object.getOwnPropertyDescriptor(ElectricCar, 'discount'))\n// 输出:\n// {\n//   value: undefined,\n//   writable: true,\n//   enumerable: true,\n//   configurable: true\n// }\n\n// 使用`Object.assign`创建`ElectricCar`后，属性`getter`和`setter`丢失了\n```\n\n### 使用`Object.getOwnPropertyDescriptors`后:\n\n```Javascript\nconst Car = {\n  name: 'BMW',\n  price: 100000,\n  set discount(x) {\n    this.d = x\n  }\n  get discount() {\n    return this.d\n  }\n}\n\nconst ElectricCar2 = Object.defineProperties({}, Object.getOwnPropertyDescriptors(Car))\n// 输出:\n// {\n//   get: [Function: get],  <-----👈\n//   set: [Function: set],  <-----👈\n//   enumerable: true,\n//   configurable: true \n// }\n```\n\n## 5. 在函数最后一个参数的末尾添加逗号\n\n这是个很小的一个功能点，在函数形参最后一个参数末尾添加逗号，可以避免`git blame`提示不必要的改动，\n代码示例：\n\n```Javascript\n// 假设这个函数由 `程序员_1` 创建\n// 这个函数最后一个参数`age`后没有逗号\nfunction Person(\n  name,\n  age\n) {\n  this.name = name\n  this.age = age\n}\n\n// 如果 `程序员_2` 这时有了以下修改\nfunction Person(\n  name,\n  age, /* 那么这个`,`逗号也会引起`git blame`认为 `程序员_1` 修改了这一行*/\n  gender /* 添加了新参数 */\n) { // 新添加\n  this.name = name\n  this.age = age\n  this.gender = gender // 新添加\n}\n\n// es2017对这个混淆的处理办法是:\n// 通过 `程序员_1`在`age`末尾添加`,`逗号\n\n// 更新如下:\n\n// 假设这个函数由 `程序员_1` 创建\n// 在最后一个参数`age`后添加`,`逗号\nfunction Person(\n  name,\n  age, /* 添加逗号 */\n) {\n  this.name = name\n  this.age = age\n}\n```\n\n## 6. Async/Await\n\n这个特性是目前为止最重要的一个功能，使用`async`函数可以让我们避免频繁调用*恶心的*`callback`，使代码保持干净整洁。\n\n当编译器进入`async`函数后，遇到`await`关键字会暂停执行，可以把`await`后的表达式看成一个`promise`，直到promise被`resolve`或`reject`后，函数才会恢复执行，\n具体看如下代码：\n\n```Javascript\n  \n// es5的`Promise`\nfunction getAmount(userId) {\n  getUser(userId)\n    .then(getBankBalance)\n    .then(amount => {\n      console.log(amount)\n    })\n}\n\n// es2017的`async`\nasync function getAmount2(userId) {\n  var user = await getUser(userId)\n  var amount = await getBankBalance()\n  console.log(amount)\n}\n\ngetAmount('1') // $1,000\ngetAmount2('1') // $1,000\n\nfunction getUser(userId) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve('张三')\n    }, 1000)\n  })\n}\n\nfunction getBankBalance() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (user === '张三') {\n        resolve('$1,000')\n      } else {\n        resolve('Unknown User')\n      }\n    }, 1000)\n  })\n}\n```\n\n### 6.1 Async函数本身返回一个Promise\n\n要想得到Async函数的返回值，需要把返回值当作一个promise进行`then`求值。\n\n具体看如下代码：\n\n```Javascript\nasync function doubleAndAdd(a, b) {\n  a = await doubleAfter1Sec(a)\n  b = await doubleAfter1Sec(b)\n  return a + b\n}\n\ndoubleAndAdd(1, 2).then(console.log) // 5 \n\nasync function doubleAfter1Sec(param) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(param * 2)\n    }, 1000)\n  })\n}\n```\n\n### 6.2 并行调用async/await\n\n在上一个函数`doubleAndAdd`里依次调用了两个`async`函数，但是每次调用都等待了1秒，效率很差；因为`a`和`b`之间没有耦合，所以我们可以使用`Promise.all`来并行执行这两次调用:\n\n```Javascript\nasync function doubleAndAdd(a, b) {\n  // 使用`Promise.all`\n  // 这个地方使用数组`解构`\n  // 来得到两次调用的结果\n  const [a, b] = Promise.all([doubleAfter1Sec(a), doubleAfter1Sec(b)])\n  return a + b\n}\n\ndoubleAndAdd(1, 2).then(console.log) // 5 \n\nasync function doubleAfter1Sec(param) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(param * 2)\n    }, 1000)\n  })\n}\n```\n\n### 6.3 async/await的错误处理\n\n使用`async/await`时的错误处理有很多方法：\n\n#### 1. 在函数内使用try/catch\n\n```Javascript\nasync function doubleAndAdd(a, b) {\n  try {\n    a = await doubleAfter1Sec(a)\n    b = await doubleAfter1Sec(b)\n  } catch (e) {\n    return NaN\n  }\n  return a + b\n}\n\ndoubleAndAdd('one', 2).then(console.log) // NaN\ndoubleAndAdd(1, 2).then(console.log) // 5 \n\nasync function doubleAfter1Sec(param) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      const val = param * 2\n      isNaN(val) ? reject(NaN) : resolve(val)\n    }, 1000)\n  })\n}\n```\n\n#### 2. catch 所有`await`表达式\n\n因为`await`表达式返回一个`promise`，所以我们可以在`await`表达式后直接执行`catch`来处理错误\n\n```Javascript\nasync function doubleAndAdd(a, b) {\n  a = await doubleAfter1Sec(a).catch(e => console.log(`'a' is NaN`)\n  b = await doubleAfter1Sec(b).catch(e => console.log(`'b' is NaN`))\n\n  if (!a || !b) return NaN\n  return a + b\n}\n\ndoubleAndAdd('one', 2).then(console.log) // NaN, \"a\" is NaN\ndoubleAndAdd(1, 2).then(console.log) // 5 \n\nasync function doubleAfter1Sec(param) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      const val = param * 2\n      isNaN(val) ? reject(NaN) : resolve(val)\n    }, 1000)\n  })\n}\n```\n\n#### 3. catch 整个async-await函数\n\n```Javascript\nasync function doubleAndAdd(a, b) {\n  a = await doubleAfter1Sec(a)\n  b = await doubleAfter1Sec(b)\n  return a + b\n}\n\ndoubleAndAdd('one', 2)\n  .then(console.log)\n  .catch(console.log) // 使用catch\n```\n\n![](1_X755b572fEcI0vK0fRKWkw.png)\n\n> ECMAScript目前在最终稿阶段，将会在2018年6月或7月正式推出。下面介绍的所有特性属于**stage-4**，都将成为ECMAScript 2018的一部分。\n\n## 1. 共享内存和原子性\n\n这是JS的一个高级特性，是JS引擎的核心改进。\n\n**共享内存的主要思想是： 把多线程的特性带到JS，开发者从之前由JS引擎管理内存变为自己管理内存，从而写出高性能、高并发的代码。**\n\n这个特性由一个新的全局对象[SharedArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer)来实现，这个对象在一块**共享内存空间**储存数据，这部分数据可以由JS的主线程和`web-worker`线程共享。\n\n当前，如果我们想要在JS主线程和web-worker间共享数据时，必须使用`postMessage`在不同线程间传递数据，有了`SharedArrayBuffer`后，不同的线程可以直接访问这个对象来共享数据。\n\n但是多线程间的共享内存会导致竞态条件，为了避免这种情况，引入了`原子性`的全局对象。原子性对象提供了各种方法来锁住正在被某个线程访问的内存，以保证内存安全。\n","date":"2018-04-03"},{"author":"shjie047","title":"1kb的JS框架 - Hyperapp","tags":["开发","前端","javascript","frontend","hyperapp","react","web"],"iso8601Date":"2018-04-08T08:00:00+08:00","basename":"hyperapp","body":"\n\n## 1. 概览\n\n[Hyperapp](https://github.com/hyperapp/hyperapp)是最近开源的一个前端web开发框架，体积很小 -- 只有**1.4kb**，api很简单 -- 只有**两个函数**: h和app；借鉴了React、Redux和Elm的思想,\n\n它的主要要特点是：\n\n* **最小化** -- 用最少的代码实现了同类框架(React、Vue等)的核心功能\n\n* **重实效** -- 坚持函数式编程来管理状态(state)，同时提供有效的方法来处理边际效应(side effects)比如：异步action和DOM操作\n\n* **独立性** -- 自身集成状态管理和虚拟DOM引擎(虚拟DOM支持key更新 && 生命周期事件)，没有第三方依赖\n\n\n下面用Hyperapp实现一个**Counter**的demo，实现了简单的加和减:\n\n```Javascript\n// 两个API\nimport { h, app } from \"hyperapp\"\n\n// 状态\nconst state = {\n  count: 0\n}\n\n// 用action来更新state\nconst actions = {\n  down: value => state => ({ count: state.count - value }),\n  up: value => state => ({ count: state.count + value })\n}\n\n// 用jsx来编写视图\nconst view = (state, actions) => (\n  <div>\n    <h1>{state.count}</h1>\n    <button onclick={() => actions.down(1)}>-</button>\n    <button onclick={() => actions.up(1)}>+</button>\n  </div>\n)\n\n// 把state，actions，view连接起来并渲染到页面的body元素上\napp(state, actions, view, document.body)\n```\n\n## 2. API\n\nHyperapp由两个函数API组成：**h**和**app**。\n\n**h**返回一个新的虚拟DOM节点树，**app**把一个新的app渲染到指定DOM元素上。\n\n以上的示例需要本地环境安装：编译器 -- Babel或者TypeScript，打包工具 -- Parcel或者Webpack，使用JSX来编写模板需要在**.babelrc**安装[transform plugin](https://babeljs.io/docs/plugins/transform-react-jsx)来支持:\n\n```JSON\n{\n  \"plugins\": [[\"transform-react-jsx\", { \"pragma\": \"h\" }]]\n}\n```\n\n### 2.1 JSX\n\n[JSX](https://en.wikipedia.org/wiki/React_(JavaScript_library)#JSX)是JS的语言扩展，可以写出和HTML类似的标签式组件，浏览器本身不支持JSX，需要配合编译器把JSX编译为hyperapp.h可以调用的代码。\n\n但是JSX并不是Hyperapp所必需的，可以直接使用hyperapp.h的api来直接编写组件，省去编译JSX的步骤：\n\n```Javascript\n\n// 直接用 `h` 来编写\nconst view = (state, actions) =>\n  h(\"div\", {}, [\n    h(\"h1\", {}, state.count),\n    h(\"button\", { onclick: () => actions.down(1) }, \"-\"),\n    h(\"button\", { onclick: () => actions.up(1) }, \"+\")\n  ])\n```\n\n## 3. 架构\n\nHyperapp编写的应用由三部分构成：**state**、**action**和**view**\n\n在程序初始化完成后，整个app会处于一个持续的循环执行里。通过用户或者外部事件产生的action来更新state，用virtual dom来展示view层的改动。可以把action当作一个通知Hyperapp更新状态重绘view的信号，当action处理完后，用户会看到新的状态(state)。\n\n### 3.1 State\n\n`State`是一个扁平对象，存储app的所有动态数据，用来描述app的状态。`State`在程序创建后不能直接修改，只能通过`Action`来更新。\n\n```Javascript\nconst state = {\n  count: 0\n}\n```\n`State`可以允许嵌套：\n\n```Javascript\nconst state = {\n  top: {\n    count: 0\n  },\n  bottom: {\n    count: 0\n  }\n}\n```\n\n### 3.2 Actions\n\n改变`State`的唯一方式是通过`Action`。`Action`是一个一元函数：接收一个参数，参数可以是任何类型；action通过返回**部分state**来更新**当前state**，**新的state**是action返回的**部分state**和**当前state**的组合。\n\n```Javascript\nconst actions = {\n  setValue: value => ({ value })\n}\n```\n\n`Action`还可以返回一个函数，函数接收当前state和action为参数，返回部分state:\n\n```Javascript\nconst actions = {\n  setValue: value => (state, actions) => ({value: state.count - count})\n}\n```\n\n####  3.2.1 异步Action\n\n`Action`用于处理边际效应（比如：写数据到数据库、发送一个请求到服务器，等等）并不是每次都需要返回一个值。你可以在一个action里或者回调函数里调用另外一个action。当`Action`返回`Promise`、`undefined`或者`null`时，不会触发视图重绘或状态更新。\n\n```Javascript\nconst actions = {\n  upLater: value => (state, actions) => {\n    setTimeout(actions.up, 1000, value)\n  },\n  up: value => state => ({ count: state.count + value })\n}\n```\n\n`Action`可以是一个`async`异步函数。因为async函数返回一个Promise而不是部分state，这时候需要调用另外一个action来更新state。\n\n```Javascript\nconst actions = {\n  upLater: () => async (state, actions) => {\n    await new Promise(done => setTimeout(done, 1000))\n    actions.up(10)\n  },\n  up: value => state => ({ count: state.count + value })\n}\n```\n\n### 3.2.2 嵌套的Action\n\n`Action`可以在命名空间里嵌套。更新深度嵌套的state就像在同样路径下声明一个action来更新部分state一样简单。\n\n```Javascript\nconst state = {\n  counter: {\n    count: 0\n  }\n}\n\nconst actions = {\n  counter: {\n    down: value => state => ({ count: state.count - value }),\n    up: value => state => ({ count: state.count + value })\n  }\n}\n```\n\n#### 3.2.3 操作性\n\napp函数返回一个包含action的对象，可以用来更新state。暴露这个对象到外部可以方便的和其他程序或框架交互、订阅全局事件、监听鼠标或键盘输入，等等。\n\n```Javascript\nconst main = app(state, actions, view, document.body)\n\nsetInterval(main.up, 250, 1)\nsetInterval(main.down, 500, 1)\n```\n\n### 4. View\n\n当state改变时，view函数被执行；view函数返回一个js对象，被称作virtual dom，Hyperapp根据virtual dom来更新实际的DOM节点。\n\n```Javascript\nimport { h } from \"hyperapp\"\n\nexport const view = (state, actions) =>\n  h(\"div\", {}, [\n    h(\"h1\", {}, state.count),\n    h(\"button\", { onclick: () => actions.down(1) }, \"-\"),\n    h(\"button\", { onclick: () => actions.up(1) }, \"+\")\n  ])\n```\n\n### 4.1 Virtual DOM\n\n`Virtual DOM`使用一个树结构的js对象来描述真实DOM节点，具体形式如下：\n\n```Javascript\n{\n  nodeName: \"div\",\n  attributes: {},\n  children: [\n    {\n      nodeName: \"h1\",\n      attributes: {},\n      children: [0]\n    },\n    {\n      nodeName: \"button\",\n      attributes: { ... },\n      children: [\"-\"]\n    },\n    {\n      nodeName:   \"button\",\n      attributes: { ... },\n      children: [\"+\"]\n    }\n  ]\n}\n```\n\n以上便是Hyperapp的概要，在项目使用中，由于hyperapp代码短小精炼，更易于调试和扩展，推荐感兴趣的同学试用。\n","date":"2018-04-08"}]}}