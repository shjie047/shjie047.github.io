---
author: Wm Leler
date: 2018-1-26
title: 为什么flutter使用dart ?
from: https://hackernoon.com/why-flutter-uses-dart-dd635a054ebf
tags:
    - dart
    - flutter
---

  很多语言学家相信人说出来的自然语言会影响到他们的思考。相同的道理对计算机语言成立吗？程序员使用不同的编程语言处理问题时会采用截然不同的解决方案。就像一个极端点的例子一样：计算机科学家为了鼓励更结构化的编程而取消了**goto语句**的使用。

这些跟Flutter和Dart有什么关系呢？其实关系还挺大的。在早期Flutter团队评估了大量编程语言，最后挑选了Dart的原因是它符合团队**创建用户界面**的方式。

开发者热爱Flutter很大程度上是因为Dart语言。就像一条tweet所说：

![](pic_01.jpeg)

这里有一个Dart语言的特性列表，这些特性让Dart对于Flutter来说不可或缺：

* Dart被AOT编译为快速的、可预测的本地代码，这样你可以用Dart来编写几乎所有Flutter的代码。这样不仅使Flutter运行快，还可以几乎定制任意模块（包括所以组件）。

* Dart还可以是JIT编译，以应对快节奏的开发周期和变动的工作流程（包括Flutter受欢迎的秒级以下、状态相关的hot reload）

* Dart可以轻易地创建运行在60fps的顺滑动画和变换。Dart不使用锁就可以处理对象分配和垃圾回收。和Javascript类似，Dart避免抢占式调度和共享内存（因此带来的锁）。因为Flutter app被编译为本地代码，所以Flutter不需要两者间低速的bridge（比如Javascript到native）。同时Flutter启动会更快。

* Dart让Flutter可以避免使用第三方声明式的布局语言，比如：JSX或XML，或者视觉界面编译器，因为Dart声明式、可编程的布局非常容易阅读和呈现。同时在所有布局里使用一种语言在一个地方，Flutter可以轻松地提供更高级的工具来使布局易如反掌。

* 开发者已经知道Dart很容易掌握，因为它具有对无论是使用静态语言或是动态语言的用户来说都熟悉的特性。

尽管这些特性不是Dart独有的，但是他们的结合完美地让Dart在构建Flutter时变得独一无二的强大。

![](pic_02.jpeg)

文章接下来会进一步深入到Dart的更多特性（包括它的标准库），这些特性让Dart成为了实现Flutter最好的编程语言。

### 编译和执行

`[如果你已经了解了静态语言和动态语言、AOT和JIT编译、虚拟机，那么你可以跳过这个章节]`

从历史上来看，计算机语言被分成了两类：静态语言（比如：Fortran或C，这些语言的变量在编译期是静态的）和动态语言（比如Smalltalk或者Javascript，这些语言在运行时变量的类型可以改变）。静态语言一般编译为在目标机器运行的机器码程序，在运行时直接被硬件执行。动态语言则不会产生机器码，直接被解释器执行。

当然，事情通常都会变得越来越复杂。VM--虚拟机的理念开始流行起来，它其实是一个高级的解释器，在软件里模拟一个硬件。虚拟机使一个语言移植到为新的硬件平台变得容易。在这种情况下，VM的输入语言通常是一个中间语言。例如，一个编程语言（比如Java）被编译为中间语言（字节码）然后在VM（JVM）上被执行。

除此之外，现成出现了JIT编译器。JIT编译器在程序执行时运行，动态编译。原来的编译器在程序创建时运行，现在被称作AOT编译器。

一般来说，只有静态语言才能被AOT编译为机器码，因为机器语言一般需要知道数据的类型，而在动态语言里类型在运行前不是固定的。因此，动态语言一般被解释或JIT编译。

开发中，当AOT编译完成时，它总是会导致一个很慢的开发周期（程序的一个改动和执行程序看到改变的结果）。但是AOT编译后的程序执行起来会更加可预测，不会因为代码解析而暂停，省去了运行时编译。AOT编译后的程序同时执行速度也更快（因为他们已经被编译过）。

相反，JIT编译提供了更快的开发周期，但是导致了更慢的或更不稳定的执行。特别是JIT编译器启动速度很慢，因为当程序开始运行时，JIT编译器在代码可以执行前必须解析和编译。研究表明很多人在app启动时间超过数秒后会放弃使用。

背景知识介绍完毕。如果把AOT和JIT的优势结合起来会不会很酷呢？请继续阅读。

### 编译和执行Dart

在使用Dart前，Dart团队成员在动态语言的高级编译器和虚拟机方面有了突破性进展（就像V8之于JavaScript， Strongtalk之于Smalltalk）。他们用这个经验把Dart的编译和执行变得异常灵活。

Dart是非常少有的一种完美的同时可以被AOT和JIT编译的语言。支持两种类型的编译给Dart、特别是Flutter带来了显著的优势。

在开发期间使用一个极其快速的编译器做JIT编译。之后，当app准备发布时，使用AOT编译。因此，在高级工具和编译器的帮助下，Dart兼具两种编译方式的优点：极其快速的开发周期、快速执行和启动时间。

Dart在编译期和执行期的灵活还不止于此。例如，Dart可以被编译为Javascript，所以它可以在浏览器里运行。这个允许代码在mobile和web端间复用。开发者讲到他们的代码在mobile和web间复用率达到70%。Dart同样可以被编译为机器代码在在server端使用，或者编译为Javascript搭配nodejs使用。

最后，Dart还提供了独立的VM，使用dart语言本身作为中间语言。

Dart可以高效地被AOT和JIT编译，解释，或编译为其他语言。Dart不仅编译和执行异常灵活，并且非常快。

下一节提供一个例子来展示Dart的编译速度可以改变游戏规则。。

### Stateful hot reload

Flutter最受欢迎的特性是它极其快速的hot reload。在开发期间，Flutter使用JIT编译，JIT可以在一秒内reload和继续执行代码。App的状态在reload时只要有可能就会被保留, 所以app可以从离开的状态继续执行。

![](pic_03.gif)

很难赞誉在开发时快速的hot reload的重要性，除非你自己亲身体验。开发者说它改变了开发app的方式，把它描述为就像把app画到生活中来。

Flutter的hot reload同时使测试新想法、试验新东西变得容易，为创新提供了巨大的推动力。

到此为止，我们已经讨论了Dart怎么使开发者的工作变得美好。下一节是关于Dart同样在创建流畅的app来取悦用户方面非常容易。

### 避免卡顿

一个速度快的app很棒，但是一个流畅的app更好。就算再快的动画如果中间卡顿也看起来很失败。但是，避免卡顿很困难，因为这里有很多不一样的原因。Dart有很多特性可以用来避免很多一般情况下的卡顿。

当然，（像其他语言一样）在Flutter里仍然存在写出卡顿app的可能；Dart通过更加可预测性和提供给开发者对app的顺滑更多的控制来使更好的用户体验变得容易。

结果呢？

运行在60fps，用Flutter创建的用户界面表现的比其他跨平台开发框架远远好的多。

同时不仅比跨平台app，甚至和最好的原生app一样好。

### AOT编译和"bridge"

我们已经讨论了使app顺滑的一个特性，同时也是Dart能够被AOT编译为机器码的能力。预编译的AOT代码比JIT更加可预测，因为在运行时没有暂停。

但是，AOT编译还有更大的好处，那就是避免"Javascript Bridge"。当动态语言（像Javascript）在平台里需要和本地语言交互时，他们必须通过一个bridge通信，这会导致上下文的切换，必须保存一份特别的大量的状态。这些上下文切换是双重灾难，因为他们不仅会把速度减慢，同时他们会导致严重的卡顿。

![](pic_04.png)

* 注：编译后的代码甚至也需要一个接口和平台代码通话，这个也可以称作bridge，但是通常比动态语言要求的bridge快。

### 抢占式调度，时间切片和资源共享

大部分支持多线程的计算机语言采用抢占在线程间切换。每个线程被分配一个执行的时间切片，如果它超出了他分配的时间那么线程通过使用上下文切换被抢占，但是，如果抢占在线程间共享的资源被更新时发生，那么这会导致一个race condition.

Race conditions是一个双重灾难，因为他们会导致很多严重的bug，包括让你的app崩溃和导致数据丢失，同时他们很难被发现和修复，因为他们依赖独立线程的相对时间。

解决race condition普遍的方法是给共享的资源加锁，来防止其他线程执行，但是锁住资源可能导致卡顿，或者更加严重的问题（包括死锁和卡死）。

Dart采取了不一样的方案来解决这个问题。Dart的线程叫做isolates，不会共享内存，从而避免了锁的需求。Isolates通信通过管道发送信息，这个方式和Erlang的actor或者Javascript的web worker类似。

Dart, 和JS一样是单线程，这意味着它根本不允许抢占。相应的，线程是显式的产生（通过async/await, Future, 或者Stream）。这个给了开发者对执行的更多控制权。单线程帮助开发者保证关键的函数被执行完，没有抢占。这不仅对构建用户界面是个巨大的优势，而且对server端代码也是。

当然，如果开发者忘记显示的控制，这可能会延缓其他代码的执行。但是，我们发现忘记控制通常要不忘记上锁更容易被发现和修正(因为race condition很难被发现)

### 分配和垃圾回收
